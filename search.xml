<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>生成函数</title>
      <link href="/2024/10/12/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
      <url>/2024/10/12/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>生成函数,又叫</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NumberTheory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树剖</title>
      <link href="/2024/10/12/%E6%A0%91%E5%89%96/"/>
      <url>/2024/10/12/%E6%A0%91%E5%89%96/</url>
      
        <content type="html"><![CDATA[<p>Flu:长大以后,我要学树剖,麻麻可高兴了,给我爱吃的大嘴巴子…</p><p>非得学一些用不到的算法干啥…</p><h2 id="代码解释">代码解释</h2><h3 id="处理u到v的最短路径">处理u到v的最短路径</h3><p>id就是dfn.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qRange</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;<span class="comment">//当两个点不在同一条链上 </span></span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])<span class="built_in">swap</span>(x,y);<span class="comment">//把x点改为所在链顶端的深度更深的那个点</span></span><br><span class="line">        res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[x]],id[x]);<span class="comment">//ans加上x点到x所在链顶端 这一段区间的点权和</span></span><br><span class="line">        ans+=res;</span><br><span class="line">        ans%=mod;<span class="comment">//按题意取模 </span></span><br><span class="line">        x=fa[top[x]];<span class="comment">//把x跳到x所在链顶端的那个点的上面一个点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直到两个点处于一条链上</span></span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y])<span class="built_in">swap</span>(x,y);<span class="comment">//把x点深度更深的那个点</span></span><br><span class="line">    res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[y]);<span class="comment">//这时再加上此时两个点的区间和即可</span></span><br><span class="line">    ans+=res;</span><br><span class="line">    <span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理rt为根的子树">处理rt为根的子树</h3><p>结论:树rt的子树的区间是 <code>[dfn[n],dfn[n]+siz[n]-1]</code> .</p><p>所以这玩意比两个点还好改.</p><h2 id="树剖解决的问题">树剖解决的问题</h2>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网页收藏夹</title>
      <link href="/2024/10/07/%E7%BD%91%E9%A1%B5%E6%94%B6%E8%97%8F%E5%A4%B9/"/>
      <url>/2024/10/07/%E7%BD%91%E9%A1%B5%E6%94%B6%E8%97%8F%E5%A4%B9/</url>
      
        <content type="html"><![CDATA[<p>不常用的网页会放到这里.</p><h2 id="游戏">游戏</h2><h2 id="OJ">OJ</h2>]]></content>
      
      
      <categories>
          
          <category> OTH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OTH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux笔记</title>
      <link href="/2024/09/23/Linux%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/09/23/Linux%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>舍友今天告诉我说是这周五多了一节Linux课,地点是在计算机楼…哦豁完蛋,Flu准备花几天时间速通一下Linux,真是没办法…</p><h2 id="Linux史">Linux史</h2><p>妈的,想不通为什么啥课都他妈要先讲讲历史…讲历史就算了,还他妈考试考,这就是什么逼东西…</p><p>咕咕,Flu要尽快学会使用Linux.</p><h2 id="使用">使用</h2><h3 id="Putty登录简述">Putty登录简述</h3><h3 id="管理员">管理员</h3><p>root,根用户.拥有最高权限.<br>普通用户的提示符是 <code>$</code> ,管理员的命令提示符是 <code>#</code> .(这个可以设置,丰富系统信息)</p><h3 id="命令">命令</h3><p>格式是 <code>$ 命令 [-选项] [参数]</code> 表示三个字段.</p><h3 id="简单的命令手册">简单的命令手册</h3><p><code>passwd</code> :修改密码.<br><code>passwd username</code> :修改别人密码.(显然,只有管理员可以)(root用户创建新用户时分配初始口令)<br><code>exit</code> :退出系统.<br><code>logout</code> :退出系统.<br><code>[Ctrl+d]</code> :退出系统.<br><code>date</code> :系统告诉你当前时间.<br><code>:  </code> :<br>`` :</p>]]></content>
      
      
      <categories>
          
          <category> OTH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OTH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICPC网络赛</title>
      <link href="/2024/09/21/ICPC%E7%BD%91%E7%BB%9C%E8%B5%9B/"/>
      <url>/2024/09/21/ICPC%E7%BD%91%E7%BB%9C%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>第三场网络赛,我们的新队员终于来了,我们队终于不是倒数第一了…</p><p>而且是正数第十一…终于能超过劳伦斯哥哥了,开心.</p><h2 id="收获">收获</h2><ol><li>我学了一个假的Dev_C++…新队友是四指打字的,速度不清楚,反正打起字来空格用的比较多,码风是标准的高中OIer码风,算数之间空格加的多,大括号另起一行.</li></ol><blockquote><p>Flu觉得有必要练习一下学习如何使用Dev_C++.</p></blockquote><ol start="2"><li>Flu第一次做出来期望题,居然是在考场…</li></ol><blockquote><p>有必要多看看期望题.</p></blockquote><ol start="3"><li>手滑多交了两发.A题读假了导致浪费了至少一个小时,Flu的高低位输出错了导致至少多半个小时,队友开的都快出来了Flu才改好…</li></ol><blockquote><p>不错,最后一场Flu做对了两个题提供了一个题的板子,也算功德圆满,没沦落为战犯.</p></blockquote><ol start="4"><li>发现浏览器的一个命令: <code>site:xxx.com</code> 可以锁定搜索范围就是该网页.</li></ol><h2 id="补题">补题</h2><h3 id="2L">2L</h3><p>系统初始时会给你一个随机 $[1,T]$ 的值 $t_0$ ,每过一秒, $t_0$ 会自动减1,减完之后你可以选择刷新页面或者不刷新等着 $t_0$ 变成0,从第0秒到 $t_0$ 变成0的这段时间被称作罚时,你希望最小化罚时期望.</p><p>这个题意外地很简单…我们发现每一次刷新都是随机的,所以可以转移.直接设当前期望是 $E$ ,以及罚时为 $[1,x]$ 时不动等自然变成0, $[x+1,T]$ 时手动刷新,可以列出方程<br>$$E=\frac1T\frac{(1+x)x}2+\frac{T-x}T(1+E)$$<br>解一下发现是一个关于T的基本不等式.最小值取在 $x=\sqrt{2T}$ 的位置.<br>题解:从这里开始检查 $x=\lfloor\sqrt{2T}\rfloor$ 和 $\lceil\sqrt{2T}\rceil$ 即可.<br>直接暴力检查.中间因为卡了一下快读(其实是Flu多检查了一下x-1的情况),还T了一发.</p>]]></content>
      
      
      <categories>
          
          <category> OTH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Contest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分图</title>
      <link href="/2024/09/19/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
      <url>/2024/09/19/%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>二分图就是,点可以分成两拨,左边会和右边连线,然后左边或右边都不会有连向自己的线.</p><p>今天碰到了一个很有意思的题.特此讲一下二分图的匈牙利算法.</p><ol><li>有一辆大巴车,每排能坐两个人,每个人有两个希望坐上的排数,请你给出最多能使多少人满足愿望.</li></ol><p>如何解决一个点能匹配两个人的问题呢?我们可以扩大点集,让人同时和a+n的点连线.这样就可以转换为一个二分图了,直接跑最大匹配就行.</p><p>拓展:貌似点能承受的个数变成 $f(n)$ 也行,只需要简简单单装到一个umap里面就行了.</p>]]></content>
      
      
      <categories>
          
          <category> Graph&amp;Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希</title>
      <link href="/2024/09/18/%E5%93%88%E5%B8%8C/"/>
      <url>/2024/09/18/%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<p>如何辨别哈希题?大概就通过一句话:</p><blockquote><p>当需要用 $Θ(1)$ 的时间快速比较两个 $Θ(n)$ 的东西时.</p></blockquote><p>哈希是干嘛的?提供一种映射关系,能够把字符串或者树通过某种加密关系换算成一个数,从而进行比较或者直接排序.</p><p>自然,撞哈希的概率关乎哈希算法的核心.</p><h2 id="生日悖论">生日悖论</h2><p>大概意思就是,任意约 $\sqrt n$ 个元素的时候元素相同的概率就会很高(n是值域).为了防止撞哈希,我们要让值域尽可能大(也就是选择1e16-1e18级别的质数).</p><h2 id="二维哈希">二维哈希</h2><p>矩阵哈希,要求 $O(1)$ 求出相同大小的子矩阵的哈希值.</p><p>我们要从矩阵中提取一个大小为(y,x)的矩阵,咋办?<br>首先要预处理阶乘(处理到矩阵行列最大值就可以了).二位哈希采取双进制的操作,一个是行之间的进制位(1299709),另一个是列之间乘再加的进制位(1e9+7).</p><p>然后要建立哈希表.由于二维哈希是前缀式的,所以要乘上一位再加这一位的数据.然后再前缀和一样的乘,每一位乘列的进制位.参考代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">p1[<span class="number">0</span>]=p2[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">p1[i]=p1[i<span class="number">-1</span>]*dom;</span><br><span class="line">p2[i]=p2[i<span class="number">-1</span>]*mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">x[i][j]=x[i][j<span class="number">-1</span>]*dom+<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">y[i][j]=y[i][j<span class="number">-1</span>]*dom+<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">x[i][j]+=x[i<span class="number">-1</span>][j]*mod;</span><br><span class="line">y[i][j]+=y[i<span class="number">-1</span>][j]*mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公式:<br>$$ask(x_1,x_2,y_1,y_2)=h[x_2][y_2]-h[x_2][y_1-1]*base_1[y_2-y_1+1]-h[x_1-1][y_2]*base_2[x_2-x_1+1]-h[x_1-1][y_1-1]*base_1[y_2-y_1+1]*base_2[x_2-x_1+1]$$<br>参考代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rp=y[i][j]-y[i-k][j]*p2[k]-y[i][j-k]*p1[k]+y[i-k][j-k]*p2[k]*p1[k];</span><br><span class="line"><span class="comment">//p2是1e9+7,p1是小的行之间的质数,k是子矩阵长度</span></span><br></pre></td></tr></table></figure><p>好像子矩阵都可以O(1)求.</p><h2 id="字符串哈希">字符串哈希</h2><p><s>Flu刚开始学字符串哈希的时候真的就是只学哈希来了,umap该开的还是开,字符串哈希完了装umap里,乐</s></p><p>字符串哈希,就是把一段字符串哈希变成一个数(双哈希是变成一对数),然后可以进行排序,然后直接检测有多少哈希值就行了(也就是多少种不同的字符串).</p><p>字符串哈希一般都是进制哈希.主要分为三种实现方法:<strong>自然溢出法(也就是模 $2^64$),单模哈希法(一个很大的质数),双模哈希(返回一对哈希值,据说很难卡掉)</strong>.</p><h2 id="例题">例题</h2><ol><li>矩阵哈希:给你两个矩阵,问两个矩阵中最大的重合子矩阵的大小(边长)是多少.</li></ol><p>我们发现边长是单调的,于是考虑二分.设 $k$ 是当前查验的边长.我们把两个矩阵的所有子矩阵直接哈希加到哈希表里面,然后排个序,直接比较(采用umap可以再掉一个log).时间复杂度是 $O(n^2\log^2n)$ .</p><h2 id="手写哈希表">手写哈希表</h2><p>一般而言有两种方式:拉链法和顺次法.</p><p>我们开一段连续空间,然后在空间内提供哈希算法,模上空间大小,大概就是实际的存储位置.<br><strong>拉链法</strong>:每个单点是一个链表,存储的时候如果哈希冲突就链表加一个节点,访问的时候遍历链表.<br><strong>顺次法</strong>:存储的时候如果哈希冲突,直接顺次访问(n+1),(n+2)等元素.</p>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟退火</title>
      <link href="/2024/09/12/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"/>
      <url>/2024/09/12/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/</url>
      
        <content type="html"><![CDATA[<p>很简单,我们逐渐退火让答案稳定在某段区间内.</p><p>算法不讲解了,什么以多项式概率接受啥的哪都没用,主要讲怎么应用模拟退火.</p><p>个人认为比较困难的点是如何&quot;渐进地&quot;生成新的逼近的随机答案,不然模拟退火就是单纯的随机数碰答案.</p><h2 id="二元函数求最值">二元函数求最值</h2><h2 id="三分xy的情况">三分xy的情况</h2><p>我们以吊打xxx为例.加入x值定死,势能变化随y是一个单峰函数.</p><p>也就是说,我们可以三分y从而达到理想效果.</p><p>如何三分?考虑一个单峰,假如落在三分中间,那么怎么收缩都是涵盖的.<br>假如没有,我们三分的两个点会是一个明显递增或者递减的趋势,此时收紧,也就是说一次收缩大概1/3,剩下的2/3接着三分即可;</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率与组合数学</title>
      <link href="/2024/09/12/%E2%80%9C%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E2%80%9D/"/>
      <url>/2024/09/12/%E2%80%9C%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<p>万恶之源组合数学.以及概率.</p><h2 id="插板法">插板法</h2><p>求 $a_1+…+a_k=n$ 的正整数解的个数.答案就是<br>$$\binom{n-1}{k-1}$$<br>非负整数解:借数.<br>$$\binom{n+k-1}{n}$$<br>每组至少要分到 $a_i$ 个呢?假设 $x’$ 是删完必须要加的,我们就转换为求非负解了.<br>$$\binom{n-\sum a_i+k-1}{n-\sum a_i}$$<br>不相邻排列:其实还是借数插在中间,然后组合.<br>$$\binom{n-k+1}{k}$$</p><h2 id="组合数公式">组合数公式</h2><p>$$\binom nm=\binom n{n-m}$$<br>$$\binom nk+\binom n{k+1}=\binom{n+1}k$$<br>$$\binom nk=\frac nk\binom{n-1}{k-1}$$<br>$$\binom nm=\binom n{m-1}+\binom{n-1}{m-1}$$<br>DP求杨辉三角的时候用这个.<br>$$\sum_{i=0}^n\binom ni=2^n$$<br>二项式定理取a=1,b=1的特殊情况.<br>$$\sum_{i=0}^n(-1)^i\binom ni=[n=0]$$<br>二项式定理取a=1,b=-1的特殊情况.<br>$$\sum_{i=0}^m\binom ni\binom m{n-i}=\binom{n+m}m,(n\ge m)$$<br>拆组合数的式子.某些数据结构题会遇到.<br>$$\sum_{i=0}^n\binom ni^2=\binom{2n}n$$<br>上一个式子的特殊情况(n=m).<br>$$\sum_{i=0}^ni\binom ni=n2^{n-1}$$<br>求导可证.<br>$$\sum_{i=0}^ni^2\binom ni=\frac{n(n+1)}22^{n-1}$$<br>也是多项式求导可证.<br>$$\sum_{i=0}^n\binom ik=\binom {n+1}{k+1}$$<br>子集分析可证.<br>$$\binom nr\binom rk=\binom nk\binom{n-k}{r-k}$$<br>定义证明.<br>$$\sum_{i=0}^n\binom{n-i}i=F_{n+1}$$<br>其中, $F_n$ 是斐波那契数列.</p><p><strong>多重组合数</strong> :多重集的排列数就是多重组合数.多重集的排列可以理解为有一个集合 $S={n_1a_1,n_2a_2,…,n_ka_k}$ ,有这么多种相同元素,他的全排列叫做多重组合数,公式<br>$$\binom{n}{n_1,n_2,…,n_k}=\frac{n!}{\prod_{i=1}^kn_i!}$$</p><h2 id="圆排列">圆排列</h2><p>部分圆排列公式:<br>$$Q_n^r=\frac{A_n^r}r=\frac{n!}{r\times(n-r)!}$$</p><h2 id="二项式反演">二项式反演</h2><p>设 $f_n$ 是n个元素形成特定结构的方案数, $g_n$ 是从n个元素选 $i,i\ge0$ 个元素形成结构的方案数.根据f求g有<br>$$g_n=\sum_{i=0}^n\binom nif_i$$<br>根据g求f则有<br>$$f_n=\sum_{i=0}^n\binom ni(-1)^{n-i}g_i$$<br>这个逆推的过程就叫二项式反演.</p><h2 id="容斥原理">容斥原理</h2><p>$$\left|\bigcup_{i=1}^nS_i\right|=\sum_{m=1}^n(-1)^{m-1}\sum_{a_i&lt;a_{i+1}}\left|\bigcap_{i=1}^mS_{a_i}\right|$$<br>下面是求交的容斥.<br>$$\left|\bigcap_{i=1}^nS_i\right|=|U|-\left|\bigcup_{i=1}^n\overline{S_i}\right|$$<br><strong>容斥模型</strong> :式子<br>$$\left|\bigcap_{a_i&lt;a_{i+1}}^{1\le i\le k}S_{a_i}\right|$$<br>的不定方程形式是<br>$$\sum_{i=1}^nx_i=m-\sum_{i=1}^k(b_{a_i}+1)$$</p><h2 id="容斥应用">容斥应用</h2><ol><li>硬币计数:给四种硬币的面值,n次询问每次询问给出四种硬币的数量以及s表示这么多个硬币能够拼凑出s的方案数.</li></ol><p>套模型:也就是求解<br>$$\sum_{i=1}^4C_ix_i=S-\sum_{i=1}^kC_{a_i}(D_{a_i}+1)$$<br>我们首先考虑无限金币,此时就是完全背包.假如一枚金币超过了应当的容量,就要减去对应的差值,枚举子集即可.</p><h2 id="常见误区">常见误区</h2><ol><li>误用组合数<br>概述:由于上一个选了之后会影响下一次选的概率,导致单纯组合数的结果并不是概率出来的结果.</li></ol><blockquote><p>例子:n张A票n张B票,买票的时候是抛硬币决定卖哪张票,问最后两个位置是相同票的概率,此时设想第一位选了一种的时候第二位会发生概率变换导致单纯组合数的概率并不是真正的概率.(问题出在结果判定上,假如没另一种票了就直接剩下的一样,也就是说组合数的概率不一样)<br>$$\xcancel{\frac{n-1}{2n-1}}$$<br>正解:DP,其实也能算组合数,假设最后两张票不一样,就会是前2n-2张票有n-1张A和B票.这个时候的概率就是<br>$$P=C^{n-1}_{2n-2}\Big(\frac12\Big)^{2n-2}=\frac{(2n-2)!}{4^{n-1}(n-1)!(n-1)!}$$<br>实现O(n)计算.答案是1-P.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NumberTheory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三角函数库</title>
      <link href="/2024/09/11/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%BA%93/"/>
      <url>/2024/09/11/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>常见的三角函数库.以及 <code>float</code> , <code>double</code> 范围.</p><h2 id="float">float</h2><p>范围大概是 <code>1e-38~1e38</code> .精度大概是7位.</p><h2 id="double">double</h2><p>范围: <code>1e-308~1e308</code> .精度大概是15-16位.</p><h2 id="三角函数">三角函数</h2><p><code>sin</code><br><code>cos</code><br><code>tan</code><br><code>asin</code><br><code>acos</code><br><code>atan</code><br><code>atan2(double y,double x)</code> :传入 $(y,x)$ ,输出与 $x$ 轴正方向角度(坐标轴下是负值).</p><p>参数: <code>sin</code> , <code>sinf</code> , <code>sinl</code> ,其实都差不多,单纯是传入参数的区别.</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万能欧几里得</title>
      <link href="/2024/09/10/%E4%B8%87%E8%83%BD%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
      <url>/2024/09/10/%E4%B8%87%E8%83%BD%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<p>万能欧几里得推式子的时间.</p><p>万能欧几里得的作用是求一些类似辗转相除的算法,需要递归求解的东西.万能欧几里得的泛用性在于主板子基本不用换,只需要稍微修改合并部分的代码.</p><p>可以使用矩阵的思想.</p><ol><li>求<br>$$\sum_{i=0}^{n}\left\lfloor\frac{ai+b}{c}\right\rfloor, \sum_{i=0}^{n}\left\lfloor\frac{ai+b}{c}\right\rfloor^{2}, \sum_{i=0}^{n}i\left\lfloor\frac{ai+b}{c}\right\rfloor $$<br>设<br>$$f(x)=\lfloor\frac{Px+R}Q\rfloor $$<br>求：<br>$$\sum_{i=1}^nf(i),\sum_{i=1}^nf^2(i),\sum_{i=1}^nif(i)$$<br>下文设$y=f(x)$,即求：<br>$$A=\sum y,B=\sum y^{2},C=\sum xy$$<br>一般万欧都需要维护$U$和$R$的数量(记为$u$和$r$).</li></ol><p>合并两段信息$I_0$与$I_{1}$,结果为$I$ ,考虑增量:<br>$$y\leftarrow y_1+u_0 \<br>x\leftarrow x_1+r_0$$<br>$$\begin{aligned}<br>A-A_0&amp;=\sum y \<br>&amp;=\sum(y_1+u_0) \<br>&amp;=\sum y_1+u_0r_1 \<br>&amp;=A_1+u_0r_1 \<br>B-B_{0} &amp;=\sum y^2 \<br>&amp;=\sum(y_1+u_0)^2 \<br>&amp;=\sum y_1^2+2u_0\sum y_1+u_0^2r_1 \<br>&amp;=B_1+2u_0A_1+u_0^2r_1 \<br>C-C_0 &amp;=\sum xy \<br>&amp;=\sum(x_1+r_0)(y_1+u_0) \<br>&amp;=\sum x_1y_1+u_0\sum x_1+r_0\sum y_1+u_0r_0r_1 \<br>&amp;=C_1+u_0\frac{r_1(r_1+1)}2+r_0A_1+u_0r_0r_1<br>\end{aligned}$$<br>也就是说 $\sum$ 里面(y)加 $u$ ,外面加 $r$ .</p><h2 id="弊端">弊端</h2><p>$$\sum\sqrt{y},\sum x^y,\sum a^{xy},\sum2^{2^y},\sum Asin(wy+\phi)$$<br>由于单维影响无法差分线性,即我们无法设计出一个好的矩阵来表达其值,所以上述式子均无法计算.</p><p>崩:loj138没调出来.<br>loj6440.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> enter fout&lt;&lt;<span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> space fout&lt;&lt;<span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dot fout&lt;&lt;<span class="string">&quot;,&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> oui fout&lt;&lt;<span class="string">&quot;Yes&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> non fout&lt;&lt;<span class="string">&quot;No&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si fout&lt;&lt;<span class="string">&quot;?&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> fastio&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> bufl=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> base1[<span class="number">16</span>]=&#123;<span class="number">1</span>,<span class="number">1e-1</span>,<span class="number">1e-2</span>,<span class="number">1e-3</span>,<span class="number">1e-4</span>,<span class="number">1e-5</span>,<span class="number">1e-6</span>,<span class="number">1e-7</span>,<span class="number">1e-8</span>,<span class="number">1e-9</span>,<span class="number">1e-10</span>,<span class="number">1e-11</span>,<span class="number">1e-12</span>,<span class="number">1e-13</span>,<span class="number">1e-14</span>,<span class="number">1e-15</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> base2[<span class="number">16</span>]=&#123;<span class="number">1</span>,<span class="number">1e1</span>,<span class="number">1e2</span>,<span class="number">1e3</span>,<span class="number">1e4</span>,<span class="number">1e5</span>,<span class="number">1e6</span>,<span class="number">1e7</span>,<span class="number">1e8</span>,<span class="number">1e9</span>,<span class="number">1e10</span>,<span class="number">1e11</span>,<span class="number">1e12</span>,<span class="number">1e13</span>,<span class="number">1e14</span>,<span class="number">1e15</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IN</span>&#123;</span><br><span class="line">FILE *IT;<span class="type">char</span> ibuf[bufl],*is=ibuf,*it=ibuf;</span><br><span class="line"><span class="built_in">IN</span>()&#123;IT=stdin;&#125;<span class="built_in">IN</span>(<span class="type">char</span> *a)&#123;IT=<span class="built_in">fopen</span>(a,<span class="string">&quot;r&quot;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getChar</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(is==it)&#123;it=(is=ibuf)+<span class="built_in">fread</span>(ibuf,<span class="number">1</span>,bufl,IT);<span class="keyword">if</span>(is==it)<span class="keyword">return</span> EOF;&#125;<span class="keyword">return</span> *is++;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getInt</span><span class="params">(Temp &amp;a)</span></span>&#123;a=<span class="number">0</span>;<span class="type">int</span> b=<span class="number">0</span>,c=<span class="built_in">getChar</span>();<span class="keyword">while</span>(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)b^=(c==<span class="number">45</span>),c=<span class="built_in">getChar</span>();<span class="keyword">while</span>(c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>)a=(a&lt;&lt;<span class="number">1</span>)+(a&lt;&lt;<span class="number">3</span>)+c<span class="number">-48</span>,c=<span class="built_in">getChar</span>();<span class="keyword">if</span>(b)a=-a;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getDouble</span><span class="params">(Temp &amp;a)</span></span>&#123;a=<span class="number">0</span>;<span class="type">int</span> b=<span class="number">0</span>,c=<span class="built_in">getChar</span>(),d=<span class="number">0</span>;__int128 e=<span class="number">0</span>,f=<span class="number">0</span>;<span class="keyword">while</span>(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)b^=(c==<span class="number">45</span>),c=<span class="built_in">getChar</span>();<span class="keyword">while</span>(c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>)e=(e&lt;&lt;<span class="number">1</span>)+(e&lt;&lt;<span class="number">3</span>)+c<span class="number">-48</span>,c=<span class="built_in">getChar</span>();<span class="keyword">if</span>(c==<span class="number">46</span>)&#123;c=<span class="built_in">getChar</span>();<span class="keyword">while</span>(c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>)d++,f=(f&lt;&lt;<span class="number">1</span>)+(f&lt;&lt;<span class="number">3</span>)+c<span class="number">-48</span>,c=<span class="built_in">getChar</span>();&#125;a=e+base1[d]*f;<span class="keyword">if</span>(b)a=-a;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">char</span> &amp;a)&#123;a=<span class="built_in">getChar</span>();<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">char</span> *a)&#123;<span class="keyword">do</span>&#123;*a=<span class="built_in">getChar</span>();&#125;<span class="keyword">while</span>(*a&lt;=<span class="number">32</span>);<span class="keyword">while</span>(*a&gt;<span class="number">32</span>)*++a=<span class="built_in">getChar</span>();*a=<span class="number">0</span>;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(string &amp;a)&#123;<span class="type">char</span> b=<span class="built_in">getChar</span>();<span class="keyword">while</span>(b&lt;=<span class="number">32</span>)b=<span class="built_in">getChar</span>();<span class="keyword">while</span>(b&gt;<span class="number">32</span>)a+=b,b=<span class="built_in">getChar</span>();<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">int</span> &amp;a)&#123;<span class="built_in">getInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">long</span> <span class="type">long</span> &amp;a)&#123;<span class="built_in">getInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(__int128 &amp;a)&#123;<span class="built_in">getInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">float</span> &amp;a)&#123;<span class="built_in">getDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">double</span> &amp;a)&#123;<span class="built_in">getDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">long</span> <span class="type">double</span> &amp;a)&#123;<span class="built_in">getDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OUT</span>&#123;</span><br><span class="line">FILE *IT;<span class="type">char</span> obuf[bufl],*os=obuf,*ot=obuf+bufl;<span class="type">int</span> Eps;<span class="type">long</span> <span class="type">double</span> Acc;</span><br><span class="line"><span class="built_in">OUT</span>()&#123;IT=stdout,Eps=<span class="number">6</span>,Acc=<span class="number">0.5</span>;&#125;<span class="built_in">OUT</span>(<span class="type">char</span> *a)&#123;IT=<span class="built_in">fopen</span>(a,<span class="string">&quot;w&quot;</span>),Eps=<span class="number">6</span>,Acc=<span class="number">0.5</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ChangEps</span><span class="params">(<span class="type">int</span> x=<span class="number">6</span>)</span></span>&#123;Eps=x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">flush</span><span class="params">()</span></span>&#123;<span class="built_in">fwrite</span>(obuf,<span class="number">1</span>,os-obuf,IT);os=obuf;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putChar</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;*os++=a;<span class="keyword">if</span>(os==ot)<span class="built_in">flush</span>();&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putInt</span><span class="params">(Temp a)</span></span>&#123;<span class="keyword">if</span>(a&lt;<span class="number">0</span>)&#123;<span class="built_in">putChar</span>(<span class="number">45</span>);a=-a;&#125;<span class="keyword">if</span>(a&lt;<span class="number">10</span>)&#123;<span class="built_in">putChar</span>(a+<span class="number">48</span>);<span class="keyword">return</span>;&#125;<span class="built_in">putInt</span>(a/<span class="number">10</span>);<span class="built_in">putChar</span>(a%<span class="number">10</span>+<span class="number">48</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putLeading</span><span class="params">(Temp a,<span class="type">int</span> b)</span></span>&#123;<span class="keyword">if</span>(!b)<span class="keyword">return</span>;<span class="built_in">putLeading</span>(a/<span class="number">10</span>,b<span class="number">-1</span>);<span class="built_in">putChar</span>(a%<span class="number">10</span>+<span class="number">48</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putDouble</span><span class="params">(Temp a)</span></span>&#123;<span class="keyword">if</span>(a&lt;<span class="number">0</span>)&#123;<span class="built_in">putChar</span>(<span class="number">45</span>);a=-a;&#125;__int128 b=a;<span class="built_in">putInt</span>(b);a-=b;a*=base2[Eps];b=a+Acc;<span class="built_in">putChar</span>(<span class="number">46</span>);<span class="built_in">putLeading</span>(b,Eps);&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">char</span> a)&#123;<span class="built_in">putChar</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> <span class="type">char</span> *a)&#123;<span class="keyword">while</span>(*a)<span class="built_in">putChar</span>(*a++);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(string a)&#123;<span class="keyword">for</span>(<span class="keyword">auto</span> c:a)<span class="built_in">putChar</span>(c);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">int</span> a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">long</span> <span class="type">long</span> a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(__int128 a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">unsigned</span> <span class="type">int</span> a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">unsigned</span> __int128 a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">float</span> a)&#123;<span class="built_in">putDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">double</span> a)&#123;<span class="built_in">putDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">long</span> <span class="type">double</span> a)&#123;<span class="built_in">putDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">~<span class="built_in">OUT</span>()&#123;<span class="built_in">flush</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">fastio::IN fin;</span><br><span class="line">fastio::OUT fout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">long</span> <span class="type">long</span> p=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">long</span> <span class="type">long</span> mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">qqp</span><span class="params">(T1 b,T2 po)</span></span>&#123;</span><br><span class="line">T1 res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(po&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(po&amp;<span class="number">1</span>)</span><br><span class="line">res=res*b%p;</span><br><span class="line">b=b*b%p;</span><br><span class="line">po&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> k1,k2;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> C[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> u,r,dat[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="built_in">node</span>(<span class="type">long</span> <span class="type">long</span> a=<span class="number">0</span>,<span class="type">long</span> <span class="type">long</span> b=<span class="number">0</span>):<span class="built_in">u</span>(a),<span class="built_in">r</span>(b)&#123;<span class="built_in">memset</span>(dat,<span class="number">0</span>,<span class="keyword">sizeof</span> dat);&#125;</span><br><span class="line">~<span class="built_in">node</span>()&#123;&#125;</span><br><span class="line">node <span class="keyword">operator</span>=(node io)&#123;</span><br><span class="line">u=io.u;</span><br><span class="line">r=io.r;</span><br><span class="line"><span class="built_in">memcpy</span>(dat,io.dat,<span class="keyword">sizeof</span> dat);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span>*(node io)&#123;</span><br><span class="line"><span class="function">node <span class="title">res</span><span class="params">((u+io.u)%mod,(r+io.r)%mod)</span></span>;</span><br><span class="line"><span class="built_in">memcpy</span>(res.dat,dat,<span class="keyword">sizeof</span> dat);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> uu=u%mod,rr=r%mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k1;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k2;++j)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> ii=<span class="number">0</span>,t1=<span class="number">1</span>;ii&lt;=i;++ii,t1=t1*uu%mod)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> jj=<span class="number">0</span>,t2=<span class="number">1</span>;jj&lt;=j;++jj,t2=t2*rr%mod)&#123;</span><br><span class="line">res.dat[i][j]=(res.dat[i][j]+(C[i][ii]*C[j][jj]*t1%mod*t2%mod*io.dat[i-ii][i-jj])%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">node <span class="title">qp</span><span class="params">(node b,<span class="type">long</span> <span class="type">long</span> po)</span></span>&#123;</span><br><span class="line">node res;</span><br><span class="line"><span class="keyword">while</span>(po&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(po&amp;<span class="number">1</span>)</span><br><span class="line">res=res*b;</span><br><span class="line">b=b*b;</span><br><span class="line">po&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">vargcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> c,<span class="type">long</span> <span class="type">long</span> n,node fu,node fr)</span></span>&#123;</span><br><span class="line">b%=c;</span><br><span class="line"><span class="keyword">if</span>(a&gt;=c)<span class="keyword">return</span> <span class="built_in">vargcd</span>(a%c,b,c,n,fu,<span class="built_in">qp</span>(fu,a/c)*fr);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> m=(a*n+b)/c;</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">qp</span>(fr,n);</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">qp</span>(fr,(c-b<span class="number">-1</span>)/a)*fu*<span class="built_in">vargcd</span>(c,c-b<span class="number">-1</span>,a,m<span class="number">-1</span>,fr,fu)*<span class="built_in">qp</span>(fr,n-(c*m-b<span class="number">-1</span>)/a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">U</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span>,<span class="title">R</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> t,a,b,c,n;</span><br><span class="line">fin&gt;&gt;t;</span><br><span class="line">C[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;++i)&#123;</span><br><span class="line">C[i][<span class="number">0</span>]=C[i][i]=C[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;i;++j)&#123;</span><br><span class="line">C[i][j]=C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;++i)&#123;</span><br><span class="line">U.dat[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">fin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;k1&gt;&gt;k2;</span><br><span class="line">node res;</span><br><span class="line">res.u=b/c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">0</span>,t=<span class="number">1</span>;i&lt;=<span class="number">10</span>;++i,t=(t*res.u)%mod)&#123;</span><br><span class="line">res.dat[i][<span class="number">0</span>]=t;</span><br><span class="line">&#125;</span><br><span class="line">fout&lt;&lt;(res*<span class="built_in">vargcd</span>(a,b,c,n,U,R)).dat[k1][k2]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NumberTheory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构选课学习笔记</title>
      <link href="/2024/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>这是数据结构选课的课内笔记,和 $OI$ 的高难数据结构关系不是很大,主要是记一些怕忘的定义.</p><h2 id="ADL语言">ADL语言</h2><p>算法 SM(A,n,&amp;min,&amp;max)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">max&lt;-min&lt;a[<span class="number">1</span>]</span><br><span class="line">FOR i=<span class="number">2</span> TO n DO</span><br><span class="line"><span class="keyword">if</span> A[i]&gt;max THEN max&lt;-a[i]</span><br><span class="line"><span class="keyword">if</span> A[i]&lt;min THEN min&lt;-a[i]</span><br></pre></td></tr></table></figure><p>举例<br>$$ADL:a\leftrightarrow b$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a^=b^=a^=b</span><br></pre></td></tr></table></figure><h2 id="算法的鲁棒性">算法的鲁棒性</h2><p>自动识别错误数据(并纠正)的能力.</p><h2 id="算法测试">算法测试</h2><p><strong>黑盒测试</strong>:测试点.<br><strong>白盒测试</strong>:语句覆盖,分支覆盖.</p><h2 id="时间复杂度">时间复杂度</h2><p>$O$ ,读音:big-oh;表示上界,小于等于.<br>$ο$ ,读音:small-oh;表示上界,小于.<br>$\Theta$ ,读音:theta、西塔;既是上界也是下界,称为确界,等于.<br>$\omega$ ,读音:small omega;表示下界,大于.<br>$\Omega$ ,读音:big omega、欧米伽;表示下界,大于等于.</p><p>Ο是渐进上界,Ω是渐进下界.Θ需同时满足大Ο和Ω,故称为确界.Ο极其有用,因为它表示了最差性能.</p><h2 id="时空积分">时空积分</h2><p>$$W=\int_0^tf(x)\mathrm dx$$</p><h2 id="多维数组寻址">多维数组寻址</h2><p>$$*=dat+\sum_{j=1}^{n-1}(i_j\times\prod^{n}_{p=k+1} m_p)*C$$<br>C代表<code>sizeof</code>,大乘号其实就是前缀积</p><h2 id="矩阵三元组表转置">矩阵三元组表转置</h2><p>Q:为啥PPT说的是 $O(nt)$ 的?<br>这个可以做到 $O(t\log t)$ .</p><h2 id="矩阵十字链表">矩阵十字链表</h2><p>cqcqcq</p><p>how $A\to A* …$</p><p>3.2.4十字链表</p><h2 id="字典序">字典序</h2><p>cqcqcq</p><h2 id="二叉树">二叉树</h2><p>满二叉树:顾名思义,节点全满,非常均匀.<br>完全二叉树:节点全的,末层缺失</p><h2 id="线索二叉树">线索二叉树</h2><p>节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val,l,r,   pred,succ</span><br></pre></td></tr></table></figure><p>后面这俩存根,先根或者后根, <strong>可以存前根,中根或者后根</strong> ,故又称前序,中序或者后序线索二叉树.</p><p>cqc++…</p><h2 id="树转二叉树">树转二叉树</h2><p>深度相同兄弟之间连一条线,然后删掉所有非大孩子,刚连的线.</p><h2 id="森林转二叉树">森林转二叉树</h2><p>整一个首节点,然后连线,然后串串…</p><h2 id="树转森林">树转森林</h2><p>重剖,长剖.(不至于)</p><h2 id="哈夫曼树">哈夫曼树</h2><p>扩充二叉树:二叉树所有原来有空位的加子节点.</p><p>路径长度:<br>$$w=\sum_{i=1}^nw_id_i$$<br>其中w代表权值(就是存的那个数),然后d是路径长(深度-1),这个w最小的叫最优二叉树.</p><p>哈夫曼编码:左儿子是0,右儿子是1,直接走,走到哪编码.</p><p><strong>压缩</strong>:开一个map统计出现频率,然后建立哈夫曼树,直接译码. $O(n\log n)$ .<br><strong>解码</strong>:先读哈夫曼树,然后直接译码即可.</p><h3 id="哈夫曼树构造">哈夫曼树构造</h3><p>所有节点都是一个森林,然后每次选权值最小的根组成一个新树,产生一个新节点,加入其中,直到剩一个根.</p><h2 id="表达式树">表达式树</h2><p>中缀表达式树.这个一看就明白了,也没多难写.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(a+b)*(c+d)-e</span><br><span class="line">        -</span><br><span class="line">       / \</span><br><span class="line">      *   e</span><br><span class="line">     / \</span><br><span class="line">+   -</span><br><span class="line">   / \ / \</span><br><span class="line">   a b c d</span><br></pre></td></tr></table></figure><h2 id="图">图</h2><p>连通子图:顾名思义.<br>连通分量:把所有联通块抽出来就是了.</p><h2 id="拓扑排序">拓扑排序</h2><p>每次选一个入度为0的,然后删掉边,循环.</p><p>拓扑排序是 $O(n+e)$ 的.</p><h2 id="关键路径">关键路径</h2><p>cqcqcq</p><h2 id="可及性">可及性</h2><p>cqcqcq</p><h2 id="希尔排序-Shell">希尔排序(Shell)</h2><p>直接插入排序的改进.作为最先冲破 $O(n^2)$ 的排序算法,值得借鉴.</p><p>每次把增量分成n&gt;&gt;1,然后每个区间暴力插入排序.直到最后</p><h2 id="基数分布和值分布">基数分布和值分布</h2><p>基数排序,是模按照指定位数进行排序的算法,计数排序就是俗称的桶排序.</p><p>基数排序:先开十个链表,然后取最后一位看剩下的数.按照这个顺序先排起来.<br>然后取第二位接着排,直到元素有序.</p><h1>板子</h1><p>前情提要:数据结构作业不让用 <code>stl</code> 库,这令Flu有点难办…</p><p>咋办?自己搓!于是这就是常见的数据结构封装,快说谢谢Flu.</p><h2 id="栈">栈</h2><p>一度让我觉得没有封装的必要…但是既然数据结构提了那就写一个吧…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sstack</span>&#123;</span><br><span class="line">T* dat;</span><br><span class="line"><span class="type">int</span> ttop;</span><br><span class="line"><span class="built_in">sstack</span>(<span class="type">int</span> n=<span class="number">100010</span>)&#123;dat=<span class="keyword">new</span> T[n];ttop=<span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T val)</span></span>&#123;dat[++ttop]=val;&#125;</span><br><span class="line"><span class="function">T <span class="title">top</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop&gt;<span class="number">0</span>)<span class="keyword">return</span> dat[ttop];<span class="keyword">return</span> <span class="number">-114514</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ttop;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-114514</span>;ttop--;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ttop&lt;=<span class="number">0</span>;&#125;</span><br><span class="line">&#125;;<span class="comment">//所有操作不合法会返回-114514</span></span><br></pre></td></tr></table></figure><h2 id="队列-双端队列">队列(双端队列)</h2><p>因为双端队列兼容队列,所以就不再写队列的模板了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ddeque</span>&#123;</span><br><span class="line">T* dat;</span><br><span class="line"><span class="type">int</span> ttop,l;</span><br><span class="line"><span class="built_in">ddeque</span>(<span class="type">int</span> n=<span class="number">200010</span>)&#123;dat=<span class="keyword">new</span> T[n];ttop=(n&gt;&gt;<span class="number">1</span>);l=(n&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ttop-l+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function">T <span class="title">front</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop&lt;l)<span class="keyword">return</span> <span class="number">-114514</span>;<span class="keyword">return</span> dat[ttop];&#125;</span><br><span class="line"><span class="function">T <span class="title">back</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop&lt;l)<span class="keyword">return</span> <span class="number">-114514</span>;<span class="keyword">return</span> dat[l];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop_front</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop&lt;l)<span class="keyword">return</span> <span class="number">-114514</span>;ttop--;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop_back</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop&lt;l)<span class="keyword">return</span> <span class="number">-114514</span>;l++;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(T val)</span></span>&#123;dat[++ttop]=val;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T val)</span></span>&#123;dat[--l]=val;&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (ttop-l+<span class="number">1</span>)&lt;=<span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="动态数组">动态数组</h2><p>neta了vector.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">vvector</span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> base[]=&#123;<span class="number">0</span>,<span class="number">20</span>,<span class="number">110</span>,<span class="number">1010</span>,<span class="number">10010</span>,<span class="number">100010</span>,<span class="number">200010</span>,<span class="number">1000010</span>,<span class="number">2000010</span>,<span class="number">10000010</span>&#125;;</span><br><span class="line">T* dat;</span><br><span class="line"><span class="type">int</span> sz,top;<span class="comment">//当前块指向,顶端元素(Flu比较喜欢闭区间)</span></span><br><span class="line"><span class="built_in">vvector</span>(<span class="type">int</span> size=<span class="number">0</span>,T val=<span class="number">0</span>)&#123;sz=size;dat=<span class="keyword">new</span> T[base[size]];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;base[size];++i)&#123;dat[i]=val;&#125;top=<span class="number">-1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> top+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T val)</span></span>&#123;<span class="keyword">if</span>((top+<span class="number">1</span>)&gt;=base[sz])&#123;T* p=<span class="keyword">new</span> T[base[sz+<span class="number">1</span>]];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;base[sz];++i)&#123;p[i]=dat[i];&#125;p[++top]=val;sz++;<span class="keyword">delete</span>[]dat;dat=p;&#125;<span class="keyword">else</span>&#123;dat[++top]=val;&#125;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;top=<span class="number">-1</span>;&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> io)&#123;<span class="keyword">return</span> dat[io];&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="哈希表">哈希表</h2><p>低配版的umap,只支持 <code>long long</code> 的哈希…但是够用了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">uunordered_map</span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> first;</span><br><span class="line">T second;</span><br><span class="line">node *next,*nnext;</span><br><span class="line"><span class="built_in">node</span>(<span class="type">long</span> <span class="type">long</span> a,T b,node* p=<span class="literal">nullptr</span>,node* pp=<span class="literal">nullptr</span>):<span class="built_in">first</span>(a),<span class="built_in">second</span>(b),<span class="built_in">next</span>(p),<span class="built_in">nnext</span>(pp)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">node** dat;</span><br><span class="line">node* pp00;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mmod=<span class="number">1000003</span>;</span><br><span class="line"><span class="type">int</span> sz;</span><br><span class="line"><span class="built_in">uunordered_map</span>()&#123;</span><br><span class="line">sz=<span class="number">0</span>;</span><br><span class="line">pp00=<span class="literal">nullptr</span>;</span><br><span class="line">dat=<span class="keyword">new</span> node*[mmod];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;mmod;++i)&#123;</span><br><span class="line">dat[i]=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qqp</span><span class="params">(<span class="type">long</span> <span class="type">long</span> b,<span class="type">int</span> po)</span></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(po&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(po&amp;<span class="number">1</span>)</span><br><span class="line">res=res*b%mmod;</span><br><span class="line">b=b*b%mmod;</span><br><span class="line">po&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">long</span> <span class="type">long</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">qqp</span>(val,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">long</span> <span class="type">long</span>&amp; io)&#123;</span><br><span class="line"><span class="type">int</span> h=<span class="built_in">hash</span>(io);</span><br><span class="line">node* i=dat[h];</span><br><span class="line"><span class="keyword">for</span>(;i!=<span class="literal">nullptr</span>;i=i-&gt;next)&#123;</span><br><span class="line"><span class="keyword">if</span>(i-&gt;first==io)</span><br><span class="line"><span class="keyword">return</span> i-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line">sz++;</span><br><span class="line">node* j=<span class="keyword">new</span> <span class="built_in">node</span>(io,<span class="number">0</span>,dat[h],pp00);</span><br><span class="line">pp00=j;</span><br><span class="line">dat[h]=j;</span><br><span class="line"><span class="keyword">return</span> j-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">triverse</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(node* i=pp00;i!=<span class="literal">nullptr</span>;i=i-&gt;nnext)&#123;</span><br><span class="line"><span class="comment">//i-&gt;first键 i-&gt;second键值</span></span><br><span class="line"><span class="comment">//这是遍历所有元素的过程</span></span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sz&lt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="priority-queue">priority_queue</h2><p>自定义类需要写比较函数 <code>&lt;</code> ,记得输入0或者1表明建立小根堆还是大根堆,默认是0大根堆.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ppriority_queue</span>&#123;</span><br><span class="line">T* dat;</span><br><span class="line"><span class="type">int</span> sz,ff;<span class="comment">/*ff0大根堆1小根堆*/</span></span><br><span class="line"><span class="built_in">ppriority_queue</span>(<span class="type">int</span> flag=<span class="number">0</span>,<span class="type">int</span> n=<span class="number">100010</span>):<span class="built_in">sz</span>(<span class="number">0</span>),<span class="built_in">ff</span>(flag)&#123;</span><br><span class="line">dat=<span class="keyword">new</span> T[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ppriority_queue</span>(T* arr,<span class="type">int</span> num,<span class="type">int</span> flag=<span class="number">0</span>,<span class="type">int</span> n=<span class="number">100010</span>):<span class="built_in">sz</span>(num),<span class="built_in">ff</span>(flag)&#123;</span><br><span class="line">dat=<span class="keyword">new</span> T[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;++i)&#123;</span><br><span class="line">dat[i+<span class="number">1</span>]=dat[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">maintain</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T val)</span></span>&#123;</span><br><span class="line">dat[++sz]=val;</span><br><span class="line"><span class="built_in">maintaindown</span>(sz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintaindown</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> fa=num&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>((dat[fa]&lt;dat[num])^ff)&#123;</span><br><span class="line"><span class="built_in">sswap</span>(dat[fa],dat[num]);</span><br><span class="line"><span class="built_in">maintaindown</span>(fa);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sz&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-114514</span>;</span><br><span class="line">dat[<span class="number">1</span>]=dat[sz--];</span><br><span class="line"><span class="built_in">maintainup</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintainup</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ls=num&lt;&lt;<span class="number">1</span>,rs=(num&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,gg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(rs&lt;=sz)gg+=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(ls&lt;=sz)gg++;</span><br><span class="line"><span class="keyword">switch</span>(gg)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line"><span class="keyword">if</span>((dat[num]&lt;dat[ls])^ff)&#123;</span><br><span class="line"><span class="built_in">sswap</span>(dat[num],dat[ls]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line"><span class="keyword">if</span>((dat[ls]&lt;dat[rs])^ff)&#123;</span><br><span class="line"><span class="keyword">if</span>((dat[num]&lt;dat[rs])^ff)&#123;</span><br><span class="line"><span class="built_in">sswap</span>(dat[num],dat[rs]);</span><br><span class="line"><span class="built_in">maintainup</span>(rs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>((dat[num]&lt;dat[ls])^ff)&#123;</span><br><span class="line"><span class="built_in">sswap</span>(dat[num],dat[ls]);</span><br><span class="line"><span class="built_in">maintainup</span>(ls);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> dat[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sswap</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line">T _tmp=a;</span><br><span class="line">a=b;</span><br><span class="line">b=_tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;<span class="comment">/*O(n)建堆*/</span></span><br><span class="line"><span class="type">int</span> ls=num&lt;&lt;<span class="number">1</span>,rs=(num&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,gg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(ls&lt;=sz)<span class="built_in">maintain</span>(ls),gg++;</span><br><span class="line"><span class="keyword">if</span>(rs&lt;=sz)<span class="built_in">maintain</span>(rs),gg+=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">switch</span>(gg)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line"><span class="keyword">if</span>((dat[num]&lt;dat[ls])^ff)&#123;</span><br><span class="line"><span class="built_in">sswap</span>(dat[num],dat[ls]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line"><span class="keyword">if</span>((dat[ls]&lt;dat[rs])^ff)&#123;</span><br><span class="line"><span class="keyword">if</span>((dat[num]&lt;dat[rs])^ff)&#123;</span><br><span class="line"><span class="built_in">sswap</span>(dat[num],dat[rs]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>((dat[num]&lt;dat[ls])^ff)&#123;</span><br><span class="line"><span class="built_in">sswap</span>(dat[num],dat[ls]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sz&lt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="ppair">ppair</h2><p>单纯模仿用的…其实自己写一个也行…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ppair</span>&#123;</span><br><span class="line">T1 first;</span><br><span class="line">T2 second;</span><br><span class="line"><span class="built_in">ppair</span>()&#123;&#125;</span><br><span class="line"><span class="built_in">ppair</span>(T1 a,T2 b):<span class="built_in">first</span>(a),<span class="built_in">second</span>(b)&#123;&#125;</span><br><span class="line">ppair&amp; <span class="keyword">operator</span> =(<span class="type">const</span> ppair&amp; io)&#123;</span><br><span class="line">first=io.first;</span><br><span class="line">second=io.second;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> <span class="keyword">operator</span> ==(<span class="type">const</span> ppair&amp; io)<span class="type">const</span>&#123;</span><br><span class="line"><span class="built_in">return</span> (first==io.first)&amp;&amp;(second==io.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(ppair&amp; io)</span></span>&#123;</span><br><span class="line">ppair tmp=io;</span><br><span class="line">io=*<span class="keyword">this</span>;</span><br><span class="line">*<span class="keyword">this</span>=tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="list">list</h2><p>十分暴力的链表,考虑到有些时候无可避免地要用到链表,最后还是写了…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">llist</span>&#123;</span><br><span class="line"><span class="type">int</span> cnt,top;<span class="comment">/*top目前链表占用多大空间,cnt链表有多少个元素*/</span></span><br><span class="line">T* dat;</span><br><span class="line"><span class="type">int</span>* nxt;</span><br><span class="line"><span class="built_in">llist</span>(<span class="type">int</span> n=<span class="number">200010</span>):<span class="built_in">cnt</span>(<span class="number">0</span>),<span class="built_in">top</span>(<span class="number">1</span>)&#123;</span><br><span class="line">dat=<span class="keyword">new</span> T[n];</span><br><span class="line">nxt=<span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">nxt[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">llist</span>(T* ddat,<span class="type">int</span> num,<span class="type">int</span> n=<span class="number">200010</span>):<span class="built_in">cnt</span>(num),<span class="built_in">top</span>(<span class="number">1</span>+num)&#123;</span><br><span class="line">dat=<span class="keyword">new</span> T[n];</span><br><span class="line">nxt=<span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;++i)&#123;<span class="comment">/*[0,num)*/</span></span><br><span class="line">dat[i+<span class="number">2</span>]=ddat[i];</span><br><span class="line">nxt[i+<span class="number">1</span>]=i+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _add(<span class="type">int</span> pre,T val)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;;++i,j=nxt[j])&#123;</span><br><span class="line"><span class="keyword">if</span>(i==pre)&#123;</span><br><span class="line">nxt[++top]=nxt[j];</span><br><span class="line">nxt[j]=top;</span><br><span class="line">dat[top]=val;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos,T val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;<span class="number">0</span>||cnt&lt;pos)<span class="keyword">return</span> <span class="number">-114514</span>;</span><br><span class="line">_add(pos,val);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _del(<span class="type">int</span> pre)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;;++i,j=nxt[j])&#123;</span><br><span class="line"><span class="keyword">if</span>(i==pre)&#123;</span><br><span class="line">nxt[j]=nxt[nxt[j]];</span><br><span class="line">cnt--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=<span class="number">0</span>||cnt&lt;pos)<span class="keyword">return</span> <span class="number">-114514</span>;</span><br><span class="line">_del(pos<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">triverse</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=nxt[<span class="number">1</span>];j!=<span class="number">0</span>;++i,j=nxt[j])&#123;</span><br><span class="line"><span class="comment">/*i是序号,j是当前元素指针*/</span></span><br><span class="line"><span class="comment">//do something...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="高精度">高精度</h2><p>懒得写,下一个.<br>我宁可去洛谷上找一个之前写好的都不要自己修这个破玩意.</p><h2 id="ALL">ALL</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Flu&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ddeque</span>&#123;</span><br><span class="line">T* dat;</span><br><span class="line"><span class="type">int</span> ttop,l;</span><br><span class="line"><span class="built_in">ddeque</span>(<span class="type">int</span> n=<span class="number">200010</span>)&#123;dat=<span class="keyword">new</span> T[n];ttop=(n&gt;&gt;<span class="number">1</span>);l=(n&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ttop-l+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function">T <span class="title">front</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop&lt;l)<span class="keyword">return</span> <span class="number">0x0d000721</span>;<span class="keyword">return</span> dat[ttop];&#125;</span><br><span class="line"><span class="function">T <span class="title">back</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop&lt;l)<span class="keyword">return</span> <span class="number">0x0d000721</span>;<span class="keyword">return</span> dat[l];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop_front</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop&lt;l)<span class="keyword">return</span> <span class="number">0x0d000721</span>;ttop--;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop_back</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop&lt;l)<span class="keyword">return</span> <span class="number">0x0d000721</span>;l++;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(T val)</span></span>&#123;dat[++ttop]=val;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T val)</span></span>&#123;dat[--l]=val;&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (ttop-l+<span class="number">1</span>)&lt;=<span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">vvector</span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> base[]=&#123;<span class="number">0</span>,<span class="number">20</span>,<span class="number">110</span>,<span class="number">1010</span>,<span class="number">10010</span>,<span class="number">100010</span>,<span class="number">200010</span>,<span class="number">1000010</span>,<span class="number">2000010</span>,<span class="number">10000010</span>&#125;;</span><br><span class="line">T* dat;</span><br><span class="line"><span class="type">int</span> sz,top;<span class="comment">//当前块指向,顶端元素(Flu比较喜欢闭区间)</span></span><br><span class="line"><span class="built_in">vvector</span>(<span class="type">int</span> size=<span class="number">0</span>,T val=<span class="number">0</span>)&#123;sz=size;dat=<span class="keyword">new</span> T[base[size]];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;base[size];++i)&#123;dat[i]=val;&#125;top=<span class="number">-1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> top+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T val)</span></span>&#123;<span class="keyword">if</span>((top+<span class="number">1</span>)&gt;=base[sz])&#123;T* p=<span class="keyword">new</span> T[base[sz+<span class="number">1</span>]];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;base[sz];++i)&#123;p[i]=dat[i];&#125;p[++top]=val;sz++;<span class="keyword">delete</span>[]dat;dat=p;&#125;<span class="keyword">else</span>&#123;dat[++top]=val;&#125;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;top=<span class="number">-1</span>;&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> io)&#123;<span class="keyword">return</span> dat[io];&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ppriority_queue</span>&#123;</span><br><span class="line">T* dat;</span><br><span class="line"><span class="type">int</span> sz,ff;<span class="comment">/*ff0大根堆1小根堆*/</span></span><br><span class="line"><span class="built_in">ppriority_queue</span>(<span class="type">int</span> flag=<span class="number">0</span>,<span class="type">int</span> n=<span class="number">100010</span>):<span class="built_in">sz</span>(<span class="number">0</span>),<span class="built_in">ff</span>(flag)&#123;dat=<span class="keyword">new</span> T[n];&#125;</span><br><span class="line"><span class="built_in">ppriority_queue</span>(T* arr,<span class="type">int</span> num,<span class="type">int</span> flag=<span class="number">0</span>,<span class="type">int</span> n=<span class="number">100010</span>):<span class="built_in">sz</span>(num),<span class="built_in">ff</span>(flag)&#123;dat=<span class="keyword">new</span> T[n];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;++i)&#123;dat[i+<span class="number">1</span>]=dat[i];&#125;<span class="built_in">maintain</span>(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T val)</span></span>&#123;dat[++sz]=val;<span class="built_in">maintaindown</span>(sz);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintaindown</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;<span class="type">int</span> fa=num&gt;&gt;<span class="number">1</span>;<span class="keyword">if</span>((dat[fa]&lt;dat[num])^ff)&#123;<span class="built_in">sswap</span>(dat[fa],dat[num]);<span class="built_in">maintaindown</span>(fa);&#125;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(sz&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0x0d000721</span>;dat[<span class="number">1</span>]=dat[sz--];<span class="built_in">maintainup</span>(<span class="number">1</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintainup</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;<span class="type">int</span> ls=num&lt;&lt;<span class="number">1</span>,rs=(num&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,gg=<span class="number">0</span>;<span class="keyword">if</span>(rs&lt;=sz)gg+=<span class="number">2</span>;<span class="keyword">if</span>(ls&lt;=sz)gg++;<span class="keyword">switch</span>(gg)&#123;<span class="keyword">case</span> <span class="number">0</span>:&#123;<span class="keyword">return</span>;&#125;<span class="keyword">case</span> <span class="number">1</span>:&#123;<span class="keyword">if</span>((dat[num]&lt;dat[ls])^ff)&#123;<span class="built_in">sswap</span>(dat[num],dat[ls]);&#125;<span class="keyword">return</span>;&#125;<span class="keyword">case</span> <span class="number">3</span>:&#123;<span class="keyword">if</span>((dat[ls]&lt;dat[rs])^ff)&#123;<span class="keyword">if</span>((dat[num]&lt;dat[rs])^ff)&#123;<span class="built_in">sswap</span>(dat[num],dat[rs]);<span class="built_in">maintainup</span>(rs);&#125;&#125;<span class="keyword">else</span>&#123;<span class="keyword">if</span>((dat[num]&lt;dat[ls])^ff)&#123;<span class="built_in">sswap</span>(dat[num],dat[ls]);<span class="built_in">maintainup</span>(ls);&#125;&#125;<span class="keyword">break</span>;&#125;&#125;&#125;</span><br><span class="line"><span class="function">T <span class="title">top</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> dat[<span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> sz;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sswap</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;T _tmp=a;a=b;b=_tmp;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;<span class="comment">/*O(n)建堆*/</span><span class="type">int</span> ls=num&lt;&lt;<span class="number">1</span>,rs=(num&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,gg=<span class="number">0</span>;<span class="keyword">if</span>(ls&lt;=sz)<span class="built_in">maintain</span>(ls),gg++;<span class="keyword">if</span>(rs&lt;=sz)<span class="built_in">maintain</span>(rs),gg+=<span class="number">2</span>;<span class="keyword">switch</span>(gg)&#123;<span class="keyword">case</span> <span class="number">0</span>:&#123;<span class="keyword">return</span>;&#125;<span class="keyword">case</span> <span class="number">1</span>:&#123;<span class="keyword">if</span>((dat[num]&lt;dat[ls])^ff)&#123;<span class="built_in">sswap</span>(dat[num],dat[ls]);&#125;<span class="keyword">return</span>;&#125;<span class="keyword">case</span> <span class="number">3</span>:&#123;<span class="keyword">if</span>((dat[ls]&lt;dat[rs])^ff)&#123;<span class="keyword">if</span>((dat[num]&lt;dat[rs])^ff)&#123;<span class="built_in">sswap</span>(dat[num],dat[rs]);&#125;&#125;<span class="keyword">else</span>&#123;<span class="keyword">if</span>((dat[num]&lt;dat[ls])^ff)&#123;<span class="built_in">sswap</span>(dat[num],dat[ls]);&#125;&#125;<span class="keyword">break</span>;&#125;&#125;&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> sz&lt;=<span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">llist</span>&#123;</span><br><span class="line"><span class="type">int</span> cnt,top;<span class="comment">/*top目前链表占用多大空间,cnt链表有多少个元素*/</span></span><br><span class="line">T* dat;</span><br><span class="line"><span class="type">int</span>* nxt;</span><br><span class="line"><span class="built_in">llist</span>(<span class="type">int</span> n=<span class="number">200010</span>):<span class="built_in">cnt</span>(<span class="number">0</span>),<span class="built_in">top</span>(<span class="number">1</span>)&#123;dat=<span class="keyword">new</span> T[n];nxt=<span class="keyword">new</span> <span class="type">int</span>[n];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;nxt[i]=<span class="number">0</span>;&#125;&#125;</span><br><span class="line"><span class="built_in">llist</span>(T* ddat,<span class="type">int</span> num,<span class="type">int</span> n=<span class="number">200010</span>):<span class="built_in">cnt</span>(num),<span class="built_in">top</span>(<span class="number">1</span>+num)&#123;dat=<span class="keyword">new</span> T[n];nxt=<span class="keyword">new</span> <span class="type">int</span>[n];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;++i)&#123;<span class="comment">/*[0,num)*/</span>dat[i+<span class="number">2</span>]=ddat[i];nxt[i+<span class="number">1</span>]=i+<span class="number">2</span>;&#125;&#125;</span><br><span class="line"><span class="type">void</span> _add(<span class="type">int</span> pre,T val)&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;;++i,j=nxt[j])&#123;<span class="keyword">if</span>(i==pre)&#123;nxt[++top]=nxt[j];nxt[j]=top;dat[top]=val;cnt++;<span class="keyword">return</span>;&#125;&#125;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos,T val)</span></span>&#123;<span class="keyword">if</span>(pos&lt;<span class="number">0</span>||cnt&lt;pos)<span class="keyword">return</span> <span class="number">0x0d000721</span>;_add(pos,val);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="type">void</span> _del(<span class="type">int</span> pre)&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;;++i,j=nxt[j])&#123;<span class="keyword">if</span>(i==pre)&#123;nxt[j]=nxt[nxt[j]];cnt--;<span class="keyword">return</span>;&#125;&#125;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;<span class="keyword">if</span>(pos&lt;=<span class="number">0</span>||cnt&lt;pos)<span class="keyword">return</span> <span class="number">0x0d000721</span>;_del(pos<span class="number">-1</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">triverse</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=nxt[<span class="number">1</span>];j!=<span class="number">0</span>;++i,j=nxt[j])&#123;</span><br><span class="line"><span class="comment">/*i是序号,j是当前元素指针*/</span></span><br><span class="line"><span class="comment">//do something...</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">uunordered_map</span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> first;</span><br><span class="line">T second;</span><br><span class="line">node *next,*nnext;</span><br><span class="line"><span class="built_in">node</span>(<span class="type">long</span> <span class="type">long</span> a,T b,node* p=<span class="literal">nullptr</span>,node* pp=<span class="literal">nullptr</span>):<span class="built_in">first</span>(a),<span class="built_in">second</span>(b),<span class="built_in">next</span>(p),<span class="built_in">nnext</span>(pp)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">node** dat;</span><br><span class="line">node* pp00;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mmod=<span class="number">1000003</span>;</span><br><span class="line"><span class="type">int</span> sz;</span><br><span class="line"><span class="built_in">uunordered_map</span>()&#123;sz=<span class="number">0</span>;pp00=<span class="literal">nullptr</span>;dat=<span class="keyword">new</span> node*[mmod];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;mmod;++i)&#123;dat[i]=<span class="literal">nullptr</span>;&#125;&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qqp</span><span class="params">(<span class="type">long</span> <span class="type">long</span> b,<span class="type">int</span> po)</span></span>&#123;<span class="type">long</span> <span class="type">long</span> res=<span class="number">1</span>;<span class="keyword">while</span>(po&gt;<span class="number">0</span>)&#123;<span class="keyword">if</span>(po&amp;<span class="number">1</span>)res=res*b%mmod;b=b*b%mmod;po&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">long</span> <span class="type">long</span> val)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">qqp</span>(val,<span class="number">5</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> sz;&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">long</span> <span class="type">long</span>&amp; io)&#123;<span class="type">int</span> h=<span class="built_in">hash</span>(io);node* i=dat[h];<span class="keyword">for</span>(;i!=<span class="literal">nullptr</span>;i=i-&gt;next)&#123;<span class="keyword">if</span>(i-&gt;first==io)<span class="keyword">return</span> i-&gt;second;&#125;sz++;node* j=<span class="keyword">new</span> <span class="built_in">node</span>(io,<span class="number">0</span>,dat[h],pp00);pp00=j;dat[h]=j;<span class="keyword">return</span> j-&gt;second;&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> sz&lt;=<span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">triverse</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(node* i=pp00;i!=<span class="literal">nullptr</span>;i=i-&gt;nnext)&#123;</span><br><span class="line"><span class="comment">//i-&gt;first键 i-&gt;second键值</span></span><br><span class="line"><span class="comment">//这是遍历所有元素的过程</span></span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="tmp">tmp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   /|\</span><br><span class="line">   BCD</span><br><span class="line">  /|||\</span><br><span class="line"> E FGH I</span><br><span class="line">/|\</span><br><span class="line">KLJ</span><br><span class="line">      A</span><br><span class="line">     /|\</span><br><span class="line">    B-C-D</span><br><span class="line">   /| | |\</span><br><span class="line">  E-F-G-H-I</span><br><span class="line"> /|\</span><br><span class="line">K-L-J</span><br><span class="line">      A</span><br><span class="line">     /</span><br><span class="line">    B-C-D</span><br><span class="line">   /     </span><br><span class="line">  E-F-G-H-I</span><br><span class="line"> /</span><br><span class="line">K-L-J</span><br><span class="line">      A</span><br><span class="line">     /</span><br><span class="line">    B</span><br><span class="line">   / \</span><br><span class="line">  E   C</span><br><span class="line"> / \   \</span><br><span class="line">K   F   D</span><br><span class="line"> \   \</span><br><span class="line">  L   G</span><br><span class="line">   \   \</span><br><span class="line">    J   H</span><br><span class="line">     \</span><br><span class="line">  I</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筛法</title>
      <link href="/2024/09/03/%E7%AD%9B%E6%B3%95/"/>
      <url>/2024/09/03/%E7%AD%9B%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="区间筛">区间筛</h2><p>例题:每次给一对 $l,r$ ,求区间内的质数有多少个.<br>范围是 $l\le r\le10^{12},b-a\le10^6$.</p><p>首先要明白一个常见的道理: 区间 $[a,b]$ 内最大的质因数是 $\sqrt b$ .所以我们要先打好1e6内的表,然后利用坐标偏移再打好lr的表即可.</p><p>看到 $10^{12}$ 的数据范围要想到区间筛.因为数据范围这么大的话,一般要用到,&quot;一个数的最小质因数不会超过 $\sqrt n$ &quot;这个结论,然后先质数筛,再对每个数进行质因数分解O(logn).然后利用唯一分解定理把约数组合拼上去即可.</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NumberTheory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推式子</title>
      <link href="/2024/09/03/%E6%8E%A8%E5%BC%8F%E5%AD%90/"/>
      <url>/2024/09/03/%E6%8E%A8%E5%BC%8F%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>以下是推式子时间,记录一些公式的求解过程.(以及一些奇奇怪怪的公式)</p><ol><li><p>求解的个数:(1e9取模)<br>$$\frac1x+\frac1y=\frac1{n!}$$<br>首先我们发现,1/x和1/y都是小于1/n!的,所以x和y应该是大于n!的.<br>我们设 $y=n!+k,k\in N^+$ ,于是式子变成<br>$$\frac1x+\frac1{n!+k}=\frac1{n!}$$<br>化简变成<br>$$x=n!+\frac{(n!)^2}k$$<br>我们就统计一下约数个数就行了,具体地,线性筛一下,算出每个数的最小质因数,因为 $x^2$ 的每个约数都是 $x$ 的两倍,所以我们要先乘2再加1.</p></li><li><p>求<br>$$\sum_{k=1}^n\Big\lfloor\frac{(3k+6)!+1}{3k+7}-\Big\lfloor\frac{(3k+6)!}{3k+7}\Big\rfloor\Big\rfloor$$<br>我们分情况考虑,假设 $3k+7$ 是质数,则由定理知 $(3k+6)!\equiv-1\mod (3k+7)$ ,所以我们设 $(3k+6)!+1=a(3k+7)$ (同时注意,模意义下只能这么干,不要想着逆元解决),原式即为<br>$$\Big\lfloor a-\Big\lfloor a-\frac{1}{3k+7}\Big\rfloor\Big\rfloor=1$$<br>同时,假如不是质数,由于其质因子全部包含在阶乘里面,也就有了 $(3k+7)|(3k+6)!$ .这个时候还是设 $(3k+6)!=a(3k+7)$ ,式子可以化为<br>$$\Big\lfloor a+\frac{1}{3k+7}-a\Big\rfloor=0$$<br>所以,式子只是让我们统计一下有多少个 $3k+7$ 是质数.</p></li><li><p>求 $x^2+y^2=19451945$ :凑配法:对于展开数有以下式子:<br>$$(ac+bd)^2+(ad-bc)^2=(a^2+b^2)(c^2+d^2)$$<br>然后19451945就能分解为1945*10001,现在开始考虑分解1945,在3的时候能分解,问题解决了.最后的abcd分别是 $3,44,100,1$ ,答案是 $344,4397$ .</p></li></ol><h2 id="其他奇奇怪怪的公式">其他奇奇怪怪的公式</h2><ol><li>feb表示斐波那契数列第n项.<br>$$\gcd(feb_{n},feb_{m})=feb_{\gcd(n,m)}$$</li><li></li></ol><h2 id="升幂引理">升幂引理</h2><p>规定 $v_p(n)$ 表示n中有多少个p这个因子.</p><ol><li>素数p和与p互质的n.<br>若 $p|x-y$ 有<br>$$v_p(x^n-y^n)=v_p(x-y)$$<br>若 $p|x+y$ 则对 <strong>奇数</strong> n有<br>$$v_p(x^n+y^n)=v_p(x+y)$$</li><li>若p不是2(是奇质数):<br>若 $p|x-y$ 有<br>$$v_p(x^n-y^n)=v_p(x-y)+v_p(n)$$<br>若 $p|x+y$ 则对 <strong>奇数</strong> n有<br>$$v_p(x^n+y^n)=v_p(x+y)+v_p(n)$$</li><li>若p是2且 $p|x-y$ 对 <strong>偶数</strong> n有<br>$$v_p(x^n-y^n)=v_p(x-y)+v_p(x+y)+v_p(n)-1$$</li><li>对于 $4|x-y$<br>$$v_2(x+y)=1$$<br>$$v_2(x^n-y^n)=v_2(x-y)+v_2(n)$$</li></ol><h2 id="Wilson威尔逊定理">Wilson威尔逊定理</h2><p>$$(p-1)!\equiv-1\mod p$$</p><ol><li><p>特殊的阶乘(n比p大,不计所有p的因子对p取模)<br>$$\begin{aligned}&amp;(n!)\mod p\=&amp;(-1)^{\lfloor\frac{n}{p}\rfloor}\Big(\Big\lfloor\frac np\Big\rfloor!\Big)\mod p\end{aligned}$$<br>打一个阶乘表可以 $\log_pn$解决.</p></li><li><p>Lagenre(勒让德)公式<br>$$v_p(n!)=\sum_{i=1}^\infin\Big\lfloor\frac n{p^i}\Big\rfloor=\frac{n-S_p(n)}{p-1}$$<br>其中, $S_p(n)$ 表示在p进制下n每位数字和.(注意,直接除,别搞什么逆元啥的)</p></li></ol><h2 id="类欧几里得算法">类欧几里得算法</h2><ol><li>我们需要logn解决.设<br>$$\begin{aligned}f(a,b,c,n)=&amp;\sum_{i=0}^n\Big\lfloor\frac{ai+b}{c}\Big\rfloor\=&amp;\sum_{i=0}^n\Big\lfloor\frac{(\lfloor\frac ac\rfloor c+a\mod c)i+(\lfloor\frac bc\rfloor c+b\mod c)}{c}\Big\rfloor\=&amp;\frac{n(n+1)}2\Big\lfloor\frac ac\Big\rfloor+(n+1)\Big\lfloor\frac bc\Big\rfloor+\sum_{i=0}^n\Big\lfloor\frac{(a\mod c)i+(b\mod c)}c\Big\rfloor<br>\=&amp;\frac{n(n+1)}2\Big\lfloor\frac ac\Big\rfloor+(n+1)\Big\lfloor\frac bc\Big\rfloor+f(a\mod c,b\mod c,c,n)\end{aligned}$$<br>改变一下求和项目看到<br>$$\begin{aligned}f(a,b,c,n)&amp;=\sum_{k=0}^{m-1}\sum_{i=0}^n\Big[i&gt;\Big\lfloor\frac{jc+c-b-1}{a}\Big\rfloor\Big]<br>\&amp;=\sum_{j=0}^{m-1}\Big(n-\Big\lfloor\frac{jc+c-b-a}a\Big\rfloor\Big)<br>\&amp;=nm-f(c,c-b-1,a,m-1)\end{aligned}$$<br>中间有<br>$$n^2=2\frac{n(n+1)}2-n=\Big(\sum_{i=0}^ni\Big)-n$$</li></ol><h2 id="万能欧几里得算法">万能欧几里得算法</h2>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NumberTheory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF Round970 Div3</title>
      <link href="/2024/09/03/CF-Round970-Div3/"/>
      <url>/2024/09/03/CF-Round970-Div3/</url>
      
        <content type="html"><![CDATA[<p>CF场.收获颇丰.</p><p>栈区开新数组是默认可能会很混乱的取值,可以在后面加一个大括号,然后就是0了. <code>int a[114][514]&#123;&#125;</code></p><p>首先是看大佬的码风.两个模板构造的默认是前面一个是默认分配大小,后面一个是每个元素初始值.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">114</span>,<span class="number">514</span>);</span><br></pre></td></tr></table></figure><p>然后是找最大元素.有一个很方便的函数是 <code>max_element</code> ,直接给两个指针,返回最大元素指针,多个就返回第一个指针.</p><p>相对的,肯定也有 <code>min_element</code> 了,在此不表.</p><p>然后是前缀和后缀和的巧妙应用.如果我要遍历一个数组,在每个点都会用到前缀和和后缀和,这个时候有一个优化就是,先求前缀和(一个数,不是数组),然后从末尾开始,减掉该点,同时再来一个数代表后缀和,就这样倒着边算后缀和,减掉前缀和,同时计算出答案.</p><h2 id="字符串">字符串</h2><p>奇数位的字符串在前面删掉一个元素的时候会变成偶数,也就是说直接让这个奇数位在求后缀和的时候装偶数位的就行了,没必要自己给自己设套,又是映射又是四个数组的.</p><h2 id="位运算">位运算</h2><p><code>a&amp;1^1</code> 是判定一个数是不是偶数的算法,再也不用写成 <code>(!(a&amp;1))</code> 而且为了优先级担心半天了.</p>]]></content>
      
      
      <categories>
          
          <category> OTH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Contest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prufer序列</title>
      <link href="/2024/08/29/Prufer%E5%BA%8F%E5%88%97/"/>
      <url>/2024/08/29/Prufer%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>Prufer序列的构造略,这里主要总结应用.</p><p>完全图 $K_n$ 有 $n^{n-2}$ 棵生成树.证明:Prufer序列值域是[1,n],有n-2个,QED.</p><h2 id="性质">性质</h2><p>在Prufer序列中出现次数为d-1的节点的度数是d.</p><p>所以,给一个序列表示每个点的度数,可以计算出来这样的无根树一共有<br>$$\prod_{i=1}^n\binom{rest}{d_i-1}$$<br>个,rest表示每次选数剩下的位置.</p><h2 id="图联通方案数">图联通方案数</h2><blockquote><p>一个n个点m条边的带标号无向图有k个连通块.我们希望添加k-1条边使得整个图连通.求方案数.</p></blockquote><p>首先是多项组合数公式:表示从<br>$$\binom{a}{b,c,d}=\frac{a!}{b!c!d!}$$<br>然后是多元二项式定理:<br>$$(x_1+…+x_m)^p=\sum_{c_i\ge0,\sum_{i=1}^{m}c_i=p}\binom{p}{c_1,…,c_m}\cdot\prod_{i=1}^{m}x_i^{c_i}$$<br>结论:<br>$$n^{k-2}\cdot\prod_{i=1}^{k}s_i$$</p>]]></content>
      
      
      <categories>
          
          <category> Graph&amp;Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2024/08/25/%E5%9B%BE%E8%AE%BA/"/>
      <url>/2024/08/25/%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="Floyd算法">Floyd算法</h2><p>通过dp的方式进行转移, <code>dp[i][j]</code> 表示从i到j的最小边权和.<br>还可以这么想,在一个没有权值的图中, <code>dp[i][j]</code> 表示i能到j.现在,假设dp是一个矩阵,则 $dp^k$ 的意思就是从i花费k步能到达j的方案总数.<br>例题:一个人在图上1节点,每步可以走向与他相连的其他节点,也可以不动,还可以自爆,自爆之后就不能动了,求经过k步之后的所有行走情况和.<br>一些特殊情况的处理:</p><ol><li>这一步不动: 自己给自己连边,形成自环即可.</li><li>自爆: 我们假想一个新节点0, 所有点和0连边,0不和任何点连边(自爆之后不能转移出去).</li></ol><p>最后,套上矩阵快速幂板子即可.</p><h2 id="dfs序-欧拉序">dfs序 欧拉序</h2><p>这俩的区别就是,前者是节点遍历到的时候只会有一次,后者是来的时候一次走的时候再来一次.</p>]]></content>
      
      
      <categories>
          
          <category> Graph&amp;Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随机数算法</title>
      <link href="/2024/08/08/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%AE%97%E6%B3%95/"/>
      <url>/2024/08/08/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>随机数引擎</h1><p>常见的有两个,一个是<code>rand()</code>,另一个是随机数引擎<code>mt19937</code>.</p><h2 id="shuffle">shuffle</h2><p>洗牌算法,和sort一样用,开头,结尾,随机数引擎.(随机打乱)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::mt19937 <span class="title">rnd</span><span class="params">(seed)</span></span>;</span><br><span class="line"><span class="built_in">shuffle</span>(dat,dat+<span class="number">1</span>+n,rnd);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OTH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WA问题速查</title>
      <link href="/2024/08/06/WA%E9%97%AE%E9%A2%98%E9%80%9F%E6%9F%A5/"/>
      <url>/2024/08/06/WA%E9%97%AE%E9%A2%98%E9%80%9F%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>在这里记录一些自己可能察觉不到的莫名WA.</p><h2 id="祖宗">祖宗</h2><p>开long long了吗?</p><h2 id="取模">取模</h2><p>有的时候要对答案进行特判,输出一个定值.但是又有的时候模数不是指定的,是要输入的,于是可能出现特判1但是模数是1正好被卡的状况…</p><h2 id="交互">交互</h2><p><code>cout&lt;&lt;&quot;!&quot;&lt;&lt;solve()&lt;&lt;endl;</code>是错的,尤其是交互库的时候千万不要这么搞,会WA,因为<code>cout</code>先执行输出然后再计算函数的值.</p><h2 id="除法">除法</h2><p>检查一下有没有除0模0的特判,不然会RE的哦.</p><h2 id="分解">分解</h2><p>什么时候能用 $O(\sqrt n)$ 的数分解(也就是<code>for(int i=2;i*i&lt;=n;++i)</code>)?当然是不影响后续的时候.假如产生影响就只能一个一个枚举了…(比如 $g(x)=\sum_{i|x}g(i)$ )</p><p>还有还有,那就是在 $f(x),f(n/x)$ 的时候记得看一下这俩数一不一样,会出大问题!!!</p><h2 id="双指针">双指针</h2><p>记得结算的时候动一下指针.</p><h2 id="DP转移">DP转移</h2><p>有的时候,状态之间会进行转换.状态之间提前到达的时候不要使用<code>dpxx=xx%m</code>,应该用<code>dpxx=(dpxx+xx)%m</code>,因为状态提前到达的时候会被<code>=</code>直接归零,就白转移了,不是<code>memset</code>的问题.</p><h2 id="树">树</h2><p>给定一棵树有n个节点,首先要判定是不是一棵树!!!(ie度数和 $\sum_{i=1}^nd_i=n-2$ )<br>一定要特判节点为1的时候有多少种情况!!!</p><ol><li>树的相同判定:给一个深度上有多少节点的数组,判断这样的树是否唯一.</li></ol><p>然而我们发现只有连着的节点大于2的才有多种,单独2后面还有链的并不算,可以看演示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> a   a   a   a</span><br><span class="line">/|\ /|\ /|\ /|\</span><br><span class="line">bcd bcd bcd bcd</span><br><span class="line">||  ||| |\|</span><br><span class="line">ee  efg efg</span><br><span class="line">这两种树本质上一样.但是这俩不一样.</span><br></pre></td></tr></table></figure><h2 id="图论">图论</h2><ol><li>给一张无向图,遍历他,染个色(只保证无自环重边).</li></ol><p>肯定是要bfs的了,但是有个hack是 <strong>给的图不一定连通</strong> ,所以要在bfs这里套一个循环保证每个点都要进队(被遍历到).(CF687A)</p><h2 id="数学">数学</h2><p>鸽巢的时候记得卡一下边界,虽然书上说最多能放 $\lceil\frac nk\rceil$ 个,但是最多能着的下 $n%k$ 种,记得统计一下.(另外,如果ceil等于直接除的话要特判,因为此时 $n%k$ 等于0)</p><h1>大坑</h1><h2 id="目力">目力</h2><p>众所周知,某些质数因为长得像而混迹998244353,而有的则是正确输出 <code>YE5</code> ,错误输出 <code>N0</code> ,就很邪恶.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">998244853</span> 是质数</span><br><span class="line"><span class="number">998244259</span> 是质数</span><br><span class="line"><span class="number">99824353</span>  是质数</span><br><span class="line"><span class="number">998242353</span> 不是质数</span><br><span class="line"><span class="number">100000007</span>(<span class="number">1e8</span>+<span class="number">7</span>) 是质数</span><br><span class="line"></span><br><span class="line"><span class="number">19491001</span> 是质数</span><br><span class="line"><span class="number">19260817</span> 是质数</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OTH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Contest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技巧</title>
      <link href="/2024/08/03/%E6%8A%80%E5%B7%A7/"/>
      <url>/2024/08/03/%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>RT,这里写一些题目中总结的技巧.</p><h2 id="分段">分段</h2><ol><li><a href="https://codeforces.com/problemset/problem/1419/C">空调</a>.一个空调有一个位置和温度,向两边传送温度,<code>+1</code>递增,问所有格子有多凉快.</li></ol><p><code>std</code>把空调向左传播和向右传播分开了,然后分别维护一个<code>L</code>和<code>R</code>表示向左传播向右传播的最小值,可以做一个DP.</p>]]></content>
      
      
      <categories>
          
          <category> OTH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ad_Hoc</title>
      <link href="/2024/08/03/Ad-Hoc/"/>
      <url>/2024/08/03/Ad-Hoc/</url>
      
        <content type="html"><![CDATA[<p>这是迟早要开的<code>Ad_Hoc</code>专题,巧妙(<s>乱搞</s>)解法的题目会被收录在这里.</p><h2 id="CF1722G">CF1722G</h2><p>构造一个数列满足奇数项抑或和等于偶数项抑或和.(构造的数字必须在 $0-2^{31}$ 以内)</p><p>乍一看挺吓人?其实,因为值域很宽,各种各样的方法都可以通过.<br>法1:随机数,最后特判一下,如果重了就上一项抑或上某个数直到不重.<br>法2:直接排列,在1-n-3位上直接摆1-n-3,然后摆俩大数,n位上摆奇数项抑或偶数项保证相同.</p><h2 id="CF1930B">CF1930B</h2><p>构造一个序列满足不存在 $a_j|a_i,a_{j+1}|a_{i+1}$ ,样例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>因为倍数首先要满足 $a_i&gt;a_j$ ,然后这么构造也就需要满足所有偶数位大于奇数位,同时奇数位递增,偶数位递减即可.</p><h2 id="P10635">P10635</h2><p>给一个01矩阵,一次反转会翻转所有该硬币行和列的所有状态,求最少需要几次反转(方阵).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0101</span></span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="number">0010</span></span><br><span class="line"><span class="number">0101</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>我们不需要反转成全0或者全1,所以二者之间取最小值就行了.</p><p>发现,将单个元素反转的方法是,该行和该列上的全部元素全部反转一下就可以了.也就是说,给定矩阵必定有解.我们统计每行每列1的个数,然后遍历每个元素,看 <code>(s[i][j]-'0'+co[i]+ro[j])&amp;1</code> ,因为如果元素是1,我们要反转,所以要考虑原始矩阵对答案的贡献,不应该直接统计行列1的个数的那个.</p><h2 id="CF476D">CF476D</h2><p>给一个n和k,构造n个四元组满足:<br>四元组内任意两个元素的gcd是k.<br>所有四元组的元素不重.</p><p>显然,k是没用的,直接乘上就完了.</p><p>先引一个结论: <strong>任意三个连续奇数互质,任意奇数和偶数互质</strong> .<br>这意味着什么?我们的四元组完全可以通过三个连续奇数一个偶数的方式进行枚举,很快完成.</p><h2 id="P9667">P9667</h2><p>给n个元素( $n\le500$ )和m,首先你可以选择任意m个元素直接删掉,在剩下的元素中,对某个元素可以进行以下三选一的操作:1.元素值+1,2.元素值-1,3.元素值&gt;&gt;1,问最后剩下的元素拥有相同非零值的最小操作次数是多少.(时限 $6s,a\le10^9$ )</p><p>注意到这个题诡异的数据范围还有很高的时长,可能要暴力枚举某个东西.猜结论:答案一定是某个数字除以2得到的结果,然后暴力检查更新答案.总复杂度 $O(n^2\log^2n)$ .这种题只能多做,初见杀.</p>]]></content>
      
      
      <categories>
          
          <category> OTH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OTH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markov Algorithm Online 攻略</title>
      <link href="/2024/07/31/Markov-Algorithm-Online-%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/"/>
      <url>/2024/07/31/Markov-Algorithm-Online-%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>笔者接触了一种<a href="https://mao.snuke.org/">全新游戏</a>(加班.jpg),网上查了一圈发现没有做这个游戏攻略的,Flu只好以身作则,开一期专题聊这个.</p><h1>规则</h1><p>这是一种简单的语言,只有两个语句:<br><code>a:b</code>:把字符串<code>a</code>替换成<code>b</code>.<br><code>a::b</code>:把字符串<code>a</code>替换成<code>b</code>,程序结束.</p><p>(模式/替换的前导/尾随空格会被直接忽略)</p><p><strong>执行顺序</strong>:每次都是先执行前面的语句,如果第一句找到了就执行第一句,然后从头开始接着执行(中间执行了<code>::</code>会直接结束的).</p><h1>题解区</h1><p>好了,你已经学会了所有语法,去写一个程序吧(^_^)~</p><h2 id="0001">0001</h2><p>直接替换.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello,:World!</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">Hello,::World!</span><br></pre></td></tr></table></figure><h2 id="0002">0002</h2><p>删除所有的<code>s</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:</span><br></pre></td></tr></table></figure><h2 id="0003">0003</h2><p>把<code>s</code>加在头上(注意只能执行一次防止死循环)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::s</span><br></pre></td></tr></table></figure><h2 id="0004">0004</h2><p>剪刀石头布,对每种情况进行替换,注意每种只能执行一次.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R::P</span><br><span class="line">P::S</span><br><span class="line">S::R</span><br></pre></td></tr></table></figure><h2 id="0005">0005</h2><p>给一堆只有<code>i</code>的串,在每个之间插一个<code>w</code>.<br>也就是把所有<code>ii</code>换成<code>iwi</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ii:iwi</span><br></pre></td></tr></table></figure><h2 id="0006">0006</h2><p>对ABC进行排序,枚举三种将要进行的排序准则分别替换即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BA:AB</span><br><span class="line">CB:BC</span><br><span class="line">BA:AC</span><br></pre></td></tr></table></figure><h2 id="0007">0007</h2><p>给一段<code>o</code>判断有奇数个还是偶数个.<br>发现两个<code>o</code>没有贡献,直接消掉,最后判断即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oo:</span><br><span class="line">o::odd</span><br><span class="line">::even</span><br></pre></td></tr></table></figure><p>(注意先判有的odd,因为even是兜底的)</p><h2 id="0008">0008</h2><p>(感觉开始上强度了)给一段只有<code>b</code>的串,加一个<code>s</code>在末尾.<br>首先,是个人都应该清楚,因为字符串检测是从头开始的,我们要在<code>bb</code>这样的里面加东西.</p><p>加啥?Flu设想的是先把<code>bb</code>变成<code>bsb</code>,然后掉转顺序变成<code>bbs</code>,最后删掉所有的<code>bsb</code>.写出来长这样:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bb:bsb</span><br><span class="line">sb:bs</span><br><span class="line">bsb:bb</span><br></pre></td></tr></table></figure><p>跑起来死循环啊…考虑优化:<strong>顺序优化</strong>.每次查子串是从第一句开始查,也就是说符合条件的语句编号越小越优先执行,调整一下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sb:bs</span><br><span class="line">bb:bsb</span><br><span class="line">bsb:bb</span><br></pre></td></tr></table></figure><p>这个时候我们发现,他变成了一直往尾部加<code>s</code>,一个,两个…<br>到这应该明白了吧,我们让<code>b</code>变成<code>bs</code>,然后把<code>sb:bs</code>的交换优先级调整的比添加高,就可以顺到最后了,然后<code>ss::s</code>结束,完美.(<code>bb:bsb</code>会WA,只有一个<code>b</code>的情况)AC代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ss::s</span><br><span class="line">sb:bs</span><br><span class="line">b:bs</span><br></pre></td></tr></table></figure><h2 id="0009">0009</h2><p>给一个二进制串,按位反转.<br>首先想到,交换嘛,肯定有个tmp的防止反转再反转,于是<code>0</code>先换成<code>2</code>,再换成<code>1</code>,<code>1</code>也一样,调一下优先级.</p><p>发现,死循环了.我们注意到,即使是结果也是可以当输入的,我们要手动结束程序,于是考虑扫描,从左插一个<code>a</code>,每次枚举<code>a</code>左边的进行反转,<code>a</code>到头结束.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a0:<span class="number">1</span>a</span><br><span class="line">a1:<span class="number">0</span>a</span><br><span class="line">a::</span><br><span class="line">:a</span><br></pre></td></tr></table></figure><h2 id="0010">0010</h2><p>写一个加法器.<br>首先我们需要插一个东西在末尾.我们如何判定他插到末尾了?<br><strong>答:</strong> 插两个的时候.<br>然后程序向前遍历就很好写了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>ss::<span class="number">1</span></span><br><span class="line"><span class="number">1</span>ss:ss0</span><br><span class="line">ss::<span class="number">1</span></span><br><span class="line">s0:<span class="number">0</span>s</span><br><span class="line">s1:<span class="number">1</span>s</span><br><span class="line">:s</span><br></pre></td></tr></table></figure><h2 id="0011">0011</h2><p>计数.<br>首先,每一个o都是看成1,进位的时候直接放到左边即可.<br>数之间不允许直接加,否则会乱位,于是调整一下<code>o</code>变成<code>1</code>的优先级即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>o:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>o:<span class="number">2</span></span><br><span class="line"><span class="number">2</span>o:<span class="number">3</span></span><br><span class="line"><span class="number">3</span>o:<span class="number">4</span></span><br><span class="line"><span class="number">4</span>o:<span class="number">5</span></span><br><span class="line"><span class="number">5</span>o:<span class="number">6</span></span><br><span class="line"><span class="number">6</span>o:<span class="number">7</span></span><br><span class="line"><span class="number">7</span>o:<span class="number">8</span></span><br><span class="line"><span class="number">8</span>o:<span class="number">9</span></span><br><span class="line"><span class="number">9</span>o:o0</span><br><span class="line">o:<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="0012">0012</h2><p>会11的话12就很简单了.反向搞就行,注意0作为进位标志最后再摘.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:<span class="number">0</span>o</span><br><span class="line"><span class="number">2</span>:<span class="number">0</span>oo</span><br><span class="line"><span class="number">3</span>:<span class="number">0</span>ooo</span><br><span class="line"><span class="number">4</span>:<span class="number">0</span>oooo</span><br><span class="line"><span class="number">5</span>:<span class="number">0</span>ooooo</span><br><span class="line"><span class="number">6</span>:<span class="number">0</span>oooooo</span><br><span class="line"><span class="number">7</span>:<span class="number">0</span>ooooooo</span><br><span class="line"><span class="number">8</span>:<span class="number">0</span>oooooooo</span><br><span class="line"><span class="number">9</span>:<span class="number">0</span>ooooooooo</span><br><span class="line">o0:<span class="number">0</span>oooooooooo</span><br><span class="line"><span class="number">0</span>:</span><br></pre></td></tr></table></figure><h2 id="0013">0013</h2><h2 id="0014">0014</h2><h2 id="0015">0015</h2><h2 id="0016">0016</h2><p>显然,比5长的直接迭代缩减即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oooooo:ooooo</span><br></pre></td></tr></table></figure><h2 id="0017">0017</h2><p>显然,比5短的直接迭代增加即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ooooo::ooooo</span><br><span class="line">:o</span><br></pre></td></tr></table></figure><h2 id="0018">0018</h2><p>(最后还是看题解改成6行的屑)判断<code>ox</code>序列哪个多,输出<code>win,lose,draw</code>.<br>难点在于6行内完成.题解借用很长一段<code>x</code>保证<code>xo</code>一定能消掉<code>o</code>,从而完成消掉另一方,然后再归还<code>x</code>,多就是输,默认赢,不变就是平手.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xo:</span><br><span class="line">win+xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx:lose+</span><br><span class="line">win+xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx:draw+</span><br><span class="line">+x:+</span><br><span class="line">+::</span><br><span class="line">:win+xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure><h2 id="0019">0019</h2><p>发现排好序一定是<code>12345</code>,考虑如何把12345搞掉:好像没啥别的办法.不讲武德.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:</span><br><span class="line"><span class="number">2</span>:</span><br><span class="line"><span class="number">3</span>:</span><br><span class="line"><span class="number">4</span>:</span><br><span class="line"><span class="number">5</span>::<span class="number">12345</span></span><br></pre></td></tr></table></figure><h2 id="0020">0020</h2><p>给一个数字串,在每两个数字间加点.<br>显然,直接扫描即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a0:<span class="number">0.</span>a</span><br><span class="line">a1:<span class="number">1.</span>a</span><br><span class="line">a2:<span class="number">2.</span>a</span><br><span class="line">a3:<span class="number">3.</span>a</span><br><span class="line">a4:<span class="number">4.</span>a</span><br><span class="line">a5:<span class="number">5.</span>a</span><br><span class="line">a6:<span class="number">6.</span>a</span><br><span class="line">a7:<span class="number">7.</span>a</span><br><span class="line">a8:<span class="number">8.</span>a</span><br><span class="line">a9:<span class="number">9.</span>a</span><br><span class="line">.a::</span><br><span class="line">:a</span><br></pre></td></tr></table></figure><h2 id="0023">0023</h2><p>给一个数列(只有<code>012</code>),求他们的和模3.<br>显然暴力是会超行的,我们考虑替换,把0替换成111,2换成11就可以很简单的消除了.但是注意一个小坑是<code>111:</code>错<code>1111:1</code>对,因为假如最后没数字了就寄了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">111</span></span><br><span class="line"><span class="number">2</span>:<span class="number">11</span></span><br><span class="line"><span class="number">1111</span>:<span class="number">1</span></span><br><span class="line"><span class="number">111</span>::<span class="number">0</span></span><br><span class="line"><span class="number">11</span>::<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="0032">0032</h2><p>发现值域很窄,直接枚举.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xo:x</span><br><span class="line">oooooooooooooooooooooooooooooooo:<span class="number">5</span>x</span><br><span class="line">oooooooooooooooo:<span class="number">4</span>x</span><br><span class="line">oooooooo:<span class="number">3</span>x</span><br><span class="line">oooo:<span class="number">2</span>x</span><br><span class="line">oo:<span class="number">1</span>x</span><br><span class="line">o:<span class="number">0</span>x</span><br><span class="line">x::</span><br></pre></td></tr></table></figure><h2 id="0035">0035</h2><p>把第三个字符替换成<code>x</code>,送分.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ooo::oox</span><br></pre></td></tr></table></figure><h2 id="0036">0036</h2><p>把倒数第三个字符替换成<code>x</code>,插一个a,扫到末尾,结束,还是送分.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ao:oa</span><br><span class="line">oooa::xoo</span><br><span class="line">:a</span><br></pre></td></tr></table></figure><h2 id="0037">0037</h2><p>直接替换,注意第一个问号的优先级是最低的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m?:ma</span><br><span class="line">a?:ar</span><br><span class="line">r?:rk</span><br><span class="line">k?:ko</span><br><span class="line">o?:ov</span><br><span class="line">?:m</span><br></pre></td></tr></table></figure><h2 id="0038">0038</h2><p>发现转移的时候多余的o会没,但是最终状态的o也会跟着没,考虑扫描.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xbob:oxb</span><br><span class="line">xb:x</span><br><span class="line">xo:x</span><br><span class="line">x::</span><br><span class="line">:x</span><br></pre></td></tr></table></figure><h2 id="0045">0045</h2><p>直接删掉<code>-</code>即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-:</span><br></pre></td></tr></table></figure><h2 id="0048">0048</h2><p>找最大公因数即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ooo:oof</span><br><span class="line">oofoofoofoofoof:oofobfoofbofooz</span><br><span class="line">oofoofoofo:oofobfoofb</span><br><span class="line">oofoo:oofob</span><br></pre></td></tr></table></figure><h2 id="0049">0049</h2><p>直接替换.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bb:ba</span><br></pre></td></tr></table></figure><h2 id="0050">0050</h2><p>替换小心头部重复替换.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aa:ba</span><br><span class="line">bbb:bab</span><br></pre></td></tr></table></figure><h2 id="0051">0051</h2><p>扫描一遍即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zab:baz</span><br><span class="line">z::</span><br><span class="line">:z</span><br></pre></td></tr></table></figure><h2 id="0052">0052</h2><p>来一个被减数,左右对消即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ozo:z</span><br><span class="line">z::</span><br><span class="line">:ooooooooooz</span><br></pre></td></tr></table></figure><h2 id="0053">0053</h2><p>这里开始是几道闪电题,意思是尽快做出来而不是压行做出来,题目也非常傻逼(难).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xoo:ox</span><br><span class="line">x::</span><br><span class="line">:x</span><br></pre></td></tr></table></figure><h2 id="0054">0054</h2><h2 id="0061">0061</h2><p>冒号不能动,右边减一个左边加一个即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(:</span><br><span class="line">::(</span><br></pre></td></tr></table></figure><h2 id="0062">0062</h2><p>考虑整体转变,<code>00</code>先变成<code>01</code>再一个变成<code>00</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>:<span class="number">01</span></span><br><span class="line"><span class="number">01</span>::<span class="number">00</span></span><br></pre></td></tr></table></figure><h2 id="0063">0063</h2><p>打印空格.由于前导/尾随空格都会没,我们要构造两面包夹的形态.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">114514</span>:</span><br><span class="line"><span class="number">1919810</span>::</span><br><span class="line">:<span class="number">114514</span> <span class="number">1919810</span></span><br></pre></td></tr></table></figure><h2 id="0064">0064</h2><p>我们要去掉中间的空格,显然扫描线做.<br>注意到我们开头要插入一个没空格的,这里是没法转移的.我们考虑插一个形如<code>x y</code>的结构,然后再把y去掉,就可以成功转移了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x a:ax</span><br><span class="line">x b:bx</span><br><span class="line">x c:cx</span><br><span class="line">y:</span><br><span class="line">x::</span><br><span class="line">:x y</span><br></pre></td></tr></table></figure><h2 id="0069">0069</h2><p>注意到数据是4个<code>t</code>起手,考虑做一个头然后沿伸.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testtt:testtest</span><br><span class="line">tttt:testtest</span><br></pre></td></tr></table></figure><h2 id="0078">0078</h2><p>直接查找.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iwi::[iwi]</span><br></pre></td></tr></table></figure><h2 id="0079">0079</h2><p>发现最优解只有四行,而且由于结果可以作为输入,只好使用扫描线.但是扫描头添加(2),转移(2),检测(1),超了,要魔改.</p><p>咋改呢?有个好方法:鉴于只有<code>iw</code>,我们可以构造:很多<code>iiiiii</code>,然后不用转移<code>ii</code>,转移<code>iw</code>,就结束了.正好四行.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iiiiiiiiiiiiiiiiiiiiiiwi:[iwi]iiiiiiiiiiiiiiiiiiiii</span><br><span class="line">iiiiiiiiiiiiiiiiiiiiiw:wiiiiiiiiiiiiiiiiiiiii</span><br><span class="line">iiiiiiiiiiiiiiiiiiiii::</span><br><span class="line">:iiiiiiiiiiiiiiiiiiiii</span><br></pre></td></tr></table></figure><h2 id="0080">0080</h2><p>发现拆括号的过程就是放到外面然后乘二即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o]:]oo</span><br><span class="line">[]:</span><br></pre></td></tr></table></figure><h2 id="0085">0085</h2><p>我们考虑同质化,把他们变成0+啥,然后由于最后一个数字也肯定是<code>0+</code>,所以考虑<code>+0:0</code>,然后最后转化回去就可以了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>:<span class="number">0</span>++</span><br><span class="line"><span class="number">1</span>:<span class="number">0</span>+</span><br><span class="line">+<span class="number">0</span>:<span class="number">0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0</span></span><br><span class="line"><span class="number">0</span>++::<span class="number">2</span></span><br><span class="line"><span class="number">0</span>+::<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语法</title>
      <link href="/2024/07/30/C-%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/07/30/C-%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>这里包含部分C++的语法以及调试技巧啥的,比较杂.</p><h1>基础库</h1><h2 id="杂项">杂项</h2><p>多表达式叠写返回值是后面那个.例如<code>a=b,1</code>返回后面那个<code>1</code>不是前面那个<code>a</code>.</p><p><code>unordered_map</code>不可以开出来自定义类型的图,因为没法算哈希,<code>map</code>可以.</p><h2 id="namespace">namespace</h2><p>名字空间就是防止名字重复特地设置的命名机制,形象理解就是套层壳,使用必须先叫名字空间::成员函数.对于不重的情况确实没啥用.<br>然后<code>using namespace xx</code>就是把封装好的函数直接用就行了(去壳).比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> IO&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; num)</span></span>&#123;xxx&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用:IO::read(xxx);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;<span class="comment">//去掉壳子</span></span><br><span class="line"><span class="comment">//调用:read(xxx);</span></span><br></pre></td></tr></table></figure><h2 id="typedef">typedef</h2><p>直观的就是给一个变量取一个小名,大名小名都能用.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> i32;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">float</span><span class="params">(*Func)</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aaa</span><span class="params">(Func f1,Func f2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aaa</span><span class="params">(<span class="type">float</span> f1(<span class="type">int</span> arr[],<span class="type">int</span> num),<span class="type">float</span> f2(<span class="type">int</span> arr[],<span class="type">int</span> num))</span></span>;</span><br></pre></td></tr></table></figure><p>可以直接置换函数,体会一下.</p><h2 id="math-h">math.h</h2><p><strong>cbrt</strong>:算立方根的函数.<br><strong>log</strong>:其实是求ln.<br><strong>log10</strong>:其实是求lg.<br><strong>ceil</strong>:向上取整.<br><strong>floor</strong>:向下取整.</p><h2 id="windows-h">windows.h</h2><p>系统相关的库文件,盲目交到OJ上会吃CE(一般OJ都是Linux).但是制作课设会用到(交互嘛).<br><strong>Sleep</strong>:睡觉函数,单位毫秒.<br><strong>system(“”)</strong>:著名的弹计算器函数.(真的能给我电脑直接干关机了,他能干啥不可想象,写病毒轻轻松松)</p><h2 id="IO">IO</h2><p>有的时候数据点多少个不告诉你,就需要用这个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对拍">对拍</h2><p>先写一个数据生成器再说…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;data.exe &gt; sstd.in&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;sstd.exe &lt; sstd.in &gt; sstd.out&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;your.exe &lt; sstd.in &gt; your.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">system</span>(<span class="string">&quot;rc sstd.txt your.txt&quot;</span>))<span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sstd可以是暴力,data是生成器.</p><h1>STL</h1><p>这里讲一些常用函数,免得忘了.</p><h2 id="vector">vector</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">push_back</span>(x)<span class="comment">//末尾插一个</span></span><br><span class="line">.<span class="built_in">pop_back</span>()<span class="comment">//末尾删一个</span></span><br><span class="line">[x]<span class="comment">//当成数组使用</span></span><br><span class="line">.<span class="built_in">empty</span>()<span class="comment">//是否为空</span></span><br><span class="line">.<span class="built_in">size</span>()<span class="comment">//大小</span></span><br><span class="line">.<span class="built_in">front</span>(),.<span class="built_in">back</span>()<span class="comment">//首尾元素</span></span><br><span class="line">::iterator<span class="comment">//指针</span></span><br><span class="line">.<span class="built_in">begin</span>(),.<span class="built_in">end</span>()<span class="comment">//首尾迭代器</span></span><br></pre></td></tr></table></figure><h2 id="stack">stack</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">top</span>()</span><br><span class="line">.<span class="built_in">push</span>()</span><br><span class="line">.<span class="built_in">size</span>()</span><br><span class="line">.<span class="built_in">pop</span>()</span><br><span class="line">.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><h2 id="queue">queue</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">push</span>()</span><br><span class="line">.<span class="built_in">pop</span>()</span><br><span class="line">.<span class="built_in">empty</span>()</span><br><span class="line">.<span class="built_in">front</span>(),.<span class="built_in">back</span>()</span><br><span class="line">.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><h2 id="deque">deque</h2><p>双端队列,都差不多.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">push_back</span>(x);</span><br><span class="line">.<span class="built_in">push_front</span>(x);</span><br><span class="line">.<span class="built_in">front</span>();</span><br><span class="line">.<span class="built_in">back</span>();</span><br><span class="line">.<span class="built_in">pop_back</span>();</span><br><span class="line">.<span class="built_in">pop_front</span>();</span><br></pre></td></tr></table></figure><h2 id="priority-queue">priority_queue</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">top</span>()</span><br><span class="line">.<span class="built_in">push</span>()</span><br><span class="line">.<span class="built_in">size</span>()</span><br><span class="line">.<span class="built_in">pop</span>()</span><br><span class="line">.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><h2 id="map">map</h2><p>红黑树,logn插入logn查询,支持自定义结构.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[x]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:mp)&#123;</span><br><span class="line">i.first,i.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unordered-map">unordered_map</h2><p>哈希表但是常数比较大,不支持自定义哈希.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[x]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:mp)&#123;</span><br><span class="line">i.first,i.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为人家是哈希表,有的东西开不了,能不能开和前一个键有关.前面一个键只能是常见类型,<code>char</code>,<code>short</code>,<code>int</code>,<code>long</code>,<code>long long</code>都是能开的,但是所有自定义类型都不可以,包括<code>pair</code>.</p><h2 id="set">set</h2><h2 id="bitset">bitset</h2><p>没用.常数听说比较大,而且省不了多少空间.</p><h2 id="multiset">multiset</h2><h2 id="multimap">multimap</h2><h2 id="stringUUU">stringUUU</h2><p>Flu不太会用.</p><h2 id="tuple">tuple</h2><h2 id="tie">tie</h2><p>UUU</p><h2 id="list">list</h2><p>封装的双向链表.废物,不支持随机化访问,真就单纯的一个链表是吧.</p><h1>PB_DS</h1><p>UUU</p><h1>OTH</h1><h2 id="lambda表达式">lambda表达式</h2><p>这玩意不是必须学的,能用它实现的功能用普通C++也可以实现,在这里偷个懒略了.</p><h2 id="对拍-2">对拍</h2><p>先写一个数据生成器再说…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;data.exe &gt; sstd.in&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;sstd.exe &lt; sstd.in &gt; sstd.out&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;your.exe &lt; sstd.in &gt; your.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">system</span>(<span class="string">&quot;rc sstd.txt your.txt&quot;</span>))<span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sstd可以是暴力,data是生成器.</p>]]></content>
      
      
      <categories>
          
          <category> OTH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP</title>
      <link href="/2024/07/29/DP/"/>
      <url>/2024/07/29/DP/</url>
      
        <content type="html"><![CDATA[<h2 id="期望DP">期望DP</h2><p>期望dp的状态一般设定为 <strong>dp[i]:已经取到i个,取完剩下的期望xx</strong> .然后列转移方程,比个例子:有n种邮,第k次买邮票的价格是k元,每次买邮票等概率随机一种,问一个人想买到这总共n种邮票期望花多少钱.</p><p>我们发现第k次取和价钱挂钩,于是要设两个式子: $f(x)$ 表示已经取到了x,取完总共n种的期望 <strong>次数</strong>, $g(x)$ 表示已经取到了x,期望取完的 <strong>价钱</strong> .于是有<br>$$f(x)=\frac xnf(x)+\frac{n-x}nf(x+1)+1$$<br>$$g(x)=\frac xn(g(x)+f(x)+1)+\frac{n-x}n(g(x+1)+f(x+1)+1)$$<br>关于g的表达式:有x/n的概率不动,也就是期望不变,后面的f(x)是期望的代价是次数,+1表示每次都要比之前贵一块,体现在这里.</p><h2 id="矩阵优化">矩阵优化</h2><p>指通过广义矩阵乘法让dp的方式优化,支持数据结构维护的操作.</p><p>定义广义矩阵乘法的操作是:<br>$$C_{i,j}=\bigoplus_{k=1}^m(A_{ik}\otimes B_{kj})$$<br>(其实就是重载+和*俩运算符)满足以下条件时乘法有 <strong>结合律</strong>:</p><ol><li>$\oplus$ 有交换律</li><li>$\otimes$ 有结合律和交换律</li><li>$\times$ 对 $\oplus$ 有分配律,也就是满足 $(a\oplus b)\otimes c=(a\otimes c)\oplus(b\otimes c)$ .</li></ol><p>常见的广义矩阵重载是(原来是 $(\times,+)$ ) $(\pm,\min),(\pm,\max),(\land,\lor)$</p><p>如此,矩阵可以使用快速幂优化,同时可以使用数据结构提前维护区间矩阵乘积,便于快速计算.</p><h2 id="例题">例题</h2><ol><li>GSS3单点修改,维护区间的最大子段和.<br>我们设 $f_i$ 表示以i结尾的最大子段和, $g_i$ 表示区间上的最大子段和.转移方程:<br>$$f_i=\max(f_{i-1}+a_i,a_i),g_i=\max(g_{i-1},f_{i-1}+a_i,a_i)$$<br>构造矩阵:<br>$$\begin{bmatrix}f_{i-1}&amp;g_{i-1}&amp;0\end{bmatrix}\begin{bmatrix}a_i&amp;a_i&amp;-\infin\-\infin&amp;0&amp;-\infin\a_i&amp;a_i&amp;0\end{bmatrix}=\begin{bmatrix}f_i&amp;g_i&amp;0\end{bmatrix}$$<br>然后使用线段树提前维护区间矩阵乘积即可.</li></ol>]]></content>
      
      
      <categories>
          
          <category> OTH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python语法</title>
      <link href="/2024/07/28/Python%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/07/28/Python%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>这里讲一些基础语法.(基本上,精通一种语言,别的语言都大差不差能看懂)</p><h2 id="初等函数">初等函数</h2><h3 id="print">print</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串&quot;</span>,算式,变量)</span><br></pre></td></tr></table></figure><p>参数:sep分隔符,默认空格,可以换成别的,end结尾符,默认换行,可以换别的.</p><h3 id="eval">eval</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">7</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;3*x&#x27;</span>)</span><br></pre></td></tr></table></figure><p>eval把字符串转换成算式并给出计算结果.</p><h3 id="namespace">namespace</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">namespace=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;a+b&#x27;</span>,namespace)</span><br></pre></td></tr></table></figure><p>在指定名字空间内执行语句长这样.</p><h3 id="if-else-elif-while-for">if else elif while for</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> xxx:</span><br><span class="line">    xxx</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    xxx</span><br><span class="line"><span class="keyword">elif</span>:</span><br><span class="line">    xxx</span><br><span class="line"><span class="keyword">while</span> xxx:</span><br><span class="line">    xxx</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(xxx):</span><br><span class="line">    xxx</span><br></pre></td></tr></table></figure><h4 id="range">range</h4><p>range可以接受三个参数,分别是[l,r)和步长.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">12</span>,<span class="number">16</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 12 14</span></span><br></pre></td></tr></table></figure><h3 id="注释">注释</h3><p>注释长这样:(只有一种注释方法,就是这个,单行有效,按住Ctrl+/即可)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xxx</span></span><br></pre></td></tr></table></figure><h3 id="变量类型">变量类型</h3><p>Python内置高精(C艹党吐血倒地),变量类型可以转变,有以下几种:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> <span class="built_in">int</span> string Bool(<span class="literal">True</span> <span class="literal">False</span>) 字典 列表 元组</span><br></pre></td></tr></table></figure><p>其中元组就是const形态的列表,一般用于函数返回值.(TF这俩必须大写,不大写认不出来)</p><h3 id="运算">运算</h3><p>按优先级排序:(上面的最高)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**幂</span><br><span class="line">~按位反</span><br><span class="line">* /除法 % //整除</span><br><span class="line">+ -</span><br><span class="line">&gt;&gt; &lt;&lt;</span><br><span class="line">&amp;</span><br><span class="line">^ |</span><br><span class="line">&lt;= &lt; &gt; &gt;=</span><br><span class="line">== !=</span><br><span class="line">= %= /= //= -= += *= **=</span><br><span class="line"><span class="keyword">is</span>  <span class="keyword">is</span> <span class="keyword">not</span></span><br><span class="line"><span class="keyword">in</span>  <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">and</span>  <span class="keyword">or</span> <span class="keyword">not</span></span><br></pre></td></tr></table></figure><p>小技巧:按住Ctrl+C会立刻结束程序的,不妨试试(C++也一样)</p><h3 id="import">import</h3><p>导入包.为了避免变量名冲突,建议只用<code>import xxx</code>的格式,<code>from xxx import*</code>会闹麻的(变量名冲突)</p>]]></content>
      
      
      <categories>
          
          <category> MachineLearn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公式杂项</title>
      <link href="/2024/07/25/%E5%85%AC%E5%BC%8F%E6%9D%82%E9%A1%B9/"/>
      <url>/2024/07/25/%E5%85%AC%E5%BC%8F%E6%9D%82%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>RT,这里放一些奇奇怪怪的公式.</p><h2 id="常见质数">常见质数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">99844353</span></span><br><span class="line"><span class="number">1000000007</span> <span class="number">1e9</span>+<span class="number">7</span></span><br><span class="line"><span class="number">100000000000000003</span> <span class="number">1e17</span>+<span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="判定奇数-判定偶数">判定奇数 判定偶数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n&amp;<span class="number">1</span>   <span class="comment">//奇数</span></span><br><span class="line">n&amp;<span class="number">1</span>^<span class="number">1</span> <span class="comment">//偶数,再也不用 !(n&amp;1)</span></span><br></pre></td></tr></table></figure><h2 id="MEX">MEX</h2><p>定义是最小的没出现在数列中的非负整数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mex</span><span class="params">(<span class="type">int</span>* dat,<span class="type">int</span> n)</span></span>&#123;<span class="comment">//[1,n]</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">mp[dat[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(mp[i]!=<span class="number">1</span>)<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下是求第k大mex,也就是第k个没出现的非负整数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">mex</span><span class="params">(T* p,T n,T k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> (p[<span class="number">1</span>]&lt;k?k:k<span class="number">-1</span>);</span><br><span class="line">T gg=<span class="number">0</span>;k--;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">gg=<span class="built_in">gcd</span>(gg,p[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">p[i]=(i<span class="number">-1</span>)*gg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]&lt;=k)k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="卡特兰数">卡特兰数</h2><p>$$Catalan_n=\frac{(2n)!}{n!(n+1)!}$$<br>$$f[n]=f[0]*f[n−1]+f[1]*f[n−2]+…+f[n−1]*f<a href="n%5Cge2">0</a>$$<br>$$1,1,2,5,14,42,132,429$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">__int128 <span class="title">Catalan</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">__int128 f[n+<span class="number">1</span>]&#123;&#125;;</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">f[i]+=f[j]*f[i-j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="随机数生成">随机数生成</h2><p>使用<code>MT19937</code>作为随机数引擎.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">std::mt19937 <span class="title">r32</span><span class="params">(chrono::system_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">rand32</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> l,<span class="type">unsigned</span> <span class="type">int</span> r)</span></span>&#123;<span class="comment">//[l,r]</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">r32</span>()%(r-l+<span class="number">1</span>)+l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::mt19937_64 <span class="title">r64</span><span class="params">(chrono::system_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">rand64</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> l,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> r)</span></span>&#123;<span class="comment">//[l,r]</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">r64</span>()%(r-l+<span class="number">1</span>)+l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="斐波那契数列-广义斐波那契数列">斐波那契数列(广义斐波那契数列)</h2><p>$$a_n=pa_{n-1}+qa_{n-2}$$<br>可以转换成矩阵乘法的形式:<br>$$\begin{bmatrix}a_{n-1}&amp;a_{n-2}\end{bmatrix}\begin{bmatrix}p&amp;1\q&amp;0\end{bmatrix}=\begin{bmatrix}a_n&amp;a_{n-1}\end{bmatrix}$$<br>所以有(假设 $a_0$ 是1)<br>$$\begin{bmatrix}1&amp;1\end{bmatrix}\begin{bmatrix}1&amp;1\1&amp;0\end{bmatrix}^n=\begin{bmatrix}a_n&amp;a_{n-1}\end{bmatrix}$$<br>函数只填第几项就是传统斐波那契数列了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> num,<span class="type">long</span> <span class="type">long</span> a1=<span class="number">1</span>,<span class="type">long</span> <span class="type">long</span> a2=<span class="number">1</span>,<span class="type">int</span> p=<span class="number">1</span>,<span class="type">int</span> q=<span class="number">1</span>,<span class="type">long</span> <span class="type">long</span> mod=<span class="number">1000000007</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//第几项，第一项第二项，系数1和2，取模 </span></span><br><span class="line"><span class="comment">//an=p*an-1+qan-2</span></span><br><span class="line"><span class="keyword">if</span>(num&lt;<span class="number">3</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(num==<span class="number">1</span>)<span class="keyword">return</span> a1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a2;</span><br><span class="line">&#125;</span><br><span class="line">num-=<span class="number">3</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> tmp[<span class="number">4</span>]=&#123;p,<span class="number">1</span>,q,<span class="number">0</span>&#125;,res[<span class="number">4</span>]=&#123;p,<span class="number">1</span>,q,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(num&amp;<span class="number">1</span>)</span><br><span class="line"><span class="built_in">tie</span>(res[<span class="number">0</span>],res[<span class="number">1</span>],res[<span class="number">2</span>],res[<span class="number">3</span>])=<span class="built_in">make_tuple</span>((res[<span class="number">0</span>]*tmp[<span class="number">0</span>]+res[<span class="number">1</span>]*tmp[<span class="number">2</span>])%mod,(res[<span class="number">0</span>]*tmp[<span class="number">1</span>]+res[<span class="number">1</span>]*tmp[<span class="number">3</span>])%mod,(res[<span class="number">2</span>]*tmp[<span class="number">0</span>]+res[<span class="number">3</span>]*tmp[<span class="number">2</span>])%mod,(res[<span class="number">2</span>]*tmp[<span class="number">1</span>]+res[<span class="number">3</span>]*tmp[<span class="number">3</span>])%mod);</span><br><span class="line"><span class="built_in">tie</span>(tmp[<span class="number">0</span>],tmp[<span class="number">1</span>],tmp[<span class="number">2</span>],tmp[<span class="number">3</span>])=<span class="built_in">make_tuple</span>((tmp[<span class="number">0</span>]*tmp[<span class="number">0</span>]+tmp[<span class="number">1</span>]*tmp[<span class="number">2</span>])%mod,(tmp[<span class="number">0</span>]*tmp[<span class="number">1</span>]+tmp[<span class="number">1</span>]*tmp[<span class="number">3</span>])%mod,(tmp[<span class="number">0</span>]*tmp[<span class="number">2</span>]+tmp[<span class="number">2</span>]*tmp[<span class="number">3</span>])%mod,(tmp[<span class="number">1</span>]*tmp[<span class="number">2</span>]+tmp[<span class="number">3</span>]*tmp[<span class="number">3</span>])%mod);</span><br><span class="line">num&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (res[<span class="number">0</span>]*a2+res[<span class="number">2</span>]*a1)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="日期计算">日期计算</h2><p>基姆拉尔森公式,输入几几年几月几日返回一个数n表示周几.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CalculateWeekDay</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> m,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">1</span>||m==<span class="number">2</span>)m+=<span class="number">12</span>,y--;</span><br><span class="line"><span class="keyword">return</span> ((<span class="number">1LL</span>*d+(m&lt;&lt;<span class="number">1</span>)+<span class="number">3</span>*(m+<span class="number">1</span>)/<span class="number">5</span>+y+y/<span class="number">4</span>-y/<span class="number">100</span>+y/<span class="number">400</span>)%<span class="number">7</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="错排-单点计算">错排(单点计算)</h2><p>解决n种元素的排列满足每一个都不在原先自己的位置上.公式:<br>$$D(n)=n!\sum_{k=0}^n\frac{(-1)^k}{k!}$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">__int128 <span class="title">Derangement</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">__int128 rres=<span class="number">0</span>,tmp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;num;++i)&#123;</span><br><span class="line">rres=(rres+(num-i)&amp;<span class="number">1</span>?tmp:-tmp)%mod;</span><br><span class="line">tmp=tmp*(num+<span class="number">1</span>-i)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rres;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="错排-预处理递推">错排(预处理递推)</h2><p>$$D_n=(n-1)(D_{n-1}+D_{n-2})$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> D[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">D[<span class="number">0</span>]=<span class="number">1</span>;D[<span class="number">1</span>]=<span class="number">0</span>,D[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;++i)&#123;</span><br><span class="line">D[i]=(i<span class="number">-1</span>)*(D[i<span class="number">-1</span>]+D[i<span class="number">-2</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="康托展开">康托展开</h2><p>解决n个元素的一种排列按顺序排列的名次.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fenwick</span>&#123;</span><br><span class="line"><span class="type">int</span> dat[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aadd</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;pos&lt;=n;pos+=<span class="built_in">lowbit</span>(pos))&#123;</span><br><span class="line">dat[pos]+=val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qquery</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;pos;pos-=<span class="built_in">lowbit</span>(pos))&#123;</span><br><span class="line">res+=dat[pos];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> fact[<span class="number">1000010</span>];</span><br><span class="line">fenwick cantor;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ffact</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">fact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;++i)&#123;</span><br><span class="line">fact[i]=fact[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">CantorExpension</span><span class="params">(<span class="type">int</span>* tar,<span class="type">int</span> num)</span></span>&#123;<span class="comment">//[1,n]</span></span><br><span class="line"><span class="built_in">ffact</span>(num);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=num;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">k=cantor.<span class="built_in">qquery</span>(tar[i]);</span><br><span class="line">cantor.<span class="built_in">aadd</span>(tar[i],<span class="number">1</span>);</span><br><span class="line">res=(res+fact[num-i]*k)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (res+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="康托逆展开UUU">康托逆展开UUU</h2><p>RT,这是给一个排名求出第几个排列的过程,逆着来的.</p><h2 id="逆序对">逆序对</h2><p>公式是<br>$$\sum_{i=1}^{n}\sum_{j=i+1}^n[a_i&gt;a_j]$$<br>该函数同时还是归并排序板子(参数是dat序列ddat辅助空数组res接受结果lr排序范围,写1-n或者0-(n-1)都可以)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ssort</span><span class="params">(<span class="type">int</span>* dat,<span class="type">int</span>* ddat,<span class="type">long</span> <span class="type">long</span>&amp; res,<span class="type">int</span> l,<span class="type">int</span> mid,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> hi=l,ho=mid+<span class="number">1</span>,top=l;</span><br><span class="line"><span class="keyword">while</span>(hi&lt;=mid&amp;&amp;ho&lt;=r)&#123;</span><br><span class="line"><span class="keyword">if</span>(dat[hi]&gt;dat[ho])&#123;</span><br><span class="line">res+=mid-hi+<span class="number">1</span>;</span><br><span class="line">ddat[top++]=dat[ho++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ddat[top++]=dat[hi++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(hi&lt;=mid)&#123;</span><br><span class="line">ddat[top++]=dat[hi++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(ho&lt;=r)&#123;</span><br><span class="line">ddat[top++]=dat[ho++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">msort</span><span class="params">(<span class="type">int</span>* dat,<span class="type">int</span>* ddat,<span class="type">long</span> <span class="type">long</span>&amp; res,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">msort</span>(dat,ddat,res,l,mid);</span><br><span class="line"><span class="built_in">msort</span>(dat,ddat,res,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">ssort</span>(dat,ddat,res,l,mid,r);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> o=l;o&lt;=r;++o)&#123;</span><br><span class="line">dat[o]=ddat[o];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="欧拉函数-单点">欧拉函数(单点)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">phi</span><span class="params">(T n)</span></span>&#123;</span><br><span class="line">T res=n;</span><br><span class="line"><span class="keyword">for</span>(T i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>)res=res/i*(i<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(n%i==<span class="number">0</span>)n/=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (n!=<span class="number">1</span>)?(res/n*(n<span class="number">-1</span>)):(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="狄利克雷卷积-Dirichlet-Convolution">狄利克雷卷积(Dirichlet Convolution)</h2><p>给定数论函数f和积性函数g,在 $O(n\log\log n)$ 时间内求出 $h=\sum_{i=1}^nf*g$ .</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dirichlet</span><span class="params">(T1* f,T2* g,<span class="type">int</span>* prime,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=primetop;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=n/prime[i];j&gt;=<span class="number">1</span>;--j)&#123;</span><br><span class="line"><span class="type">int</span> t=prime[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> k=j*prime[i];k&lt;=n;k*=prime[i])&#123;</span><br><span class="line">f[k]=f[k]+f[j]*g[t];</span><br><span class="line">t*=prime[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//计算f*g的卷积，f是结果，要求g是积性函数 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dirichlet</span><span class="params">(T* f,<span class="type">int</span>* prime,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=primetop;++i)&#123;</span><br><span class="line"><span class="type">int</span> tmp=n/prime[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tmp;++j)&#123;</span><br><span class="line">f[j*prime[i]]=(f[j*prime[i]]+f[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//计算一个积性函数前缀和（f*1） </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dirichletde</span><span class="params">(T* f,<span class="type">int</span>* prime,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=primetop;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=n/prime[i];j;--j)&#123;</span><br><span class="line">f[j]=f[j]+f[j*prime[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//计算一个积性函数自身后缀和（f*1），也就是f(n)=sum(f(kn)),(kn&lt;n) </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="D函数-数字每位和">D函数(数字每位和)</h2><p>就是字面意思,把十进制每位数都加一起.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DFunction</span><span class="params">(T num)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(num)&#123;</span><br><span class="line">res+=num%<span class="number">10</span>;</span><br><span class="line">num/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="每次可以直线加上gcd-求最小极差">每次可以直线加上gcd,求最小极差</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addgcd</span><span class="params">(T* dat,<span class="type">int</span> n,T ggcd)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">dat[i]%=ggcd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(dat+<span class="number">1</span>,dat+<span class="number">1</span>+n);</span><br><span class="line">T res=dat[n]-dat[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">res=<span class="built_in">min</span>(res,ggcd+dat[i]-dat[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="绕线">绕线</h2><p>给一堆散点和一个区间上下界,每次可以选个点进行反转(绕线),求最小极差.由于无论在哪里想进区间必定只有一种绕法,状态确定,就可以直接遍历检查.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">mirrgcd</span><span class="params">(T* dat,<span class="type">int</span> n,T a,T b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a&gt;b)<span class="built_in">swap</span>(a,b);</span><br><span class="line">T mxx=<span class="number">0</span>,mnn;</span><br><span class="line"><span class="built_in">memset</span>(&amp;mnn,<span class="number">0x7f</span>,<span class="built_in">sizeof</span>(mnn));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">T tmp=((dat[i]/a)&amp;<span class="number">1</span>)?(dat[i]%b):(b-(dat[i]%b));</span><br><span class="line">mxx=<span class="built_in">max</span>(mxx,tmp);</span><br><span class="line">mnn=<span class="built_in">min</span>(mnn,tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mxx-mnn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="镜面对称-上翻下翻">镜面对称(上翻下翻)</h2><p>形象理解为一个点绕着一条线坐标变换的过程.公式是 $2a-i$ .</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">mmirror</span><span class="params">(T i,T a)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>*a-i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="阶乘取模-不算模数的取模">阶乘取模,不算模数的取模</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">facmod</span><span class="params">(<span class="type">int</span>* table,<span class="type">int</span> n,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=p)<span class="keyword">return</span> table[n];</span><br><span class="line"><span class="type">int</span> res=((n/p)&amp;<span class="number">1</span>^<span class="number">1</span>)?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">res=(res*<span class="built_in">facmod</span>(table,n/p,p))%p;</span><br><span class="line">res=(res*<span class="built_in">facmod</span>(table,n%p,p))%p;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="阶乘中有多少个因数">阶乘中有多少个因数</h2><p>$$v_p(n!)$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">faccnt</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">n/=p;</span><br><span class="line">res+=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="摩尔投票">摩尔投票</h2><p>求一个数组中的绝对众数(出现次数大于n/2的元素),时间复杂度O(n),空间复杂度O(1)(边读边算),这玩意因为需要自己读,不封装了,直接裸板子.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>,ttmp,tttmp;</span><br><span class="line">cin&gt;&gt;ttmp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">cin&gt;&gt;tttmp;</span><br><span class="line"><span class="keyword">if</span>(tttmp==ttmp)&#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;<span class="keyword">else</span> cnt--;</span><br><span class="line"><span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">ttmp=tttmp;</span><br><span class="line">cnt=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OTH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>板子</title>
      <link href="/2024/07/23/%E6%9D%BF%E5%AD%90/"/>
      <url>/2024/07/23/%E6%9D%BF%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>RT,这是Flu的板子.(本篇巨长,代码含量极高)</p><p>Flu看到打比赛的时候好多人交了一千行的代码,就知道封装的重要性了.Flu也要有自己的板子!!!</p><h2 id="写在前面-一些约定">写在前面,一些约定</h2><p>Flu不喜欢用宏定义,Flu码风良好,除了不喜欢用空格,原则是能不用就不用,除非碰到必须用的地方(比方小根堆).Flu喜欢加大括号.</p><p>数据结构尽量小写,算法函数尽量大写开头.</p><p><strong>除非特殊说明,数组有效空间是[1,n].</strong></p><p>时间复杂度的所有涉及到 $\log$ 的默认 $\log_2$ 即可.</p><p>顺序:快读,基本函数,数据结构,图论,数学,计算几何.</p><h1>快读,基本函数</h1><h2 id="快读快写">快读快写</h2><p>大佬直接出正解,萌新才会使用快读这种垃圾技巧减少程序运行时间.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关同步流.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> enter fout&lt;&lt;<span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> space fout&lt;&lt;<span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dot fout&lt;&lt;<span class="string">&quot;,&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> oui fout&lt;&lt;<span class="string">&quot;Yes&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> non fout&lt;&lt;<span class="string">&quot;No&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si fout&lt;&lt;<span class="string">&quot;?&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> fastio&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> bufl=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> base1[<span class="number">16</span>]=&#123;<span class="number">1</span>,<span class="number">1e-1</span>,<span class="number">1e-2</span>,<span class="number">1e-3</span>,<span class="number">1e-4</span>,<span class="number">1e-5</span>,<span class="number">1e-6</span>,<span class="number">1e-7</span>,<span class="number">1e-8</span>,<span class="number">1e-9</span>,<span class="number">1e-10</span>,<span class="number">1e-11</span>,<span class="number">1e-12</span>,<span class="number">1e-13</span>,<span class="number">1e-14</span>,<span class="number">1e-15</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> base2[<span class="number">16</span>]=&#123;<span class="number">1</span>,<span class="number">1e1</span>,<span class="number">1e2</span>,<span class="number">1e3</span>,<span class="number">1e4</span>,<span class="number">1e5</span>,<span class="number">1e6</span>,<span class="number">1e7</span>,<span class="number">1e8</span>,<span class="number">1e9</span>,<span class="number">1e10</span>,<span class="number">1e11</span>,<span class="number">1e12</span>,<span class="number">1e13</span>,<span class="number">1e14</span>,<span class="number">1e15</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IN</span>&#123;</span><br><span class="line">FILE *IT;<span class="type">char</span> ibuf[bufl],*is=ibuf,*it=ibuf;</span><br><span class="line"><span class="built_in">IN</span>()&#123;IT=stdin;&#125;<span class="built_in">IN</span>(<span class="type">char</span> *a)&#123;IT=<span class="built_in">fopen</span>(a,<span class="string">&quot;r&quot;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getChar</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(is==it)&#123;it=(is=ibuf)+<span class="built_in">fread</span>(ibuf,<span class="number">1</span>,bufl,IT);<span class="keyword">if</span>(is==it)<span class="keyword">return</span> EOF;&#125;<span class="keyword">return</span> *is++;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getInt</span><span class="params">(Temp &amp;a)</span></span>&#123;a=<span class="number">0</span>;<span class="type">int</span> b=<span class="number">0</span>,c=<span class="built_in">getChar</span>();<span class="keyword">while</span>(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)b^=(c==<span class="number">45</span>),c=<span class="built_in">getChar</span>();<span class="keyword">while</span>(c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>)a=(a&lt;&lt;<span class="number">1</span>)+(a&lt;&lt;<span class="number">3</span>)+c<span class="number">-48</span>,c=<span class="built_in">getChar</span>();<span class="keyword">if</span>(b)a=-a;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getDouble</span><span class="params">(Temp &amp;a)</span></span>&#123;a=<span class="number">0</span>;<span class="type">int</span> b=<span class="number">0</span>,c=<span class="built_in">getChar</span>(),d=<span class="number">0</span>;__int128 e=<span class="number">0</span>,f=<span class="number">0</span>;<span class="keyword">while</span>(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)b^=(c==<span class="number">45</span>),c=<span class="built_in">getChar</span>();<span class="keyword">while</span>(c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>)e=(e&lt;&lt;<span class="number">1</span>)+(e&lt;&lt;<span class="number">3</span>)+c<span class="number">-48</span>,c=<span class="built_in">getChar</span>();<span class="keyword">if</span>(c==<span class="number">46</span>)&#123;c=<span class="built_in">getChar</span>();<span class="keyword">while</span>(c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>)d++,f=(f&lt;&lt;<span class="number">1</span>)+(f&lt;&lt;<span class="number">3</span>)+c<span class="number">-48</span>,c=<span class="built_in">getChar</span>();&#125;a=e+base1[d]*f;<span class="keyword">if</span>(b)a=-a;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">char</span> &amp;a)&#123;a=<span class="built_in">getChar</span>();<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">char</span> *a)&#123;<span class="keyword">do</span>&#123;*a=<span class="built_in">getChar</span>();&#125;<span class="keyword">while</span>(*a&lt;=<span class="number">32</span>);<span class="keyword">while</span>(*a&gt;<span class="number">32</span>)*++a=<span class="built_in">getChar</span>();*a=<span class="number">0</span>;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(string &amp;a)&#123;<span class="type">char</span> b=<span class="built_in">getChar</span>();<span class="keyword">while</span>(b&lt;=<span class="number">32</span>)b=<span class="built_in">getChar</span>();<span class="keyword">while</span>(b&gt;<span class="number">32</span>)a+=b,b=<span class="built_in">getChar</span>();<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">int</span> &amp;a)&#123;<span class="built_in">getInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">long</span> <span class="type">long</span> &amp;a)&#123;<span class="built_in">getInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(__int128 &amp;a)&#123;<span class="built_in">getInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">float</span> &amp;a)&#123;<span class="built_in">getDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">double</span> &amp;a)&#123;<span class="built_in">getDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">long</span> <span class="type">double</span> &amp;a)&#123;<span class="built_in">getDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OUT</span>&#123;</span><br><span class="line">FILE *IT;<span class="type">char</span> obuf[bufl],*os=obuf,*ot=obuf+bufl;<span class="type">int</span> Eps;<span class="type">long</span> <span class="type">double</span> Acc;</span><br><span class="line"><span class="built_in">OUT</span>()&#123;IT=stdout,Eps=<span class="number">6</span>,Acc=<span class="number">0.5</span>;&#125;<span class="built_in">OUT</span>(<span class="type">char</span> *a)&#123;IT=<span class="built_in">fopen</span>(a,<span class="string">&quot;w&quot;</span>),Eps=<span class="number">6</span>,Acc=<span class="number">0.5</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ChangEps</span><span class="params">(<span class="type">int</span> x=<span class="number">6</span>)</span></span>&#123;Eps=x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">flush</span><span class="params">()</span></span>&#123;<span class="built_in">fwrite</span>(obuf,<span class="number">1</span>,os-obuf,IT);os=obuf;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putChar</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;*os++=a;<span class="keyword">if</span>(os==ot)<span class="built_in">flush</span>();&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putInt</span><span class="params">(Temp a)</span></span>&#123;<span class="keyword">if</span>(a&lt;<span class="number">0</span>)&#123;<span class="built_in">putChar</span>(<span class="number">45</span>);a=-a;&#125;<span class="keyword">if</span>(a&lt;<span class="number">10</span>)&#123;<span class="built_in">putChar</span>(a+<span class="number">48</span>);<span class="keyword">return</span>;&#125;<span class="built_in">putInt</span>(a/<span class="number">10</span>);<span class="built_in">putChar</span>(a%<span class="number">10</span>+<span class="number">48</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putLeading</span><span class="params">(Temp a,<span class="type">int</span> b)</span></span>&#123;<span class="keyword">if</span>(!b)<span class="keyword">return</span>;<span class="built_in">putLeading</span>(a/<span class="number">10</span>,b<span class="number">-1</span>);<span class="built_in">putChar</span>(a%<span class="number">10</span>+<span class="number">48</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putDouble</span><span class="params">(Temp a)</span></span>&#123;<span class="keyword">if</span>(a&lt;<span class="number">0</span>)&#123;<span class="built_in">putChar</span>(<span class="number">45</span>);a=-a;&#125;__int128 b=a;<span class="built_in">putInt</span>(b);a-=b;a*=base2[Eps];b=a+Acc;<span class="built_in">putChar</span>(<span class="number">46</span>);<span class="built_in">putLeading</span>(b,Eps);&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">char</span> a)&#123;<span class="built_in">putChar</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> <span class="type">char</span> *a)&#123;<span class="keyword">while</span>(*a)<span class="built_in">putChar</span>(*a++);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(string a)&#123;<span class="keyword">for</span>(<span class="keyword">auto</span> c:a)<span class="built_in">putChar</span>(c);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">int</span> a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">long</span> <span class="type">long</span> a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(__int128 a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">unsigned</span> <span class="type">int</span> a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">unsigned</span> __int128 a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">float</span> a)&#123;<span class="built_in">putDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">double</span> a)&#123;<span class="built_in">putDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">long</span> <span class="type">double</span> a)&#123;<span class="built_in">putDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">~<span class="built_in">OUT</span>()&#123;<span class="built_in">flush</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> fastio::IN;</span><br><span class="line"><span class="keyword">using</span> fastio::OUT;</span><br><span class="line">IN fin;</span><br><span class="line">OUT fout;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m,res;</span><br><span class="line"><span class="comment">//#define NaraFluorine</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NaraFluorine</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;P_.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;std.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">fin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">fin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fout&lt;&lt;res&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用法:fin替代cin,fout替代cout.其中eps默认的6是保留几位小数,可以改.</p><p>现役板子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> enter putchar(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> space putchar(<span class="string">&#x27; &#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dot putchar(<span class="string">&#x27;,&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> oui putchar(<span class="string">&#x27;Y&#x27;</span>),putchar(<span class="string">&#x27;e&#x27;</span>),putchar(<span class="string">&#x27;s&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> non putchar(<span class="string">&#x27;N&#x27;</span>),putchar(<span class="string">&#x27;o&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si putchar(<span class="string">&#x27;?&#x27;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> bufsize=<span class="number">1</span>&lt;&lt;<span class="number">21</span>;</span><br><span class="line"><span class="type">char</span> buf[bufsize],*p1=buf,*p2=buf;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,bufsize,stdin),p1==p2)?EOF:*p1++)</span></span><br><span class="line"><span class="type">char</span> obuf[bufsize],*p3=obuf;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> putchar(x) (p3-obuf&lt;(bufsize))?(*p3++=x):(fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=x)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;sum)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> tf=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">tf=ch==<span class="string">&#x27;-&#x27;</span>?<span class="number">1</span>:<span class="number">0</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">sum=(sum&lt;&lt;<span class="number">1</span>)+(sum&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>),ch=<span class="built_in">getchar</span>();</span><br><span class="line">(tf)&amp;&amp;(sum=-sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> ...Args&gt;<span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;tmp,Args &amp;...tmps)</span></span>&#123;</span><br><span class="line"><span class="built_in">read</span>(tmp);</span><br><span class="line"><span class="built_in">read</span>(tmps...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">printt</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">10</span>)<span class="built_in">printt</span>(x/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">x&lt;<span class="number">0</span>?<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),<span class="built_in">printt</span>(-x):<span class="built_in">printt</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> ...Args&gt;<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T tmp,Args ...tmps)</span></span>&#123;</span><br><span class="line"><span class="built_in">print</span>(tmp);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(tmps...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line"><span class="built_in">print</span>(x),<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> ...Args&gt;<span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(T tmp,Args ...tmps)</span></span>&#123;</span><br><span class="line"><span class="built_in">put</span>(tmp);</span><br><span class="line"><span class="built_in">put</span>(tmps...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readc</span><span class="params">(<span class="type">char</span> &amp;a)</span></span>&#123;<span class="comment">//获取一个字符，自动过滤空格回车 </span></span><br><span class="line">a=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(a==<span class="string">&#x27; &#x27;</span>||a==<span class="string">&#x27;\n&#x27;</span>||a==<span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">a=<span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">char</span>,<span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readc</span><span class="params">(<span class="type">char</span> &amp;a,Args &amp;...b)</span></span>&#123;</span><br><span class="line"><span class="built_in">readc</span>(a);</span><br><span class="line"><span class="built_in">readc</span>(b...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面这俩是打印十六进制数和二进制数的 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">bprint</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">(x&gt;=<span class="number">2</span>)?(<span class="built_in">bprint</span>(x&gt;&gt;<span class="number">1</span>),<span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>+(x&amp;<span class="number">1</span>))):(<span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>+(x&amp;<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">xprint</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">((x^(x&amp;<span class="number">0xf</span>))!=<span class="number">0</span>)?(<span class="built_in">xprint</span>(x&gt;&gt;<span class="number">4</span>),x&amp;=<span class="number">0xf</span>,(x&gt;=<span class="number">10</span>)?(<span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>+x<span class="number">-10</span>)):(<span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>+x))):((x&gt;=<span class="number">10</span>)?(<span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>+x<span class="number">-10</span>)):(<span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>+x)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m,res;</span><br><span class="line"><span class="comment">//#define NaraFluorine</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NaraFluorine</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;P_.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;std.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">read</span>(t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">res=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">read</span>(n,m);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">put</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fwrite</span>(obuf,p3-obuf,<span class="number">1</span>,stdout);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是Flu最常用的快读快写板子.</p><h2 id="位运算">位运算</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> T <span class="title">lowbit</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&amp;-a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowcnt</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __builtin_ctz(num);</span><br><span class="line">&#125;<span class="comment">//最低位1之前有多少个0</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowcnt</span><span class="params">(<span class="type">long</span> <span class="type">long</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __builtin_ctzll(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">highcnt</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __builtin_clz(num);</span><br><span class="line">&#125;<span class="comment">//最高位1之后有多少个0</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">highcnt</span><span class="params">(<span class="type">long</span> <span class="type">long</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __builtin_clzll(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cnt1</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __builtin_popcount(num);</span><br><span class="line">&#125;<span class="comment">//统计这个数有多少个位是1</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cnt1</span><span class="params">(<span class="type">long</span> <span class="type">long</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __builtin_popcountll(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">even1</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __builtin_parity(num);</span><br><span class="line">&#125;<span class="comment">//这个数1的个数的奇偶</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">even1</span><span class="params">(<span class="type">long</span> <span class="type">long</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __builtin_parityll(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">low1</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __builtin_ffs(num);</span><br><span class="line">&#125;<span class="comment">//最低位1是第几位</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">low1</span><span class="params">(<span class="type">long</span> <span class="type">long</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __builtin_ffsll(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">highreal</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __builtin_clrsb(num);</span><br><span class="line">&#125;<span class="comment">//如果符号位是0返回前导0个数-1,否则返回前导1个数-1</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">highreal</span><span class="params">(<span class="type">long</span> <span class="type">long</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __builtin_clrsbll(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> abs(x) ((x^(x&gt;&gt;31))-(x&gt;&gt;31))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> abs64(x) ((x^(x&gt;&gt;63))-(x&gt;&gt;63))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> abs128(x) ((x^(x&gt;&gt;127))-(x&gt;&gt;127))</span></span><br><span class="line"><span class="comment">//绝对值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=num;i;i=(i<span class="number">-1</span>)&amp;num)&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;<span class="comment">//枚举二进制子集(降序)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0 is here</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;(<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>&lt;=num;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x=(<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>,t;x&lt;=num;t=x+(x&amp;-x),x=(t|((((t&amp;-t)/(x&amp;-x))&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>)))&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//二进制1位数相同数的枚举顺序增序排列,O(n)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="常用库函数">常用库函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">cmax</span><span class="params">(T1&amp; num,T2 val)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (num&lt;=val)?(num=val,<span class="number">1</span>):<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">cmin</span><span class="params">(T1&amp; num,T2 val)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (num&gt;=val)?(num=val,<span class="number">1</span>):<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>数据结构</h1><h2 id="二分-最小值">二分(最小值)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">BSCheck</span><span class="params">(T num)</span></span>&#123;</span><br><span class="line"><span class="comment">//checker自己写 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">BinarySearch</span><span class="params">(T l,T r)</span></span>&#123;<span class="comment">//范围[l,r]</span></span><br><span class="line">T mid;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">BSCheck</span>(mid))r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二分-最大值">二分(最大值)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">BSCheck</span><span class="params">(T num)</span></span>&#123;</span><br><span class="line"><span class="comment">//checker自己写 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">BinarySearch</span><span class="params">(T l,T r)</span></span>&#123;<span class="comment">//范围[l,r]</span></span><br><span class="line">r++;</span><br><span class="line">T mid;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">BSCheck</span>(mid))l=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三分-最小值">三分(最小值)</h2><p>三分的板子,由于三分区间比较宽,我们使用eeps来限定误差,超出误差直接手动判定答案.<br><s>为啥要用三分?因为考试考,就让你两个点同时判断,只能三分.</s></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">TriSearch</span><span class="params">(T l,T r)</span></span>&#123;<span class="comment">//[l,r]</span></span><br><span class="line">T ll,rr,res,eeps=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(l+eeps&lt;r)&#123;</span><br><span class="line">ll=((l&lt;&lt;<span class="number">1</span>)+r)/<span class="number">3</span>;</span><br><span class="line">rr=((r&lt;&lt;<span class="number">1</span>)+l)/<span class="number">3</span>;</span><br><span class="line"><span class="comment">//Check</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>()&#123;<span class="comment">//[rr+1,r]</span></span><br><span class="line">l=rr+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>()&#123;<span class="comment">//[ll+1,rr]</span></span><br><span class="line">l=ll+<span class="number">1</span>;</span><br><span class="line">r=rr;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//[l,ll]</span></span><br><span class="line">r=ll;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Check</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line"><span class="keyword">return</span> l+<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>()&#123;</span><br><span class="line"><span class="keyword">return</span> l+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="搜联通块">搜联通块</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">char</span> dat[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (y&lt;<span class="number">0</span>||x&lt;<span class="number">0</span>||y&gt;n||x&gt;m||dat[y][x]==<span class="string">&#x27;.&#x27;</span>)?<span class="number">0</span>:(dat[y][x]=<span class="string">&#x27;.&#x27;</span>,<span class="built_in">dfs</span>(y+<span class="number">1</span>,x)+<span class="built_in">dfs</span>(y<span class="number">-1</span>,x)+<span class="built_in">dfs</span>(y,x+<span class="number">1</span>)+<span class="built_in">dfs</span>(y,x<span class="number">-1</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="并查集-路径压缩">并查集(路径压缩)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dsunoden 1000010</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dsu</span>&#123;</span><br><span class="line"><span class="type">int</span> ko[dsunoden];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dsunoden;++i)&#123;</span><br><span class="line">ko[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">isfa</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> num==ko[num];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ffind</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ko[num]==num?num:ko[num]=<span class="built_in">ffind</span>(ko[num]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uunion</span><span class="params">(<span class="type">int</span> b,<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">ko[b]=<span class="built_in">ffind</span>(a);</span><br><span class="line">&#125;<span class="comment">//b被a合并 </span></span><br><span class="line"><span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> num)&#123;</span><br><span class="line"><span class="keyword">return</span> ko[num];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="树状数组">树状数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fenwick</span>&#123;<span class="comment">//tree line,树状数组 </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ddat[<span class="number">1000010</span>]&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bbuild</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;<span class="comment">//建树 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">ddat[i]+=dat[i];</span><br><span class="line"><span class="type">int</span> j=i+<span class="built_in">lowbit</span>(i);</span><br><span class="line"><span class="keyword">if</span>(j&lt;=n)ddat[j]+=ddat[i];<span class="comment">//向后找爹加和，实现O(n)建树 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aadd</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;pos&lt;=n;pos+=<span class="built_in">lowbit</span>(pos))&#123;</span><br><span class="line">ddat[pos]+=val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qquery</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;<span class="comment">//[1,pos]</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;pos;pos-=<span class="built_in">lowbit</span>(pos))&#123;</span><br><span class="line">res+=ddat[pos];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线段树-lazy-mulazy">线段树(lazy,mulazy)</h2><p>给的还是区间加乘的板子.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> segmenttreemxxn 5000000</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segmenttree</span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segmenttreenode</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> val,lazy,mulazy;</span><br><span class="line">&#125;;</span><br><span class="line">segmenttreenode dat[segmenttreemxxn];</span><br><span class="line"><span class="type">int</span> top=<span class="number">0</span>,p;<span class="comment">//对p取模 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bbuild</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//建空树，返回根节点 </span></span><br><span class="line"><span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line"><span class="built_in">read</span>(dat[++top].val);</span><br><span class="line"><span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,tmp=++top;</span><br><span class="line">dat[tmp].mulazy=<span class="number">1</span>;</span><br><span class="line">dat[tmp].l=<span class="built_in">bbuild</span>(l,mid);</span><br><span class="line">dat[tmp].r=<span class="built_in">bbuild</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">dat[tmp].val=(dat[dat[tmp].l].val+dat[dat[tmp].r].val)%p;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">llazy</span><span class="params">(<span class="type">int</span> mod,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//down stream</span></span><br><span class="line"><span class="keyword">if</span>(dat[mod].mulazy!=<span class="number">1</span>||dat[mod].lazy!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">dat[dat[mod].l].val=(dat[dat[mod].l].val*dat[mod].mulazy%p+dat[mod].lazy*(mid-l+<span class="number">1</span>)%p)%p;</span><br><span class="line">dat[dat[mod].r].val=(dat[dat[mod].r].val*dat[mod].mulazy%p+dat[mod].lazy*(r-mid)%p)%p;</span><br><span class="line">dat[dat[mod].l].lazy=(dat[dat[mod].l].lazy*dat[mod].mulazy%p+dat[mod].lazy)%p;</span><br><span class="line">dat[dat[mod].r].lazy=(dat[dat[mod].r].lazy*dat[mod].mulazy%p+dat[mod].lazy)%p;</span><br><span class="line">dat[dat[mod].l].mulazy=(dat[dat[mod].l].mulazy*dat[mod].mulazy)%p;</span><br><span class="line">dat[dat[mod].r].mulazy=(dat[dat[mod].r].mulazy*dat[mod].mulazy)%p;</span><br><span class="line">dat[mod].mulazy=<span class="number">1</span>;</span><br><span class="line">dat[mod].lazy=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aaddchange</span><span class="params">(<span class="type">int</span> mod,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> tl,<span class="type">int</span> tr,<span class="type">long</span> <span class="type">long</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l&amp;&amp;r&lt;=tr)&#123;</span><br><span class="line">dat[mod].val=(dat[mod].val+val*(r-l+<span class="number">1</span>)%p)%p;</span><br><span class="line">dat[mod].lazy=(dat[mod].lazy+val)%p;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">llazy</span>(mod,l,r);</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid)<span class="built_in">aaddchange</span>(dat[mod].l,l,mid,tl,tr,val);</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid)<span class="built_in">aaddchange</span>(dat[mod].r,mid+<span class="number">1</span>,r,tl,tr,val);</span><br><span class="line">dat[mod].val=(dat[dat[mod].l].val+dat[dat[mod].r].val)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mmulchange</span><span class="params">(<span class="type">int</span> mod,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> tl,<span class="type">int</span> tr,<span class="type">long</span> <span class="type">long</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l&amp;&amp;r&lt;=tr)&#123;</span><br><span class="line">dat[mod].val=(dat[mod].val*val)%p;</span><br><span class="line">dat[mod].mulazy=(dat[mod].mulazy*val)%p;</span><br><span class="line">dat[mod].lazy=(dat[mod].lazy*val)%p;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">llazy</span>(mod,l,r);</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid)<span class="built_in">mmulchange</span>(dat[mod].l,l,mid,tl,tr,val);</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid)<span class="built_in">mmulchange</span>(dat[mod].r,mid+<span class="number">1</span>,r,tl,tr,val);</span><br><span class="line">dat[mod].val=(dat[dat[mod].l].val+dat[dat[mod].r].val)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qquery</span><span class="params">(<span class="type">int</span> mod,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> tl,<span class="type">int</span> tr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l&amp;&amp;r&lt;=tr)<span class="keyword">return</span> dat[mod].val;</span><br><span class="line"><span class="built_in">llazy</span>(mod,l,r);</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid)res=(res+<span class="built_in">qquery</span>(dat[mod].l,l,mid,tl,tr))%p;</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid)res=(res+<span class="built_in">qquery</span>(dat[mod].r,mid+<span class="number">1</span>,r,tl,tr))%p;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线段树-lazy">线段树(lazy)</h2><p>给的是维护区间加和和lazytag的板子.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> segmenttreemxxn 2000000</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segmenttree</span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segmenttreenode</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> val,lazy;</span><br><span class="line">&#125;;</span><br><span class="line">segmenttreenode dat[segmenttreemxxn];</span><br><span class="line"><span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bbuild</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//建空树，返回根节点 </span></span><br><span class="line"><span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line"><span class="built_in">read</span>(dat[++top].val);</span><br><span class="line"><span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,tmp=++top;</span><br><span class="line">dat[tmp].l=<span class="built_in">bbuild</span>(l,mid);</span><br><span class="line">dat[tmp].r=<span class="built_in">bbuild</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">dat[tmp].val=dat[dat[tmp].l].val+dat[dat[tmp].r].val;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">llazy</span><span class="params">(<span class="type">int</span> mod,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//down stream</span></span><br><span class="line"><span class="keyword">if</span>(dat[mod].lazy!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">dat[dat[mod].l].val+=dat[mod].lazy*(mid-l+<span class="number">1</span>);</span><br><span class="line">dat[dat[mod].r].val+=dat[mod].lazy*(r-mid);</span><br><span class="line">dat[dat[mod].l].lazy+=dat[mod].lazy;</span><br><span class="line">dat[dat[mod].r].lazy+=dat[mod].lazy;</span><br><span class="line">dat[mod].lazy=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aaddchange</span><span class="params">(<span class="type">int</span> mod,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> tl,<span class="type">int</span> tr,<span class="type">long</span> <span class="type">long</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l&amp;&amp;r&lt;=tr)&#123;</span><br><span class="line">dat[mod].val=dat[mod].val+val*(r-l+<span class="number">1</span>);</span><br><span class="line">dat[mod].lazy=dat[mod].lazy+val;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">llazy</span>(mod,l,r);</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid)<span class="built_in">aaddchange</span>(dat[mod].l,l,mid,tl,tr,val);</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid)<span class="built_in">aaddchange</span>(dat[mod].r,mid+<span class="number">1</span>,r,tl,tr,val);</span><br><span class="line">dat[mod].val=dat[dat[mod].l].val+dat[dat[mod].r].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aaddchange</span><span class="params">(<span class="type">int</span> mod,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,<span class="type">long</span> <span class="type">long</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">dat[mod].val+=val;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">llazy</span>(mod,l,r);</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">aaddchange</span>(dat[mod].l,l,mid,pos,val);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">aaddchange</span>(dat[mod].r,mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line">dat[mod].val=dat[dat[mod].l].val+dat[dat[mod].r].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qquery</span><span class="params">(<span class="type">int</span> mod,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> tl,<span class="type">int</span> tr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l&amp;&amp;r&lt;=tr)<span class="keyword">return</span> dat[mod].val;</span><br><span class="line"><span class="built_in">llazy</span>(mod,l,r);</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid)res+=<span class="built_in">qquery</span>(dat[mod].l,l,mid,tl,tr);</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid)res+=<span class="built_in">qquery</span>(dat[mod].r,mid+<span class="number">1</span>,r,tl,tr);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线段树-权值">线段树(权值)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> segmenttreemxxn 600000</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segmenttree</span>&#123;<span class="comment">//这个是权值线段树,由于区间加和,假如要求严格小于的有多少个就-1+1来弥补. </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segmenttreenode</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r,val;</span><br><span class="line">&#125;;</span><br><span class="line">segmenttreenode dat[segmenttreemxxn];</span><br><span class="line"><span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bbuild</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//建空树，返回根节点 </span></span><br><span class="line"><span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span> ++top;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,tmp=++top;</span><br><span class="line">dat[tmp].l=<span class="built_in">bbuild</span>(l,mid);</span><br><span class="line">dat[tmp].r=<span class="built_in">bbuild</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aadd</span><span class="params">(<span class="type">int</span> mod,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,<span class="type">int</span> val)</span></span>&#123;<span class="comment">//某点加多少 </span></span><br><span class="line"><span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">dat[mod].val+=val;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">dat[mod].val+=val;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">aadd</span>(dat[mod].l,l,mid,pos,val);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">aadd</span>(dat[mod].r,mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qqquery</span><span class="params">(<span class="type">int</span> mod,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span>&#123;<span class="comment">//查询pos单点 </span></span><br><span class="line"><span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span> dat[mod].val;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=mid)<span class="keyword">return</span> <span class="built_in">qqquery</span>(dat[mod].l,l,mid,pos);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">qqquery</span>(dat[mod].r,mid+<span class="number">1</span>,r,pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qquery</span><span class="params">(<span class="type">int</span> mod,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span>&#123;<span class="comment">//查询[1,pos]的和 </span></span><br><span class="line"><span class="keyword">if</span>(r&lt;=pos)<span class="keyword">return</span> dat[mod].val;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid&lt;pos)<span class="keyword">return</span> dat[dat[mod].l].val+<span class="built_in">qquery</span>(dat[mod].r,mid+<span class="number">1</span>,r,pos);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">qquery</span>(dat[mod].l,l,mid,pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">deqquery</span><span class="params">(<span class="type">int</span> mod,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos)</span></span>&#123;<span class="comment">//查询[pos,r]的和 </span></span><br><span class="line"><span class="keyword">if</span>(pos&lt;=l)<span class="keyword">return</span> dat[mod].val;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid&gt;=pos)<span class="keyword">return</span> dat[dat[mod].r].val+<span class="built_in">deqquery</span>(dat[mod].l,l,mid,pos);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">deqquery</span>(dat[mod].r,mid+<span class="number">1</span>,r,pos);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="主席树-可持久化线段树-UUU">主席树(可持久化线段树)UUU</h2><h2 id="树链剖分-重链剖分">树链剖分(重链剖分)</h2><p>这里放的是一个能单点修改,查询区间max和区间和的板子.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">heavyChainSegmentation</span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">nnode</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r,val,mxx;</span><br><span class="line">&#125;;</span><br><span class="line">nnode dat[<span class="number">600000</span>];</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;edge;</span><br><span class="line"><span class="type">int</span> sz,cnt,n,ttop,*fa,*dep,*siz,*son,*top,*dfn,*rnk,*ddat;</span><br><span class="line"><span class="built_in">heavyChainSegmentation</span>(<span class="type">int</span> nn=<span class="number">100010</span>):<span class="built_in">sz</span>(nn),<span class="built_in">n</span>(<span class="number">0</span>),<span class="built_in">cnt</span>(<span class="number">0</span>),<span class="built_in">ttop</span>(<span class="number">0</span>)&#123;</span><br><span class="line">edge.<span class="built_in">resize</span>(sz);</span><br><span class="line">fa=<span class="keyword">new</span> <span class="type">int</span>[sz]&#123;&#125;;</span><br><span class="line">dep=<span class="keyword">new</span> <span class="type">int</span>[sz]&#123;&#125;;</span><br><span class="line">siz=<span class="keyword">new</span> <span class="type">int</span>[sz]&#123;&#125;;</span><br><span class="line">son=<span class="keyword">new</span> <span class="type">int</span>[sz]&#123;&#125;;</span><br><span class="line">top=<span class="keyword">new</span> <span class="type">int</span>[sz]&#123;&#125;;</span><br><span class="line">dfn=<span class="keyword">new</span> <span class="type">int</span>[sz]&#123;&#125;;</span><br><span class="line">rnk=<span class="keyword">new</span> <span class="type">int</span>[sz]&#123;&#125;;</span><br><span class="line">ddat=<span class="keyword">new</span> <span class="type">int</span>[sz];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adddir</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">edge[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adddedir</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">edge[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">edge[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">son[num]=<span class="number">-1</span>;</span><br><span class="line">siz[num]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:edge[num])&#123;</span><br><span class="line"><span class="comment">// fout&lt;&lt;i&lt;&lt;&quot;!&quot;;</span></span><br><span class="line"><span class="keyword">if</span>(dep[i]==<span class="number">0</span>)&#123;</span><br><span class="line">dep[i]=dep[num]+<span class="number">1</span>;</span><br><span class="line">fa[i]=num;</span><br><span class="line"><span class="built_in">dfs1</span>(i);</span><br><span class="line">siz[num]+=siz[i];</span><br><span class="line"><span class="keyword">if</span>(son[num]==<span class="number">-1</span>||siz[i]&gt;siz[son[num]])&#123;</span><br><span class="line">son[num]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> ko)</span></span>&#123;<span class="comment">/*当前节点,当前重链顶*/</span></span><br><span class="line">top[num]=ko;</span><br><span class="line">dfn[num]=++cnt;</span><br><span class="line">rnk[cnt]=num;</span><br><span class="line"><span class="keyword">if</span>(son[num]==<span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(son[num],ko);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:edge[num])&#123;</span><br><span class="line"><span class="keyword">if</span>(i!=son[num]&amp;&amp;i!=fa[num])&#123;</span><br><span class="line"><span class="built_in">dfs2</span>(i,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">dat[num].val=dat[dat[num].l].val+dat[dat[num].r].val;</span><br><span class="line">dat[num].mxx=<span class="built_in">max</span>(dat[dat[num].l].mxx,dat[dat[num].r].mxx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bbuild</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">++ttop;</span><br><span class="line">dat[ttop].val=dat[ttop].mxx=ddat[rnk[l]];</span><br><span class="line"><span class="keyword">return</span> ttop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,tmp=++ttop;</span><br><span class="line">dat[tmp].l=<span class="built_in">bbuild</span>(l,mid);</span><br><span class="line">dat[tmp].r=<span class="built_in">bbuild</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">push_up</span>(tmp);</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aadd</span><span class="params">(<span class="type">int</span> mod,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> pos,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">dat[mod].val=val;</span><br><span class="line">dat[mod].mxx=val;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">aadd</span>(dat[mod].l,l,mid,pos,val);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">aadd</span>(dat[mod].r,mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line"><span class="built_in">push_up</span>(mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">querymax</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> dat[num].mxx;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,mxx=<span class="number">-1145141919</span>;</span><br><span class="line"><span class="keyword">if</span>(ql&lt;=mid)mxx=<span class="built_in">max</span>(mxx,<span class="built_in">querymax</span>(dat[num].l,l,mid,ql,qr));</span><br><span class="line"><span class="keyword">if</span>(qr&gt;mid)mxx=<span class="built_in">max</span>(mxx,<span class="built_in">querymax</span>(dat[num].r,mid+<span class="number">1</span>,r,ql,qr));</span><br><span class="line"><span class="keyword">return</span> mxx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">querysum</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="keyword">return</span> dat[num].val;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(ql&lt;=mid)res+=<span class="built_in">querysum</span>(dat[num].l,l,mid,ql,qr);</span><br><span class="line"><span class="keyword">if</span>(qr&gt;mid)res+=<span class="built_in">querysum</span>(dat[num].r,mid+<span class="number">1</span>,r,ql,qr);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">(<span class="type">int</span> nn,<span class="type">int</span> root=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">n=nn;</span><br><span class="line">dep[root]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(root);</span><br><span class="line"><span class="built_in">dfs2</span>(root,root);</span><br><span class="line"><span class="built_in">bbuild</span>(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qquerymax</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">-1145141919</span>,fx=top[x],fy=top[y];</span><br><span class="line"><span class="keyword">while</span>(fx!=fy)&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[fx]&gt;=dep[fy])&#123;</span><br><span class="line">res=<span class="built_in">max</span>(res,<span class="built_in">querymax</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[fx],dfn[x]));</span><br><span class="line">x=fa[fx];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">res=<span class="built_in">max</span>(res,<span class="built_in">querymax</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[fy],dfn[y]));</span><br><span class="line">y=fa[fy];</span><br><span class="line">&#125;</span><br><span class="line">fx=top[x];</span><br><span class="line">fy=top[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x]&lt;dfn[y])</span><br><span class="line">res=<span class="built_in">max</span>(res,<span class="built_in">querymax</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[y]));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">res=<span class="built_in">max</span>(res,<span class="built_in">querymax</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[y],dfn[x]));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qquerysum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>,fx=top[x],fy=top[y];</span><br><span class="line"><span class="keyword">while</span>(fx!=fy)&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[fx]&gt;=dep[fy])&#123;</span><br><span class="line">res+=<span class="built_in">querysum</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[fx],dfn[x]);</span><br><span class="line">x=fa[fx];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">res+=<span class="built_in">querysum</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[fy],dfn[y]);</span><br><span class="line">y=fa[fy];</span><br><span class="line">&#125;</span><br><span class="line">fx=top[x];</span><br><span class="line">fy=top[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[x]&lt;dfn[y])</span><br><span class="line">res+=<span class="built_in">querysum</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[y]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">res+=<span class="built_in">querysum</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[y],dfn[x]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="平衡树-有旋treap">平衡树(有旋treap)</h2><p>有旋treap.<br>定义排名是比他小的数+1,逆排名是比他大的数+1.</p><p>查找排名可能不存在,此时先插一个元素再查排名再删即可.</p><p>getval查询排名为x的数(使用前请保证存在).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">treap</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">phtnode</span>&#123;</span><br><span class="line">phtnode* p[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> val,rank,cnt,size;</span><br><span class="line"><span class="built_in">phtnode</span>(<span class="type">int</span> vval):<span class="built_in">val</span>(vval),<span class="built_in">cnt</span>(<span class="number">1</span>),<span class="built_in">size</span>(<span class="number">1</span>)&#123;</span><br><span class="line">p[<span class="number">0</span>]=p[<span class="number">1</span>]=<span class="literal">nullptr</span>;</span><br><span class="line">rank=<span class="built_in">rand</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updsize</span><span class="params">()</span></span>&#123;</span><br><span class="line">size=cnt;</span><br><span class="line"><span class="keyword">if</span>(p[<span class="number">0</span>]!=<span class="literal">nullptr</span>)size+=p[<span class="number">0</span>]-&gt;size;</span><br><span class="line"><span class="keyword">if</span>(p[<span class="number">1</span>]!=<span class="literal">nullptr</span>)size+=p[<span class="number">1</span>]-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">rtype</span>&#123;</span><br><span class="line">L=<span class="number">1</span>,R=<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">phtnode* root;</span><br><span class="line"><span class="type">int</span> ttmp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(phtnode*&amp; num,rtype dir)</span></span>&#123;</span><br><span class="line">phtnode* tmp=num-&gt;p[dir];</span><br><span class="line">num-&gt;p[dir]=tmp-&gt;p[!dir];</span><br><span class="line">tmp-&gt;p[!dir]=num;</span><br><span class="line">num-&gt;<span class="built_in">updsize</span>();tmp-&gt;<span class="built_in">updsize</span>();</span><br><span class="line">num=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _insert(phtnode*&amp; num,<span class="type">int</span> val)&#123;</span><br><span class="line"><span class="keyword">if</span>(num==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">num=<span class="keyword">new</span> <span class="built_in">phtnode</span>(val);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(val==num-&gt;val)&#123;</span><br><span class="line">num-&gt;size++;</span><br><span class="line">num-&gt;cnt++;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(val&lt;num-&gt;val)&#123;</span><br><span class="line">_insert(num-&gt;p[<span class="number">0</span>],val);</span><br><span class="line"><span class="keyword">if</span>(num-&gt;p[<span class="number">0</span>]-&gt;rank&lt;num-&gt;rank)&#123;</span><br><span class="line"><span class="built_in">rotate</span>(num,R);</span><br><span class="line">&#125;</span><br><span class="line">num-&gt;<span class="built_in">updsize</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">_insert(num-&gt;p[<span class="number">1</span>],val);</span><br><span class="line"><span class="keyword">if</span>(num-&gt;p[<span class="number">1</span>]-&gt;rank&lt;num-&gt;rank)&#123;</span><br><span class="line"><span class="built_in">rotate</span>(num,L);</span><br><span class="line">&#125;</span><br><span class="line">num-&gt;<span class="built_in">updsize</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _del(phtnode*&amp; num,<span class="type">int</span> val)&#123;</span><br><span class="line"><span class="keyword">if</span>(val&gt;num-&gt;val)&#123;</span><br><span class="line">_del(num-&gt;p[<span class="number">1</span>],val);</span><br><span class="line">num-&gt;<span class="built_in">updsize</span>();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(val&lt;num-&gt;val)&#123;</span><br><span class="line">_del(num-&gt;p[<span class="number">0</span>],val);</span><br><span class="line">num-&gt;<span class="built_in">updsize</span>();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num-&gt;cnt&gt;<span class="number">1</span>)&#123;</span><br><span class="line">num-&gt;cnt--;</span><br><span class="line">num-&gt;size--;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">char</span> now=<span class="number">0</span>;</span><br><span class="line">now|=(num-&gt;p[<span class="number">0</span>]!=<span class="literal">nullptr</span>);</span><br><span class="line">now|=((num-&gt;p[<span class="number">1</span>]!=<span class="literal">nullptr</span>)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">phtnode* tmp=num;</span><br><span class="line"><span class="keyword">switch</span>(now)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line"><span class="keyword">delete</span> num;</span><br><span class="line">num=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">num=tmp-&gt;p[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">num=tmp-&gt;p[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">rtype dir=(num-&gt;p[<span class="number">0</span>]-&gt;rank&lt;num-&gt;p[<span class="number">1</span>]-&gt;rank)?R:L;</span><br><span class="line"><span class="built_in">rotate</span>(num,dir);</span><br><span class="line">_del(num-&gt;p[!dir],val);</span><br><span class="line">num-&gt;<span class="built_in">updsize</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _getrank(phtnode* num,<span class="type">int</span> val)&#123;</span><br><span class="line"><span class="type">int</span> res=(num-&gt;p[<span class="number">0</span>]==<span class="literal">nullptr</span>)?<span class="number">0</span>:num-&gt;p[<span class="number">0</span>]-&gt;size;</span><br><span class="line"><span class="keyword">if</span>(val==num-&gt;val)&#123;</span><br><span class="line"><span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(val&lt;num-&gt;val)&#123;</span><br><span class="line"><span class="keyword">if</span>(num-&gt;p[<span class="number">0</span>]!=<span class="literal">nullptr</span>)<span class="keyword">return</span> _getrank(num-&gt;p[<span class="number">0</span>],val);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num-&gt;p[<span class="number">1</span>]!=<span class="literal">nullptr</span>)<span class="keyword">return</span> res+num-&gt;cnt+_getrank(num-&gt;p[<span class="number">1</span>],val);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> num-&gt;size+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _getderank(phtnode* num,<span class="type">int</span> val)&#123;</span><br><span class="line"><span class="type">int</span> res=(num-&gt;p[<span class="number">1</span>]==<span class="literal">nullptr</span>)?<span class="number">0</span>:num-&gt;p[<span class="number">1</span>]-&gt;size;</span><br><span class="line"><span class="keyword">if</span>(val==num-&gt;val)&#123;</span><br><span class="line"><span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(val&gt;num-&gt;val)&#123;</span><br><span class="line"><span class="keyword">if</span>(num-&gt;p[<span class="number">1</span>]!=<span class="literal">nullptr</span>)<span class="keyword">return</span> _getderank(num-&gt;p[<span class="number">1</span>],val);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num-&gt;p[<span class="number">0</span>]!=<span class="literal">nullptr</span>)<span class="keyword">return</span> res+num-&gt;cnt+_getderank(num-&gt;p[<span class="number">0</span>],val);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> num-&gt;size+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _getval(phtnode* num,<span class="type">int</span> rank)&#123;</span><br><span class="line"><span class="type">int</span> lesssize=(num-&gt;p[<span class="number">0</span>]==<span class="literal">nullptr</span>)?<span class="number">0</span>:num-&gt;p[<span class="number">0</span>]-&gt;size;</span><br><span class="line"><span class="keyword">if</span>(rank&lt;=lesssize)<span class="keyword">return</span> _getval(num-&gt;p[<span class="number">0</span>],rank);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(rank&lt;=lesssize+num-&gt;cnt)<span class="keyword">return</span> num-&gt;val;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> _getval(num-&gt;p[<span class="number">1</span>],rank-lesssize-num-&gt;cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _getprevious(phtnode* num,<span class="type">int</span> val)&#123;</span><br><span class="line"><span class="keyword">if</span>(val&lt;=num-&gt;val)&#123;</span><br><span class="line"><span class="keyword">if</span>(num-&gt;p[<span class="number">0</span>]!=<span class="literal">nullptr</span>)<span class="keyword">return</span> _getprevious(num-&gt;p[<span class="number">0</span>],val);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">ttmp=num-&gt;val;</span><br><span class="line"><span class="keyword">if</span>(num-&gt;p[<span class="number">1</span>]!=<span class="literal">nullptr</span>)_getprevious(num-&gt;p[<span class="number">1</span>],val);</span><br><span class="line"><span class="keyword">return</span> ttmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _getnext(phtnode* num,<span class="type">int</span> val)&#123;</span><br><span class="line"><span class="keyword">if</span>(val&gt;=num-&gt;val)&#123;</span><br><span class="line"><span class="keyword">if</span>(num-&gt;p[<span class="number">1</span>]!=<span class="literal">nullptr</span>)<span class="keyword">return</span> _getnext(num-&gt;p[<span class="number">1</span>],val);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">ttmp=num-&gt;val;</span><br><span class="line"><span class="keyword">if</span>(num-&gt;p[<span class="number">0</span>]!=<span class="literal">nullptr</span>)_getnext(num-&gt;p[<span class="number">0</span>],val);</span><br><span class="line"><span class="keyword">return</span> ttmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">treap</span>()&#123;<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));root=<span class="literal">nullptr</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;_insert(root,val);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;_del(root,val);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getrank</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;<span class="keyword">return</span> _getrank(root,val);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getderank</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;<span class="keyword">return</span> _getderank(root,val);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getprevious</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;<span class="keyword">return</span> _getprevious(root,val);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getnext</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;<span class="keyword">return</span> _getnext(root,val);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getval</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;<span class="keyword">return</span> _getval(root,val);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串匹配-KMP">字符串匹配 KMP</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getnextt</span><span class="params">(<span class="type">char</span>* b,<span class="type">int</span>* nextt,<span class="type">int</span> lb)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;lb;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(b[j]==b[i])&#123;</span><br><span class="line">nextt[i]=++j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">nextt[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">j=nextt[j<span class="number">-1</span>];</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kmp</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;* res,<span class="type">char</span>* a,<span class="type">char</span>* b,<span class="type">int</span> la,<span class="type">int</span> lb,<span class="type">int</span>* nextt)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> p=<span class="number">0</span>,q=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p&lt;la)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[p]==b[q])&#123;</span><br><span class="line">p++,q++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(q)&#123;</span><br><span class="line">q=nextt[q<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> p++;</span><br><span class="line"><span class="keyword">if</span>(q==lb)&#123;</span><br><span class="line">res-&gt;<span class="built_in">push_back</span>(p-q+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串哈希UUU">字符串哈希UUU</h2><p>下面给了三个板子.分别是自然溢出哈希,单哈希以及双哈希.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//base: 101 103 131 233</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">strhashe64</span><span class="params">(<span class="type">char</span>* dat,<span class="type">int</span> n,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> base=<span class="number">131</span>)</span></span>&#123;</span><br><span class="line"><span class="type">uint64_t</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">res=res*base+dat[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res&amp;<span class="number">0x7fffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hash:1e16+61</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">strhashmod1</span><span class="params">(<span class="type">char</span>* dat,<span class="type">int</span> n,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> base=<span class="number">131</span>,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> mod=<span class="number">10000000000000061</span>)</span></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">res=(res*base+dat[i])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::pair&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">strhashmod2</span><span class="params">(<span class="type">char</span>* dat,<span class="type">int</span> n,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> base=<span class="number">131</span>,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> mod1=<span class="number">10000000000000061</span>,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> mod2=<span class="number">100000000000031</span>)</span></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> res1=<span class="number">0</span>,res2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">res1=(res1*base+dat[i])%mod1;</span><br><span class="line">res2=(res2*base+dat[i])%mod2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;res1,res2&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>图论</h1><h2 id="加边-最短路-Dijkstra">加边 最短路(Dijkstra)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">graph</span>&#123;</span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="type">int</span>,T&gt; &gt; &gt;edge;</span><br><span class="line">vector&lt;vector&lt;T&gt; &gt;dis;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">graph</span>(<span class="type">int</span> num=<span class="number">200000</span>):<span class="built_in">n</span>(num)&#123;</span><br><span class="line">edge.<span class="built_in">resize</span>(num+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">graph</span>()&#123;</span><br><span class="line"><span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">edge[i].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adddir</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,T val)</span></span>&#123;</span><br><span class="line">edge[u].<span class="built_in">push_back</span>(&#123;v,val&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adddedir</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,T val)</span></span>&#123;</span><br><span class="line">edge[u].<span class="built_in">push_back</span>(&#123;v,val&#125;);</span><br><span class="line">edge[v].<span class="built_in">push_back</span>(&#123;u,val&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(T* dis,<span class="type">int</span> first,<span class="type">int</span> n)</span></span>&#123;<span class="comment">//对哪个点遍历，多少个点 </span></span><br><span class="line">dis.<span class="built_in">resize</span>(n+<span class="number">5</span>);</span><br><span class="line"><span class="built_in">fill</span>(dis,dis+<span class="number">1</span>+n,<span class="number">2147483647</span>);</span><br><span class="line">priority_queue&lt;pair&lt;T,<span class="type">int</span>&gt;,vector&lt;pair&lt;T,<span class="type">int</span>&gt; &gt;,greater&lt;pair&lt;T,<span class="type">int</span>&gt; &gt; &gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,first&#125;);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">pair&lt;T,<span class="type">int</span>&gt;qq=q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(qq.first&gt;dis[qq.second])<span class="keyword">continue</span>;</span><br><span class="line">dis[qq.second]=qq.first;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:edge[qq.second])&#123;</span><br><span class="line"><span class="keyword">if</span>((qq.first+i.second)&lt;dis[i.first])&#123;</span><br><span class="line">dis[i.first]=qq.first+i.second;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;qq.first+i.second,i.first&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用法: graph&lt;int&gt; ko(114514)</span></span><br><span class="line"><span class="comment">// 存储边权  多少个点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>无权边也来一个.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">graph</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> n,tmp;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;edge;</span><br><span class="line"><span class="built_in">graph</span>(<span class="type">int</span> num=<span class="number">200000</span>):<span class="built_in">n</span>(num)&#123;</span><br><span class="line">edge.<span class="built_in">resize</span>(num+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">graph</span>()&#123;</span><br><span class="line"><span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">edge[i].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adddir</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">edge[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adddedir</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">edge[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">edge[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;d;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ddfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v:edge[u])&#123;</span><br><span class="line"><span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(d[v]&gt;d[tmp])tmp=v;</span><br><span class="line"><span class="built_in">ddfs</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getd</span><span class="params">()</span></span>&#123;</span><br><span class="line">tmp=<span class="number">-1145141919</span>;</span><br><span class="line">d.<span class="built_in">resize</span>(n+<span class="number">5</span>);</span><br><span class="line"><span class="built_in">ddfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">d[tmp]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">ddfs</span>(tmp,<span class="number">0</span>);</span><br><span class="line">tmp=d[tmp];</span><br><span class="line">d.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dpfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v:edge[u])&#123;</span><br><span class="line"><span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dpfs</span>(v,u);</span><br><span class="line">tmp=<span class="built_in">max</span>(tmp,d[u]+d[v]+<span class="number">1</span>);</span><br><span class="line">d[u]=<span class="built_in">max</span>(d[u],d[v]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getdpd</span><span class="params">(<span class="type">int</span> root=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">tmp=<span class="number">-1145141919</span>;</span><br><span class="line">d.<span class="built_in">resize</span>(n+<span class="number">5</span>);</span><br><span class="line"><span class="built_in">dpfs</span>(root,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="传递闭包">传递闭包</h2><p>给一张邻接矩阵,计算任意两点是否能够到达,a[i][j]表示这两个点能不能到达.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bitset&lt;110&gt;dat[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transitiveClosure</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(dat[i][j])&#123;</span><br><span class="line">dat[i]|=dat[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>数学</h1><h2 id="快速幂-龟速乘-qp-qmul-快速乘">快速幂,龟速乘(qp,qmul),快速乘</h2><p>ps:如果希望求负几次方直接反转成 $1/x$ 然后直接反转n即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,<span class="keyword">typename</span> T3&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">qp</span><span class="params">(T1 b,T2 po,T3 p)</span></span>&#123;</span><br><span class="line">T1 res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(po&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(po&amp;<span class="number">1</span>)</span><br><span class="line">res=res*b%p;</span><br><span class="line">b=b*b%p;</span><br><span class="line">po&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">qmul</span><span class="params">(T a,T b,T p)</span></span>&#123;<span class="comment">//a*b对p取模,由于没有int128所以要用快速幂思想解这个问题 </span></span><br><span class="line">T res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=(res+a)%p;</span><br><span class="line">a=(a&lt;&lt;<span class="number">1</span>)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qmul</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> p)</span></span>&#123;<span class="comment">//a*b对p取模 </span></span><br><span class="line">a%=p;b%=p;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c=(<span class="type">long</span> <span class="type">double</span>)a*b/p;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res=a*b-c*p;</span><br><span class="line"><span class="keyword">if</span>(res&lt;<span class="number">0</span>)res+=p;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(res&gt;=p)res-=p;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="离散化">离散化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(dat+<span class="number">1</span>,dat+<span class="number">1</span>+n);</span><br><span class="line">m=<span class="built_in">unique</span>(dat+<span class="number">1</span>,dat+<span class="number">1</span>+n)-dat<span class="number">-1</span>;</span><br><span class="line"><span class="comment">//m是实际不重合元素个数.</span></span><br><span class="line"><span class="comment">//tmp是每个元素离散化之后的值(排名).</span></span><br><span class="line">tmp=<span class="built_in">upper_bound</span>(dat+<span class="number">1</span>,dat+<span class="number">1</span>+m,val)-dat<span class="number">-1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="组合数-杨辉三角">组合数(杨辉三角)</h2><p>说在前面,Flu的排列组合大的n永远放在前面,这是约定.</p><p>解决模数不是质数的组合数求解情况(没逆元).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> yh[<span class="number">114</span>][<span class="number">114</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;++i)&#123;</span><br><span class="line">yh[i][<span class="number">1</span>]=yh[i][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;i;++j)&#123;</span><br><span class="line">yh[i][j]=(yh[i<span class="number">-1</span>][j]+yh[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> yh[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="排列组合数-预处理阶乘">排列组合数(预处理阶乘)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> fac[<span class="number">200010</span>],defac[<span class="number">200010</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,<span class="keyword">typename</span> T3&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">qp</span><span class="params">(T1 b,T2 po,T3 p)</span></span>&#123;</span><br><span class="line">T1 res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(po&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(po&amp;<span class="number">1</span>)</span><br><span class="line">res=res*b%p;</span><br><span class="line">b=b*b%p;</span><br><span class="line">po&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">fac[<span class="number">0</span>]=defac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">fac[<span class="number">1</span>]=defac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">fac[i]=(i*fac[i<span class="number">-1</span>])%mod;</span><br><span class="line">defac[i]=<span class="built_in">qp</span>(fac[i],mod<span class="number">-2</span>,mod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(m&lt;<span class="number">0</span>||m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fac[n]*defac[m]%mod*defac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">A</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(m&lt;<span class="number">0</span>||m&gt;n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fac[n]*defac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="排列组合数-直接计算">排列组合数(直接计算)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">A</span><span class="params">(T n,T m,T p)</span></span>&#123;</span><br><span class="line">T  res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(T i=n-m+<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">res=res*i%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">C</span><span class="params">(T n,T m,T p)</span></span>&#123;</span><br><span class="line">m=<span class="built_in">min</span>(m,n-m);</span><br><span class="line">T res=<span class="number">1</span>,udd=<span class="number">1</span>,tmp=n-m,x,y;</span><br><span class="line"><span class="keyword">for</span>(T i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">res=res*(i+tmp)%p;</span><br><span class="line">udd=udd*i%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exgcd</span>(udd,p,x,y);</span><br><span class="line">x=(x%p+p)%p;<span class="comment">//x是逆元</span></span><br><span class="line"><span class="keyword">return</span> res*x%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="最大公约数-最小公倍数-GCD-LCM">最大公约数,最小公倍数(GCD,LCM)</h2><p>最快的版本.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">stein</span><span class="params">(T x,T y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">T a=y-x;</span><br><span class="line">T b=x-y;</span><br><span class="line"><span class="type">int</span> n=__builtin_ctzll(b);</span><br><span class="line">T s=(x&lt;y?a:b);</span><br><span class="line">T t=(x&lt;y?x:y);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">stein</span>(s&gt;&gt;n,t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">gcd</span><span class="params">(T x,T y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span> y;</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>)<span class="keyword">return</span> x;</span><br><span class="line"><span class="type">int</span> n=__builtin_ctzll(x);</span><br><span class="line"><span class="type">int</span> m=__builtin_ctzll(y);</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">stein</span>(x&gt;&gt;n,y&gt;&gt;m)&lt;&lt;(n&lt;m?n:m));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">lcm</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a/<span class="built_in">gcd</span>(a,b)*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最好记最好写的版本.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">gcd</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;<span class="comment">//欧几里得算法 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下是高精适用的版本,只需要支持判定是不是奇数以及除2的操作和减法即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//优化的更相减损术 </span></span><br><span class="line"><span class="function">T <span class="title">gcd</span><span class="params">(T a,T b)</span></span>&#123;<span class="comment">//a&gt;=b guarantee</span></span><br><span class="line"><span class="keyword">if</span>(a==b)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">if</span>(a&amp;<span class="number">1</span>)&#123;<span class="comment">//a ji</span></span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;<span class="comment">//b ji</span></span><br><span class="line">T tmp=a-b;</span><br><span class="line"><span class="keyword">return</span> tmp&gt;b?<span class="built_in">gcd</span>(tmp,b):<span class="built_in">gcd</span>(b,tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">gcd</span>(a,b&gt;&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;<span class="comment">//b ji</span></span><br><span class="line">T tmp=a&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> tmp&gt;b?<span class="built_in">gcd</span>(tmp,b):<span class="built_in">gcd</span>(b,tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">gcd</span>(a&gt;&gt;<span class="number">1</span>,b&gt;&gt;<span class="number">1</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="拓展欧几里得算法-EXGCD">拓展欧几里得算法(EXGCD)</h2><p>常用的迭代版本.(求逆元只要求两数互质就行了,不然逆元不存在也就求不了了,qp求逆元要求mod是质数)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">exgcd</span><span class="params">(T a,T b,T &amp;x,T &amp;y)</span></span>&#123;<span class="comment">//返回值是gcd </span></span><br><span class="line">T x1=<span class="number">1</span>,x2=<span class="number">0</span>,x3=<span class="number">0</span>,x4=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">T c=a/b;</span><br><span class="line"><span class="built_in">tie</span>(x1,x2,x3,x4,a,b)=<span class="built_in">make_tuple</span>(x3,x4,x1-x3*c,x2-x4*c,b,a-b*c);</span><br><span class="line">&#125;</span><br><span class="line">x=x1,y=x2;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很好记的版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(T a,T b,T &amp;x,T &amp;y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b)<span class="built_in">exgcd</span>(b,a%b,y,x),y-=a/b*x;</span><br><span class="line"><span class="keyword">else</span> x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Lucas-卢卡斯定理">Lucas(卢卡斯定理)</h2><p>$$\binom{n}{m}\mod p=\binom{\lfloor n/p\rfloor}{\lfloor m/p\rfloor}\binom{n\mod p}{m\mod p}\mod p$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">lucas</span><span class="params">(T n,T m,T p)</span></span>&#123;<span class="comment">//p must be a prime</span></span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">C</span>(n%p,m%p,p)*<span class="built_in">lucas</span>(n/p,m/p,p)%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数论分块">数论分块</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> l=<span class="number">1</span>;r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">r=n/(n/l);</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> l=<span class="number">1</span>;r;l&lt;=<span class="built_in">min</span>(n,m);l=r+<span class="number">1</span>)&#123;</span><br><span class="line">r=<span class="built_in">min</span>(n/(n/l),m/(m/l));</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="欧拉筛">欧拉筛</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span>   vis[<span class="number">1000010</span>];<span class="comment">//存最小质因数,负的表示质数表中的位置(负的)</span></span><br><span class="line"><span class="type">int</span>  prime[<span class="number">100010</span>],primetop=<span class="number">0</span>;<span class="comment">//存质数 </span></span><br><span class="line"><span class="type">short</span>  mu[<span class="number">1000010</span>];<span class="comment">//莫比乌斯函数 </span></span><br><span class="line"><span class="type">int</span>  musu[<span class="number">1000010</span>];<span class="comment">//梅滕斯函数，莫比乌斯前缀和 </span></span><br><span class="line"><span class="type">int</span>   phi[<span class="number">1000010</span>];<span class="comment">//欧拉函数 </span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> phisu[<span class="number">1000010</span>];<span class="comment">//欧拉函数前缀和 </span></span><br><span class="line"><span class="type">int</span>     d[<span class="number">1000010</span>];<span class="comment">//存每个数的约数个数 </span></span><br><span class="line"><span class="type">int</span> mnnum[<span class="number">1000010</span>];<span class="comment">//最小质因子出现次数 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;<span class="comment">//[1,n]</span></span><br><span class="line">phi[<span class="number">1</span>]=<span class="number">1</span>;phisu[<span class="number">1</span>]=<span class="number">1</span>;mu[<span class="number">1</span>]=<span class="number">1</span>;musu[<span class="number">1</span>]=<span class="number">1</span>;d[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">register</span> <span class="type">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">vis[i]=-primetop;</span><br><span class="line">prime[++primetop]=i;</span><br><span class="line">mu[i]=<span class="number">-1</span>;<span class="comment">//</span></span><br><span class="line">phi[i]=i<span class="number">-1</span>;<span class="comment">//</span></span><br><span class="line">d[i]=<span class="number">2</span>;<span class="comment">//</span></span><br><span class="line">mnnum[i]=<span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=primetop&amp;&amp;i*prime[j]&lt;=n;++j)&#123;</span><br><span class="line">vis[i*prime[j]]=prime[j];</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)&#123;</span><br><span class="line">phi[i*prime[j]]=phi[i]*prime[j];<span class="comment">//</span></span><br><span class="line">mnnum[i*prime[j]]=mnnum[i]+<span class="number">1</span>;<span class="comment">//</span></span><br><span class="line">d[i*prime[j]]=d[i]/mnnum[i*prime[j]]*(mnnum[i*prime[j]]+<span class="number">1</span>);<span class="comment">//</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">mu[i*prime[j]]=-mu[i];<span class="comment">//</span></span><br><span class="line">phi[i*prime[j]]=phi[i]*(prime[j]<span class="number">-1</span>);<span class="comment">//</span></span><br><span class="line">mnnum[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">d[i*prime[j]]=d[i]*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">musu[i]=musu[i<span class="number">-1</span>]+mu[i];<span class="comment">//</span></span><br><span class="line">phisu[i]=phisu[i<span class="number">-1</span>]+phi[i];<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="杜教筛-S-sieve">杜教筛(S_sieve)</h2><p>建立在欧拉筛的基础上,算是一个插件(?).<br>使用前需先使用欧拉筛筛到 <code>mxxn</code> 的范围,然后再进行单点求积性函数前缀和.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mxxn=<span class="number">1000000</span>;</span><br><span class="line">unordered_map&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">long</span> <span class="type">long</span>&gt;_S_mu;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">S_mu</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=mxxn)<span class="keyword">return</span> musu[n];</span><br><span class="line"><span class="keyword">if</span>(_S_mu[n]!=<span class="number">0</span>)<span class="keyword">return</span> _S_mu[n];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> l=<span class="number">2</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">r=n/(n/l);</span><br><span class="line">res-=<span class="built_in">S_mu</span>(n/l)*(r-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _S_mu[n]=res;</span><br><span class="line">&#125;</span><br><span class="line">unordered_map&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;_S_phi;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">S_phi</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=mxxn)<span class="keyword">return</span> phisu[n];</span><br><span class="line"><span class="keyword">if</span>(_S_phi[n]!=<span class="number">0</span>)<span class="keyword">return</span> _S_phi[n];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">res=(n&amp;<span class="number">1</span>)?((n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>)*n:(n&gt;&gt;<span class="number">1</span>)*(n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> l=<span class="number">2</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">r=n/(n/l);</span><br><span class="line">res-=<span class="built_in">S_phi</span>(n/l)*(r-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _S_phi[n]=res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="单点求phi">单点求phi</h2><p>复杂度O(logn)(其实你可以用两次杜教筛解决一切问题…).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">phi</span><span class="params">(T n)</span></span>&#123;</span><br><span class="line">T res=n;</span><br><span class="line"><span class="keyword">for</span>(T i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>)res=res/i*(i<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(n%i==<span class="number">0</span>)n/=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (n!=<span class="number">1</span>)?(res/n*(n<span class="number">-1</span>)):(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二次剩余">二次剩余</h2><p>求解形如 $x^2\equiv n\mod p$ 的式子.其中,p是奇质数,必须读入全局变量,程序将从小到大返回两个值代表程序的两个解.(n=0时只有0一个解)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sq,p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ccomplex</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> real,imag;</span><br><span class="line"><span class="built_in">ccomplex</span>(<span class="type">long</span> <span class="type">long</span> a=<span class="number">0</span>,<span class="type">long</span> <span class="type">long</span> b=<span class="number">0</span>):<span class="built_in">real</span>(a),<span class="built_in">imag</span>(b)&#123;&#125;</span><br><span class="line">ccomplex <span class="keyword">operator</span> *(<span class="type">const</span> ccomplex&amp; io)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> ccomplex&#123;(real*io.real%p+sq*imag%p*io.imag%p+p)%p,(imag*io.real%p+real*io.imag%p+p)%p&#125;;</span><br><span class="line">&#125;</span><br><span class="line">ccomplex <span class="keyword">operator</span> %(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span>&amp; io)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> ccomplex&#123;real%io,imag%io&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">qp</span><span class="params">(T1 b,T2 po)</span></span>&#123;</span><br><span class="line"><span class="function">T1 <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(po&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(po&amp;<span class="number">1</span>)</span><br><span class="line">res=res*b%p;</span><br><span class="line">b=b*b%p;</span><br><span class="line">po&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">long</span> <span class="type">long</span>&gt;<span class="built_in">Cipolla</span>(<span class="type">long</span> <span class="type">long</span> n)&#123;</span><br><span class="line">n%=p;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">qp</span>(n,(p<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>)==(p<span class="number">-1</span>))<span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res1=<span class="number">-1</span>,res2=<span class="number">-1</span>,a;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">a=<span class="built_in">rand</span>()%p;</span><br><span class="line">sq=(a*a%p-n+p)%p;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">qp</span>(sq,(p<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>)==(p<span class="number">-1</span>))<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">res1=<span class="built_in">qp</span>(<span class="built_in">ccomplex</span>(a,<span class="number">1</span>),(p+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>).real;</span><br><span class="line">res2=p-res1;</span><br><span class="line"><span class="keyword">return</span> (res1&gt;res2)?<span class="built_in">pair</span>&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">long</span> <span class="type">long</span>&gt;(res2,res1):<span class="built_in">pair</span>&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">long</span> <span class="type">long</span>&gt;(res1,res2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="拉格朗日插值UUU">拉格朗日插值UUU</h2><h2 id="PollardRho-PR-Pollard-Rho-质因数分解">PollardRho(PR,Pollard_Rho)质因数分解</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> decompos&#123;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">Number</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> a,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line"><span class="function">mt19937_64 <span class="title">rng</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">return</span> (a+<span class="built_in">rng</span>()%(b-a+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">stein</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> a=y-x;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> b=x-y;</span><br><span class="line"><span class="type">int</span> n=__builtin_ctzll(b);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> s=(x&lt;y?a:b);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> t=(x&lt;y?x:y);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">stein</span>(s&gt;&gt;n,t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span> y;</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>)<span class="keyword">return</span> x;</span><br><span class="line"><span class="type">int</span> n=__builtin_ctzll(x);</span><br><span class="line"><span class="type">int</span> m=__builtin_ctzll(y);</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">stein</span>(x&gt;&gt;n,y&gt;&gt;m)&lt;&lt;(n&lt;m?n:m));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> limit=<span class="number">2147483648</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;small=&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">61</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;large=&#123;<span class="number">2</span>,<span class="number">325</span>,<span class="number">9375</span>,<span class="number">28178</span>,<span class="number">450775</span>,<span class="number">9780504</span>,<span class="number">1795265022</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">qp</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> y,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> m)</span></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(y)&#123;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>)res=((<span class="type">unsigned</span> __int128)res*x)%m;</span><br><span class="line">x=((<span class="type">unsigned</span> __int128)x*x)%m;</span><br><span class="line">y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isComposite</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> a,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> d,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> n,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> s)</span></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x=<span class="built_in">qp</span>(a,d,n);</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(s--)&#123;</span><br><span class="line"><span class="keyword">if</span>(x==n<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x=((<span class="type">unsigned</span> __int128)x*x)%n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;bases=(n&lt;limit?small:large);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(bases.<span class="built_in">begin</span>(),bases.<span class="built_in">end</span>(),n)!=bases.<span class="built_in">end</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p:bases)</span><br><span class="line"><span class="keyword">if</span>(n%p==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> s=__builtin_ctzll(n<span class="number">-1</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> d=(n<span class="number">-1</span>)&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> base:bases)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isComposite</span>(base,d,n,s))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Montgomery</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> m;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> r;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Montgomery</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> n):<span class="built_in">m</span>(n),<span class="built_in">r</span>(n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">r*=<span class="number">2</span>-m*r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">fma</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> a,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> b,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> c)</span><span class="type">const</span></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> __int128 d=(<span class="type">unsigned</span> __int128)(a)*b;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> e=c+m+(d&gt;&gt;<span class="number">64</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> f=(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)(d)*r;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> g=((<span class="type">unsigned</span> __int128)(f)*m)&gt;&gt;<span class="number">64</span>;</span><br><span class="line"><span class="keyword">return</span> (e-g);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">mul</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> a,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> b)</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> <span class="built_in">fma</span>(a,b,<span class="number">0</span>);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">PollardRho</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="function">Montgomery <span class="title">m</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> c1=<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> c2=<span class="number">2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> M=<span class="number">512</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> w1=<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> w2=<span class="number">2</span>;</span><br><span class="line">retry:</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> z1=w1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> z2=w2;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> k=M;;k &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x1=z1+n;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x2=z2+n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> j=<span class="number">0</span>;j&lt;k;j+=M)&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> y1=z1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> y2=z2;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> q1=<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> q2=<span class="number">2</span>;</span><br><span class="line">z1=m.<span class="built_in">fma</span>(z1,z1,c1);</span><br><span class="line">z2=m.<span class="built_in">fma</span>(z2,z2,c2);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> t1=x1-z1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> t2=x2-z2;</span><br><span class="line">z1=m.<span class="built_in">fma</span>(z1,z1,c1);</span><br><span class="line">z2=m.<span class="built_in">fma</span>(z2,z2,c2);</span><br><span class="line">q1=m.<span class="built_in">mul</span>(q1,t1);</span><br><span class="line">q2=m.<span class="built_in">mul</span>(q2,t2);</span><br><span class="line">&#125;</span><br><span class="line">q1=m.<span class="built_in">mul</span>(q1,x1-z1);</span><br><span class="line">q2=m.<span class="built_in">mul</span>(q2,x2-z2);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> q3=m.<span class="built_in">mul</span>(q1,q2);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> g3=<span class="built_in">gcd</span>(n,q3);</span><br><span class="line"><span class="keyword">if</span>(g3==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(g3!=n)<span class="keyword">return</span> g3;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> g1=<span class="built_in">gcd</span>(n,q1);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> g2=<span class="built_in">gcd</span>(n,q2);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> c=(g1!=<span class="number">1</span>?c1:c2);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x=(g1!=<span class="number">1</span>?x1:x2);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> z=(g1!=<span class="number">1</span>?y1:y2);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> g=(g1!=<span class="number">1</span>?g1:g2);</span><br><span class="line"><span class="keyword">if</span>(g==n)&#123;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">z=m.<span class="built_in">fma</span>(z,z,c);</span><br><span class="line">g=<span class="built_in">gcd</span>(n,x-z);</span><br><span class="line">&#125;<span class="keyword">while</span>(g==<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(g!=n)<span class="keyword">return</span> g;</span><br><span class="line">w1+=<span class="number">2</span>;</span><br><span class="line">w2+=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">factorize</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> n,vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isPrime</span>(n))&#123;</span><br><span class="line">res.<span class="built_in">push_back</span>(n);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> p=<span class="built_in">PollardRho</span>(n);</span><br><span class="line"><span class="built_in">factorize</span>(p,res);</span><br><span class="line"><span class="built_in">factorize</span>(n/p,res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用法：使用factorize(数,接受答案的vec)进行一个数的分解，返回一个数的所有不重因子（记得排序）别的函数都不用管 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="快速傅里叶变换-FFT">快速傅里叶变换(FFT)</h2><p>用于解决多项式快速乘法问题…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,<span class="keyword">typename</span> T3&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">qp</span><span class="params">(T1 b,T2 po,T3 p)</span></span>&#123;</span><br><span class="line">T1 res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(po&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(po&amp;<span class="number">1</span>)</span><br><span class="line">res=res*b%p;</span><br><span class="line">b=b*b%p;</span><br><span class="line">po&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mxx 2100000</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">double</span> <span class="title">pi</span><span class="params">(acos(<span class="number">-1</span>))</span></span>;</span><br><span class="line"><span class="type">int</span> rev[mxx],res[mxx],k,s;<span class="comment">/*s=2*n-1,k=log(s),*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">n=(n&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>;k=<span class="number">0</span>;s=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;k)&lt;n)k++,s&lt;&lt;=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;<span class="comment">//生成旋转交换数列 </span></span><br><span class="line">rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(cp* a,<span class="type">int</span> n,<span class="type">int</span> flag)</span></span>&#123;<span class="comment">//区间[0,n) </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;rev[i])&#123;</span><br><span class="line"><span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> h=<span class="number">1</span>;h&lt;n;h&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">cp wn=<span class="built_in">exp</span>(<span class="built_in">cp</span>(<span class="number">0</span>,flag*pi/h));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(h&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line"><span class="function">cp <span class="title">w</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=j;k&lt;j+h;k++)&#123;</span><br><span class="line"><span class="built_in">tie</span>(a[k],a[k+h])=<span class="built_in">make_tuple</span>(a[k]+w*a[k+h],a[k]-w*a[k+h]);</span><br><span class="line">        w*=wn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">-1</span>)&#123;<span class="comment">//IFFT</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">a[i]/=n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getres</span><span class="params">(cp* res,<span class="type">int</span>* rres)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(rres,<span class="number">0</span>,<span class="built_in">sizeof</span>(rres));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;++i)&#123;</span><br><span class="line">rres[i]+=res[i].<span class="built_in">real</span>()+<span class="number">0.5</span>;</span><br><span class="line">rres[i+<span class="number">1</span>]+=rres[i]/<span class="number">10</span>;</span><br><span class="line">rres[i]%=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ff=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=s<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line"><span class="keyword">if</span>(ff==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,rres[i]);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(rres[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">ff=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,rres[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ff==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="快速数论变换-NTT">快速数论变换(NTT)</h2><p>使用逆元代换上式的复数和一堆奇奇怪怪的东西得到这个…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,<span class="keyword">typename</span> T3&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">qp</span><span class="params">(T1 b,T2 po,T3 p)</span></span>&#123;</span><br><span class="line">T1 res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(po&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(po&amp;<span class="number">1</span>)</span><br><span class="line">res=res*b%p;</span><br><span class="line">b=b*b%p;</span><br><span class="line">po&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mxx 2100000</span></span><br><span class="line"><span class="type">int</span> rev[mxx],k,s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">n=(n&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>;k=<span class="number">0</span>;s=<span class="number">1</span>;<span class="comment">/*n是数列长度,k是log(s),s是答案的最长长度,2*n-1*/</span></span><br><span class="line"><span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;k)&lt;n)k++,s&lt;&lt;=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;i++)&#123;<span class="comment">//生成旋转交换数列 </span></span><br><span class="line">rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(k<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> ord=<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> n,<span class="type">int</span> flag)</span></span>&#123;<span class="comment">//[0,n)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(rev[i]&lt;i)&#123;</span><br><span class="line"><span class="built_in">swap</span>(a[i],a[rev[i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> h=<span class="number">2</span>;h&lt;=n;h&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> k=h&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> gn=<span class="built_in">qp</span>((<span class="type">long</span> <span class="type">long</span>)ord,(mod<span class="number">-1</span>)/h,mod);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i+=h)&#123;</span><br><span class="line"><span class="type">int</span> g=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;++j,g=<span class="number">1LL</span>*g*gn%mod)&#123;</span><br><span class="line"><span class="type">int</span> tmp=<span class="number">1LL</span>*a[i+j+k]*g%mod;</span><br><span class="line">a[i+j+k]=(a[i+j]-tmp+mod)%mod;</span><br><span class="line">a[i+j]=(a[i+j]+tmp)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">-1</span>)&#123;<span class="comment">//FNTT</span></span><br><span class="line"><span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line"><span class="type">int</span> inv=<span class="built_in">qp</span>((<span class="type">long</span> <span class="type">long</span>)n,mod<span class="number">-2</span>,mod);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">a[i]=<span class="number">1LL</span>*a[i]*inv%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getres</span><span class="params">(<span class="type">int</span>* cc)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(cc[i]&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">cc[i+<span class="number">1</span>]+=cc[i]/<span class="number">10</span>;</span><br><span class="line">cc[i]%=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ff=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=s;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line"><span class="keyword">if</span>(ff==<span class="number">1</span>)&#123;</span><br><span class="line">fout&lt;&lt;cc[i];</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(cc[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">fout&lt;&lt;cc[i];</span><br><span class="line">ff=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ff==<span class="number">0</span>)fout&lt;&lt;<span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线性基">线性基</h2><h2 id="模拟退火-SA">模拟退火(SA)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">SAcheck</span><span class="params">(<span class="type">double</span> v)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">SA</span><span class="params">(<span class="type">double</span> rres,<span class="type">double</span> t=<span class="number">3000</span>,<span class="type">double</span> EPS=<span class="number">1e-14</span>,<span class="type">double</span> down=<span class="number">0.996</span>)</span></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="type">double</span> res=<span class="built_in">SAcheck</span>(rres);</span><br><span class="line"><span class="keyword">while</span>(t&gt;EPS)&#123;</span><br><span class="line"><span class="type">double</span> eres=rres+t*((<span class="built_in">rand</span>()&lt;&lt;<span class="number">1</span>)-RAND_MAX);<span class="comment">//新随机答案</span></span><br><span class="line"><span class="type">double</span> tmp=<span class="built_in">SAcheck</span>(eres);</span><br><span class="line"><span class="type">double</span> de=tmp-res;</span><br><span class="line"><span class="keyword">if</span>(de&lt;<span class="number">0</span>)&#123;</span><br><span class="line">res=tmp;</span><br><span class="line">rres=eres;<span class="comment">//答案生成器</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span>(-de/t)*RAND_MAX&gt;<span class="built_in">rand</span>())&#123;</span><br><span class="line">rres=eres;</span><br><span class="line">&#125;</span><br><span class="line">t*=down;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>计算几何</h1><p>正在研发中…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line"><span class="type">double</span> x,y;</span><br><span class="line"><span class="built_in">point</span>(<span class="type">double</span> a=<span class="number">0</span>,<span class="type">double</span> b=<span class="number">0</span>):<span class="built_in">x</span>(a),<span class="built_in">y</span>(b)&#123;&#125;</span><br><span class="line"><span class="type">char</span> <span class="keyword">operator</span>&lt;(point io)&#123;</span><br><span class="line"><span class="keyword">return</span> (x==io.x)?(y&lt;io.y):(x&lt;io.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(point io)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((io.y-y)*(io.y-y)+(io.x-x)*(io.x-x));</span><br><span class="line">&#125;</span><br><span class="line">point <span class="keyword">operator</span>-(point io)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;x-io.x,y-io.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prr</span><span class="params">()</span></span>&#123;</span><br><span class="line">fout&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">circle</span>&#123;</span><br><span class="line">point p;</span><br><span class="line"><span class="type">double</span> r;</span><br><span class="line"><span class="built_in">circle</span>(<span class="type">double</span> a=<span class="number">0</span>,<span class="type">double</span> b=<span class="number">0</span>,<span class="type">double</span> c=<span class="number">0</span>):<span class="built_in">p</span>(a,b),<span class="built_in">r</span>(c)&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isincircle</span><span class="params">(point io)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> tmp=p.<span class="built_in">dis</span>(io)-r;</span><br><span class="line"><span class="keyword">if</span>(tmp==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//在圆上</span></span><br><span class="line"><span class="keyword">if</span>(tmp&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//在圆内</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;    <span class="comment">//在园外</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">direct</span>&#123;</span><br><span class="line"><span class="type">double</span> x,y;</span><br><span class="line"><span class="built_in">direct</span>(<span class="type">double</span> a=<span class="number">0</span>,<span class="type">double</span> b=<span class="number">0</span>):<span class="built_in">x</span>(a),<span class="built_in">y</span>(b)&#123;&#125;</span><br><span class="line"><span class="built_in">direct</span>(point a,point b):<span class="built_in">x</span>(b.x-a.x),<span class="built_in">y</span>(b.y-a.y)&#123;&#125;<span class="comment">//a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">xmul</span><span class="params">(direct io)</span></span>&#123;<span class="comment">//正值代表逆时针方向,负值代表顺时针方向,0代表共线</span></span><br><span class="line"><span class="keyword">return</span> x*io.y-y*io.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dotmul</span><span class="params">(direct io)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*io.x+y*io.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">direct <span class="title">inv</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;-x,-y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">lenth</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">xmul</span><span class="params">(point a,point b,point c,point d)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">direct</span>(a,b).<span class="built_in">xmul</span>(&#123;c,d&#125;);</span><br><span class="line">&#125;</span><br><span class="line">point dat[<span class="number">400010</span>];</span><br><span class="line"><span class="type">double</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">AndrewHull</span><span class="params">(point* dat,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(dat+<span class="number">1</span>,dat+<span class="number">1</span>+n);</span><br><span class="line"><span class="type">double</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> stac[n+<span class="number">3</span>]&#123;&#125;,top=<span class="number">0</span>;</span><br><span class="line">top=<span class="number">0</span>;</span><br><span class="line">stac[++top]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">while</span>(top&gt;=<span class="number">2</span>)&#123;</span><br><span class="line"><span class="type">double</span> tmp=<span class="built_in">xmul</span>(dat[stac[top<span class="number">-1</span>]],dat[stac[top]],dat[stac[top]],dat[i]);</span><br><span class="line"><span class="keyword">if</span>(tmp&lt;<span class="number">0</span>)top--;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">stac[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;top;++i)&#123;</span><br><span class="line"><span class="comment">//在这里求出下凸包并且计算距离,do something</span></span><br><span class="line">res+=dat[stac[i]].<span class="built_in">dis</span>(dat[stac[i+<span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br><span class="line">top=<span class="number">0</span>;</span><br><span class="line">stac[++top]=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line"><span class="keyword">while</span>(top&gt;=<span class="number">2</span>)&#123;</span><br><span class="line"><span class="type">double</span> tmp=<span class="built_in">xmul</span>(dat[stac[top<span class="number">-1</span>]],dat[stac[top]],dat[stac[top]],dat[i]);</span><br><span class="line"><span class="keyword">if</span>(tmp&lt;<span class="number">0</span>)top--;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">stac[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;top;++i)&#123;</span><br><span class="line"><span class="comment">//在这里求出上凸包并计算距离,do something</span></span><br><span class="line">res+=dat[stac[i]].<span class="built_in">dis</span>(dat[stac[i+<span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OTH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> NumberTheory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BST,平衡树</title>
      <link href="/2024/07/21/BST-%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
      <url>/2024/07/21/BST-%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散化</title>
      <link href="/2024/07/20/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
      <url>/2024/07/20/%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>离散化作用就是把值域较大的数据建立一个映射放到值域较小的范围里面.鉴于Flu不太会用函数,所以开个坑.</p><p>离散化步骤:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(dat+<span class="number">1</span>,dat+<span class="number">1</span>+n);</span><br><span class="line">m=<span class="built_in">unique</span>(dat+<span class="number">1</span>,dat+<span class="number">1</span>+n)-dat<span class="number">-1</span>;</span><br><span class="line"><span class="comment">//m是实际不重合元素个数.</span></span><br><span class="line"><span class="comment">//tmp是每个元素离散化之后的值(排名).</span></span><br><span class="line">tmp=<span class="built_in">upper_bound</span>(dat+<span class="number">1</span>,dat+<span class="number">1</span>+m,val)-dat<span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>对应函数解释:<br><code>sort</code>排序,啥也不说是默认从小往大排序.写cmp可以实现自定义排序规则.<br><code>upper_bound</code>是二分返回第一个<strong>大于</strong>元素的地址.<br><code>lower_bound</code>二分返回第一个<strong>不小于</strong>元素的地址.</p><h3 id="排序规则">排序规则</h3><p>这里仔细讲讲,防止Flu考试的时候先检查排序结果对不对…</p><p>其实排序标准挺好记的,就是用<code>&lt;</code>连接的就是结果.比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.a==b.a)<span class="keyword">return</span> a.b&gt;b.b;</span><br><span class="line"><span class="keyword">return</span> a.a&lt;b.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码首先按照a从小到大(<code>&lt;</code>的顺序)排序,a一样按b从大到小排序.</p><p>附:函数调用未知函数的格式是这样:(课设的程序,乐)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.a&gt;b.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ssort</span><span class="params">(node* head,<span class="type">char</span> cc(node a,node b))</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cc</span>(tmp,ttmp))&#123;</span><br><span class="line">        <span class="comment">//交换...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用:</span></span><br><span class="line"><span class="built_in">ssort</span>(stuhead,cmp11);</span><br><span class="line"><span class="comment">//函数名字写上就行了...程序会自动调用</span></span><br></pre></td></tr></table></figure><p>排序的时候有用,多重排序规则可以一个排序函数完成多种排序,大大降低码量,拒绝屎山(得意).</p>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2024/07/20/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2024/07/20/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>线段树分好几类.接下来分开讲解.</p><p>线段树维护的是一段区间上的某些信息.比如最大值,加和等.</p><p>线段树写法有类似堆的儿子是<code>2fa</code>和<code>2fa+1</code>定死的以及类似栈分配内存的<code>++top</code>两种.由于动态开点比较方便,笔者一律采用第二种.</p><p>笔者把板子叫<code>str</code>,选取segment tree的名字简写.</p><p>但是吧考虑到Flu码风要和大多数人接轨,以后可能会改成很长的名字也说不准…</p><h2 id="内存计算">内存计算</h2><p>普通线段树的内存是 $O(n\log n)$ .计算的时候由于计算器大多数没有 $\log_2$ 的选项,根据换底公式可以取 $\lg$ 然后乘上 $1.44$ 一个常数得到实际上的内存占用,所谓的线段树<code>20</code>倍空间实际上应该是对主席树说的.</p><p>记住,<code>1e7</code>大小的<code>int</code>大概是<code>40Mb</code>.</p><h1>普通线段树</h1><p>懒标记.</p><h1>权值线段树</h1><p>这个时候有人要问了,假如我想查找比他小的元素有多少个,但是线段树是[1,pos]和[pos,n]区间的加和,该咋办?<br>…<br>你傻啊,减1加1不就完了…</p><h1>zkw线段树</h1><p>重口味线段树?</p><h1>势能线段树(吉司机线段树)</h1><h1>可持久化线段树</h1><p>RT,就是为了实现版本回退提供的特殊数据结构.满足一次操作新建logn个节点,然后支持历史版本查询和回退.放一张图:<br><img src="https://cdn.luogu.com.cn/upload/pic/20236.png" alt="图炸了请联系Flu"></p><p>也就是线段树克隆子枝的一个过程.</p><h2 id="应用">应用</h2><p>看题.</p><ol><li>区间加一个 <strong>等差数列</strong> ,单点查询.</li></ol><p>建一个普通线段树,维护 <strong>差分数列</strong> ,然后查询就是1-n的和,修改就是 $a_l$ 加首项, $a_{l+1}-a_r$ 加公差, $a_{r+1}$ 减末项即可.</p><ol start="2"><li>求最长上升M元子序列</li></ol><p>使用dp.设 $f[i][j]$ 表示以 $a_j$ 结尾的长度为i的序列的个数,有<br>$$f[i][j]=\sum_{k&lt;j,a_k&lt;a_j}f[i-1][k]$$<br>可以用树状数组,也可以用线段树维护.具体实现:先循环i,离散化,树状数组存储 $f[i-1][a_i]$ ,循环到j的时候加上这么多就行(比它小的),然后数组加上 $f[i-1][a_j]$ .注意j要从小到大循环,每次询问 $a_j-1$ 保证闭区间求和.</p><p>3.GSS系列(1&amp;3)</p><p>SPOJ上面的一系列数据结构题,线段树维护一些奇奇怪怪的东西的题.:维护一段序列,单点修改,问一段区间的 <strong>最大子段和</strong>(也就是求 $\sum_{i=l}^ra_i,L\le l\le r\le R$ )</p><p>我们先对子段和进行分析:一段大区间上的子段和只可能是左边的,或者右边的,或者一段横贯左右两个小区间的子段和.</p><p>横贯两个区间显然左区间的最大包含右边的子段和和右边包含左边的最大子段和拼起来就完了.对此我们魔改<code>push_up</code>函数,也就是大区间包含小区间的过程.</p><p>我们需要维护val表示区间直接相加的和,res表示区间的最大子段和,lmax表示区间包含左边界的最大子段和,rmax同理.</p><p>由于lmax必须包含左边界,所以区间的lmax要么是左区间的lmax要么是左区间和加上右区间的lmax.rmax同理.</p><p>所以我们可以做出<code>push_up</code>函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> mod,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//down stream</span></span><br><span class="line">dat[mod].val=dat[dat[mod].l].val+dat[dat[mod].r].val;</span><br><span class="line">dat[mod].lmax=<span class="built_in">max</span>(dat[dat[mod].l].lmax,dat[dat[mod].l].val+dat[dat[mod].r].lmax);</span><br><span class="line">dat[mod].rmax=<span class="built_in">max</span>(dat[dat[mod].r].rmax,dat[dat[mod].r].val+dat[dat[mod].l].rmax);</span><br><span class="line">dat[mod].res=<span class="built_in">max</span>(<span class="built_in">max</span>(dat[dat[mod].l].res,dat[dat[mod].r].res),dat[dat[mod].l].rmax+dat[dat[mod].r].lmax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询也一样,我们可以把区间缩成一个一个的点,然后最后的区间合并成一个点,然后结果就是最后的节点里面装着的res.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">strnode <span class="title">qquery</span><span class="params">(<span class="type">int</span> mod,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> tl,<span class="type">int</span> tr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l&amp;&amp;r&lt;=tr)<span class="keyword">return</span> dat[mod];</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tr&lt;=mid)<span class="keyword">return</span> <span class="built_in">qquery</span>(dat[mod].l,l,mid,tl,tr);</span><br><span class="line"><span class="keyword">if</span>(mid&lt;tl)<span class="keyword">return</span> <span class="built_in">qquery</span>(dat[mod].r,mid+<span class="number">1</span>,r,tl,tr);</span><br><span class="line">strnode a,b,res;</span><br><span class="line">a=<span class="built_in">qquery</span>(dat[mod].l,l,mid,tl,tr),b=<span class="built_in">qquery</span>(dat[mod].r,mid+<span class="number">1</span>,r,tl,tr);</span><br><span class="line">res.lmax=<span class="built_in">max</span>(a.lmax,a.val+b.lmax);</span><br><span class="line">res.rmax=<span class="built_in">max</span>(b.rmax,b.val+a.rmax);</span><br><span class="line">res.val=a.val+b.val;</span><br><span class="line">res.res=<span class="built_in">max</span>(<span class="built_in">max</span>(a.res,b.res),a.rmax+b.lmax);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>qquery</code>中的递归顺序:正常线段树中的<code>qquery</code>是只要区间沾一点就递归加,现在是必须完全覆盖,所以要稍微改一下递归顺序.</p><ol start="4"><li>GSS4 给一段序列,区间每一个数开根号(向下取整),区间求和.显然还是使用线段树去维护的.如何搞???</li></ol><p>我们可以发现一个性质:即便是 $10^{18}$ 在开6次根号之后也就变成1点多了,所以每个数最多被开6次根号.</p><p>所以我们需要使用线段树维护一个val和是否是1的tag,其中开根号就暴力求,如果区间都是1或0直接忽略,求和就线段树求和.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cchange</span><span class="params">(<span class="type">int</span> mod,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> tl,<span class="type">int</span> tr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dat[mod].tg)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">dat[mod].val=<span class="built_in">sqrt</span>(dat[mod].val);</span><br><span class="line"><span class="keyword">if</span>(dat[mod].val&lt;=<span class="number">1</span>)dat[mod].tg=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid)<span class="built_in">cchange</span>(dat[mod].l,l,mid,tl,tr);</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid)<span class="built_in">cchange</span>(dat[mod].r,mid+<span class="number">1</span>,r,tl,tr);</span><br><span class="line"><span class="built_in">push_up</span>(mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>HH的项链,给定序列,查询区间[l,r]中有多少种不同的数字.</li></ol><p>对于去重这种的首先考虑离线做法.我们按照r升序排列所有询问,然后从左到右扫描(a).我们扫什么?建一个vis数组表示这个数上一次出现的位置,然后如果这个数上一次出现了(b),那就线段树减(b,-1),该点相加(a,1),举例:<br>序列 1 1 4 5 1 4 ,从左到右扫分别是(线段树叶子节点):<br>100000 010000 011000 011100 001110 000111<br>假如我们碰到询问了,假如说是[2,5],那就求前缀和(5)-(2-1)就可以了.</p><ol start="6"><li>HH的项链加强版:给定序列区间中出现两次(及以上)不重的数.</li></ol><p>考虑5的魔改.上一回我们使用了一个vis记录第一次出现的位置,这次我们拓展这个成last1和last2表示第一次出现以及第二次出现(第二次以上出现就没意思了),<strong>第一次出现记录last1,第二次出现记录last2,同时对last1对应的位置+1</strong>(因为对last2位置+1会错,区间l可能不覆盖第一次的位置)<strong>第二次及以上就覆盖,add(last1,-1),add(last2,1),然后向下传递last1=last2,last2=pos</strong>.查询不变.<br>拓展:同时出现n次才算:维护last1-lastn即可.</p><ol start="7"><li>区间查询sin值和,区间加上角度v.</li></ol><p>考虑公式<br>$$\sin(x+v)=\sin x\cos v+\sin v\cos x$$<br>$$\cos(x+v)=\cos x\cos v-\sin v\sin x$$<br>我们维护该点的sin,cos,然后打一个懒标记.</p><p>然后发现tag也可以直接加.于是就是普通线段树题了.<br>收获:懒标记代表的是已经计算过但是没传的.而不应该是打了没算.<br>三个函数: <code>push_up</code> 通过儿子更新该节点的答案, <code>push_down</code> 把tag传给孩子, <code>upd</code> 通过tag更新答案.</p>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF Round952 Div4</title>
      <link href="/2024/07/18/CF-Round952-Div4/"/>
      <url>/2024/07/18/CF-Round952-Div4/</url>
      
        <content type="html"><![CDATA[<p>妈耶,我打Div4都不能AK…</p><h2 id="C">C</h2><p>给一个数列.统计有多少个i满足前i个数是好的.<br>好的定义是数列中存在一个数是其他所有数的和.</p><p><strong>贪心</strong>:假如有一个数是其他所有数的和,他占数列和的50%,也就是说他是最大的.所以我们先算前缀和再找最大数直接比较即可.</p><h2 id="G">G</h2><p>$$D(x)=\sum_xdigits$$<br>D函数,是所有数字的和.比个例子: $D(114)=1+1+4=6$ .</p><p>D函数有一个性质:假如有<br>$$D(k\cdot n)=k\cdot D(n)$$<br>则 $kn$ 不会有进位.也就是说n中数字没有大于 $\lfloor\frac9k\rfloor$ 的.</p><h2 id="H1">H1</h2><p>给一个用.和#组成的矩阵,求选择一行或一列全部变成#的最大连通块是多少.<br>举例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line">#...#</span><br><span class="line">....#</span><br><span class="line">#...#</span><br><span class="line">.....</span><br><span class="line">...##</span><br><span class="line">输出</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><p>思路:我们选择一行的时候首先要把.变成#,这个可以预处理出来.然后我们要把两边的最大连通块搞出来加上.</p><p>最终我们需要预处理连通块,也就是前几行以边为界的连通块,可以dfs出来.这样选边的时候可以 $O(1)$ 计算.</p><p>时间复杂度 $O(nm)$ .</p><h2 id="H2">H2</h2><p>还是这个矩阵,变成可以选一行和一列.</p><p>算法:只是变成前几行前几列为界的连通块而已,算法没变太多.</p>]]></content>
      
      
      <categories>
          
          <category> OTH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Contest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NowCoder ACM Round1</title>
      <link href="/2024/07/17/NewCoder-ACM-Round1/"/>
      <url>/2024/07/17/NewCoder-ACM-Round1/</url>
      
        <content type="html"><![CDATA[<p>第一场训练拉开帷幕…</p><h2 id="赛程">赛程</h2><p>我们队非常幸运,做对了四道题成功拿到高位银牌(204/1488个有分的).</p><p>我们队(BJL,边角料)有一位零基础选手,一位高中OIer,一位初中OIer,就这么开始了又菜又爱玩的旅途…</p><p>我们最初的目标是只要开出来签到题就算成功…结果最后开对了四个…真的十分意外…</p><p>刚开始Flu从F开始看,看到K发现一共有H和I像是可做题目.</p><p>Flu开H,挂了.QianK也写H,过了.<br>Flu开I,此时零基础选手开C发现不会,QianK开C,过了.<br>此时Flu全力开I,最后WA三发过了I,稳铜了.<br>最后,大佬告诉我们组合数可以用杨辉三角做,QianK开A,过了.</p><p>然后,大家凭借4道题的优势稳高位银(对4个如果罚时少的话可以进金的),下班.</p><h1>总结环节(比赛程重要多了)</h1><p>以下按照主观排序.</p><h2 id="C">C</h2><p>签到.假设 $q_i=a_i+a_{i+1}+a_{i+2}+…+a_n$ ,计算 $\sum_{i=1}^nq_i$ .<br>拆成每一个元素贡献维护 $\sum_{i=1}^ni*a_i$ 即可.</p><h2 id="H">H</h2><p>有一个人能打A比赛或B比赛(只能参加一场),然后排名目前已经确定,求他的最好名次.</p><p>贪心.Flu开题写挂的地方在于, <strong>最优解是要么参加第一场,其他所有人参加第二场,要么参加第二场,其他所有人参加第一场</strong> ,Flu没想到,挂了.</p><h2 id="I">I</h2><p>Flu唯一一道靠自己写对的题.大模拟即可.</p><p>Flu WA了三发.前两发是记忆化写挂了,后面发现记忆化假了,于是硬模拟,又WA了一发,是因为镜子可以被反射两次但是计数一次,最后过了.</p><h2 id="A">A</h2><p>求有多少个长度为 $n$ ,元素取值在 $[0,2^m)$ 范围的数列满足其非空子序列与和是 $1$ .对输入整数 $q$ 取模(<strong>特别注意 $q$ 不一定是质数</strong>).<br>$$1\le n,m\le5000,1\le q\le10^9$$<br>设数列中二进制位最低为1的数有k个.求<br>$$\sum_{k=1}^n\binom{n}{k}2^{(n-k)(m-1)}(2^k-1)^{m-1}$$<br>式子解释:设了一个k,然后最后一位是0的显然不能在子序列里面,最后一位是0的有 $2^{m-1}$ 个,套上组合数就是前面半部分.</p><p>后半部分就是,剩下的子序列都是尾部是1的,然后由于他们与和是1(由于1&amp;0=0所以剩下的尾数为1的都可以加到子序列里面),要在每一位分散一些0.如何分散?就是 $\binom{k}{1}+\binom{k}{2}+…+\binom{k}{k}=2^k-1$ (删掉全是1的情况),然后这样的位一共有 $m-1$ 个,就是后半部分答案.</p><p>取模:由于q不一定是质数,考虑杨辉三角解决.</p><h2 id="B">B</h2><p>在A的基础上变成&quot;存在两个不同非空子序列&quot;这个条件.</p>]]></content>
      
      
      <categories>
          
          <category> OTH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Contest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFT</title>
      <link href="/2024/07/12/FFT/"/>
      <url>/2024/07/12/FFT/</url>
      
        <content type="html"><![CDATA[<p>FFT,一个令人胆寒的算法(前置知识比较多,又是复数又是矩阵又是点值的…).</p><p>如果想学习原理,请左转<a href="https://oi-wiki.org/math/poly/fft/">OIWiki</a>,这里主要聊聊FFT的升级以及实战经验该怎么写.</p><h2 id="NTT">NTT</h2><p>会炸精度…实际有效的精度大概就是两位.</p><p>例题:P2000拯救世界,计算 $(a+1)(a+2)(a+3)(a+4)/24$ ,使用NTT先计算出 $(a+1)*(a+2)$ 然后要 <strong>处理进位</strong> ,然后再乘上后半部分.</p><h3 id="模数选择">模数选择</h3><p>常见的NTT模数和原根表如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mod       ord</span><br><span class="line">998244353  3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> NumberTheory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF Round957 Div3</title>
      <link href="/2024/07/12/CF-Round957-Div-3/"/>
      <url>/2024/07/12/CF-Round957-Div-3/</url>
      
        <content type="html"><![CDATA[<p>这是蒟蒻的CF游记!虽然10点35的比赛Flu10点55才收到消息,急慌燎忙开打,总归是收获不小.</p><p>蒟蒻没有用过CF Better插件,在ZHY大神的帮助下装了(蒟蒻因为浏览器自带翻译把i这个变量翻译成我,而且装在LaTeX里面特别乱,Flu整场光读题估计就花了很长时间,约半个小时?),感谢一下.</p><p>这是蒟蒻第一次打CF,见谅(个屁,我等级分不可能再降了,因为原先是0).</p><p>现在是讲题时间.</p><h2 id="A">A</h2><p>给仨数,你每次能选一个数加1,你能操作5次.</p><p>Flu赛时做法是穷举,暴搜每一种情况.</p><p>其实应该这么想:有 $a\times b\times c$ 这么个值,你要选一个加一,就能把乘法看成加法.于是考虑贡献,得出结论:每次给最小的加上1,能收获最大结果.</p><h2 id="B">B</h2><p>合并与被合并的题.好多根木棒,你要拼成1根.你每次能把一根劈成1和剩下的,也可以用1和一根合成一根更长的.</p><p>直接计算即可.</p><h2 id="C">C</h2><p>构造排列题.</p><p>这个题卡了Flu很久,原因是读不懂题,后来做了D之后再看的C.</p><blockquote><p>原题干:<br>$g(i)$ is the sum of all the numbers in the permutation on a prefix of length $i$ that are not greater than $m$ .</p></blockquote><p>什么意思呢,又是排列又是加和又是前缀和的…所以看不懂,卡了很久.</p><p>人话: $g$ 是一个加和函数,如果一个数 $a_i\le m$ 那么 $g(i)$ 就加上 $a_i$ ,仅此而已.</p><p>构造本身是比较简单的,一眼能看出来.</p><h2 id="D">D</h2><p>检验爱情,有一个人要游泳过河.河宽n(也就是从0游到n+1这两个点),整数位上有东西,是水W,木头L和鳄鱼C.</p><p>Flu的做法是跑两遍,第一遍倒着覆盖鳄鱼,因为有鳄鱼的地方不能游,就先把所有不能到的地方标记上鳄鱼,那些是只能跳过去的地方.</p><p>运算就是,定一个ff表示距离,如果到原木(终点加一个原木即可)那就结算(游+跳能不能过去),碰到鳄鱼就加ff(距离),一直到鳄鱼结束不要结算,判断一下能不能跳过去,因为鳄鱼后面可能还有水是能游的.</p><p><strong>另外,结算的时候注意一点,游泳是整张图只能游这么长,也就是结算时候语句是<code>k-=max(0,ff-m)</code>防止不减反增.</strong></p><h2 id="E">E</h2><p>定义字符串的加是<br>$$n*a=\underbrace{nn…n}_{a}$$<br>字符串的减是直接末尾抹去几位,求对于n,有多少(a,b)满足 $na-b=na-b$ .左边字符串算法,右边正常数值算法.<br>$$1\le n\le100,1\le a,b\le10000$$<br>比赛的时候没看到数据范围,以为不可做,谁知道直接暴力就行了…</p><p>对的,就是暴力.</p><p>但是Flu赛后补题的时候WA了一发,原因是,倒着取模.数肯定是要从高位拼起来的,所以取模的时候整数an(最高位)对应0,也就是说你需要一个逆着的数字,不仅仅是逆着转移.所以对于33这种回文数字Flu是正解,但是对于某些如63这种就假了.</p><h2 id="F">F</h2><p>因子.</p><p>有一点要注意:map的特性(因为这个导致Flu没调出来,少A了一道题)是查找就建表了.</p><p>比个例子:表里面装着2,现在查找1,由于没有1,查出来是0.(在查的时候已经建表了,只是1对应0而已)</p><p>然后遍历表里面的元素进行除再加新元素(使用一个vector作为中继,防止遍历到才加进去的元素)的时候会出问题,因为1在查的时候已经加进去了,就喜提WA.</p><p>如果加上特判标记就会喜提TLE.</p><p>综上,要使用set,别老惦记着unordered_map.</p><h2 id="G">G</h2><p>定义MEX(S,k)表示集合S中第k个没出现的最小元素.</p><p>求给定集合n(也就是1-n所有数组成的集合)的所有子集的 $MEX(S,|S|+1)$ 和.</p><p>例: $MEX({1,2,4},1)=3$</p><p>首先,观察发现,范围 $|S|+1\le MEX(S,|S|+1)\le2|S|+1$ ,也就是所有元素都在里面和都不在里面的极端状况.然后考虑一般状况,也就是一部分在里面一部分不在里面.至此,我们枚举所有S的大小(i),然后枚举对应的mex的大小(j).考虑有些元素在mex里面,也就是 $\binom{j-1}{j-i-1}$ ,然后不在里面的就是 $\binom{n-j}{2i-j+1}$ ,乘在一起就是了.</p><p>注意一个点是j-1有可能大于n,卡好范围.</p><h2 id="总结">总结</h2><p>多见见题.</p>]]></content>
      
      
      <categories>
          
          <category> OTH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Contest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉定理,费马小定理</title>
      <link href="/2024/07/11/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86-%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/"/>
      <url>/2024/07/11/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86-%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>RT,这里摆一些公式怕某人忘了.</p><p>费马小定理:<br>$$a^{p-2}\equiv a^{-1}\mod p$$<br>欧拉定理/拓展欧拉定理:<br>$$a^b\equiv\begin{cases}a^{b\mod \varphi(p)}&amp;\gcd(a,p)=1\a^b&amp;\gcd(a,p)\neq1,b&lt;\varphi(p)\a^{b\mod\varphi(p)+\varphi(p)}&amp;\gcd(a,p)\neq1,b\ge\varphi(p)\end{cases}\mod p$$<br>其中第二行的意思是不能降幂了(欧拉定理推出来的比原来还大不是我们想要的)</p><h2 id="质数专题">质数专题</h2><p>总结一下啥时候能直接使用函数,什么时候不可以.</p><h2 id="模数随意使用">模数随意使用</h2><p>快速幂.</p><h2 id="模数互质时随意使用">模数互质时随意使用</h2><h2 id="模数必须是质数">模数必须是质数</h2>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NumberTheory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拉格朗日插值</title>
      <link href="/2024/07/11/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/"/>
      <url>/2024/07/11/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>拉插的用法就是,给定好多个点,让你拟合一条多项式的曲线经过这些点,求出这个函数在x=k的时候的值.</p><h2 id="拉插公式">拉插公式</h2><p>$$f(x)=\sum_{i=0}^ny_i\prod_{i\neq j}\frac{k-x_j}{x_i-x_j}$$<br>理解一下:假如给的点是 $(1,3),(2,7),(3,13)$ ,拉插就是:<br>$$f(k)=3\frac{(k-2)(k-3)}{(1-2)(1-3)}+7\frac{(k-1)(k-2)}{(2-1)(2-3)}+13\frac{(k-1)(k-2)}{(3-1)(3-2)}$$</p><h2 id="x取值连续的优化">x取值连续的优化</h2><p>由于x取值连续,可以快速计算前缀积和后缀积(上面)以及阶乘(下面)然后实现 $O(n)$ 的计算拉插.(N表示有几项)<br>$$pre_i=\prod_{j=1}^ik-j$$<br>$$suf_i=\prod_{j=i}^Nk-j$$<br>$$f(k)=\sum_{i=1}^Ny_i\frac{pre_{i-1}\cdot suf_{i+1}}{(i-1)!(N-i)!}$$</p><h2 id="重心拉插">重心拉插</h2><p>可以实现加点的计算方式:<br>$$f(x)=\sum_{i=0}^ny_i\prod_{i\neq j}\frac{k-x_j}{x_i-x_j}$$<br>令 $g=\prod^n_{i=0}k-x_i$ ,则有<br>$$f(k)=g\sum_{i=0}^n\prod_{i\neq j}\frac{y_i}{(k-x_i)(x_i-x_j)}$$<br>设 $t_i=\frac{y_i}{\prod_{i\neq j}x_i-x_j}$ ,则有<br>$$f(k)=g\sum_{i=0}^n\frac{t_i}{(k-x_i)}$$<br>这样加点的时候只需要计算他的 $t_i$ 即可.</p><h2 id="应用">应用</h2><p>首先你要证明这是一个多项式,能用插值.</p><p>典型:<br>$$\sum_{i=1}^ni^k$$<br>首先证明是一个多项式,然后&quot;直接插值&quot;(按n为变元,暴力算每个数,然后按点插值即可)</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2024/07/11/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2024/07/11/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>并查集有普通并查集,拓展域并查集,带权并查集这几种.</p><p>所有并查集的初始化都是初始爹都是自己.</p><p>并查集支持路径压缩和按秩合并两种合并方法.</p><p>在本博客中,记录爹的数组一律叫ko,是为了纪念橙王.</p><p><img src="https://static.wikia.nocookie.net/animatorvsanimation/images/7/73/OrangeNoCrown.png/revision/latest?cb=20240617165159" alt="橙王,图炸了请联系笔者更换" title="老父亲了"></p><h1>路径压缩</h1><p>由于路径压缩是查询的时候顺带压缩了一下,时间复杂度比较玄学,但是肯定比 $O(\log n)$ 要低,因为他相较于可持久化并查集牺牲了回溯的功能,也就是说查找的时候可能会修改好多好多东西(压缩路径嘛).</p><h1>按秩合并</h1><p>并查集的另一种合并操作就是按秩合并,这样的并查集会因为一个size而控制树高不会超过 $\log n$ 的高度.</p><p>而且,这样的合并是一开始就写好固定了的,也就是支持可持久化(使用主席树维护即可)</p><h2 id="普通并查集">普通并查集</h2><p>一个人的爹变成另一个人.用于检查某些元素在不在一个集合里面.</p><p>并查集支持维护区间,用法是一段序列的头和更靠右的合并,保证区间末尾一定是并查集的头,这样可以保证时间复杂度O(n),因为每一个数最多被合并一次.</p><h2 id="拓展域并查集-种类并查集">拓展域并查集(种类并查集)</h2><p>就是有两个及以上的并查集一起操作.比如,要求原有朋友关系的基础上添加一种新关系叫敌人关系,满足&quot;敌人的敌人是朋友&quot;,就可以拓展一个并查集,开到二倍空间.</p><p>实战就是,假设A和B是敌人,就合并A+n和B+n,假如B原先有敌人了那就合并朋友一个人和他敌人的敌人.</p><p>敌人本质上还是一个并查集.</p><h2 id="带权并查集">带权并查集</h2><p>并查集加个权重.比较灵活,维护的东西也比较多变,不好讲.</p><p>举例:给哪个学生比哪个学生多考几分,问谁和谁之间的分数差,就可以维护并查集叶节点和根节点的分数差关系.</p><h2 id="实战">实战</h2><ol><li>p5937,维护一个01组成的序列,给定一个区间,请你判断以下话语的正确性.如(1 2 odd 3 4 even)给定区间首尾.</li></ol><blockquote><p>对于区间的题考虑如下转化:<br>区间[l,r]可以转化为区间[0,l-1]和区间[0,r]的性质.<br>然后再由于奇偶性的传递可以维护一个种类并查集.</p></blockquote><ol start="2"><li>NOI食物链问题:</li></ol><blockquote><p>维护三个并查集，表达的是吃与被吃的关系.<br>如何表达他们是同级的呢？A不吃B而且B不吃A，或者直接查他们是不是一个集合<br>如何表达吃的关系呢？直接维护并查集，A吃B抽象成A的上级就是B+n(不同群系，不同并查集)<br>这样就得到了一个循环的样子：群系ABC三个并查集，同级就直接合并<br>吃的关系就opt1合并opt2+mxx表示A群系的opt1和opt2+mxx是一级的，由于opt2+mxx是B群系所以体现了opt1吃opt2<br>注意初始化并查集直接原数存就好<br>注意先判断是不是真话再合并防止出现环的情况</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数论分块</title>
      <link href="/2024/07/11/%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/"/>
      <url>/2024/07/11/%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>数论分块是简单的结论,这里相较于OIWiki上的叙述补充点东西.</p><h2 id="数论分块">数论分块</h2><p>结论:对于区间lr,满足 $\lfloor\frac nx\rfloor$ 的最大区间边界是<br>$$\Big\lfloor\frac n{\lfloor\frac nx\rfloor}\Big\rfloor$$<br>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    r=n/(n/l);</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是 $O(\sqrt n)$ .</p><h2 id="多次分块">多次分块</h2><p>有的时候要处理诸如 $\lfloor\frac nx\rfloor\lfloor\frac mx\rfloor$ 的两个都需要分块的式子.这个时候代码怎么写?很简单.如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=<span class="built_in">min</span>(n,m);l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    r=<span class="built_in">min</span>(n/(n/l),m/(m/l));</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实就是一段一段的划分更细了.其时间复杂度是 $O(\sqrt n+\sqrt m)$ .</p><p>(本篇文章知识点极其简单,因为有一个人写的二次分块代码是这样,又难写又难调:)</p><blockquote><p>声明:以下代码是相对错误示例,太难调了</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l1=<span class="number">1</span>,r1,l1&lt;=<span class="built_in">min</span>(n,m);l1=r1+<span class="number">1</span>)&#123;</span><br><span class="line">    r1=n/(n/l1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l2=l1,r2,l2&lt;=r1;l2=r2+<span class="number">1</span>)&#123;</span><br><span class="line">        r2=m/(m/l1);<span class="comment">//其实这里错了,因为r2有可能越界</span></span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NumberTheory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫比乌斯反演</title>
      <link href="/2024/07/07/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
      <url>/2024/07/07/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
      
        <content type="html"><![CDATA[<p>本篇学习著名莫比乌斯反演的应用以及卷积式子的转化.</p><h2 id="积性函数">积性函数</h2><p>先了解以下卷积以及积性函数的定义:数论中的卷积默认是狄利克雷卷积,写作$*$,星号夹在两个函数中间.常见的积性函数有:</p><p>单位函数 $\varepsilon(n)=[n=1]$ ,完全积性<br>恒等函数 $\mathrm{id}<em>k(n)=n^k$ ,完全积性<br>常数函数 $1(n)=1$ ,完全积性<br>欧拉函数 $\varphi(n)=\sum</em>{i=1}^n[\gcd(i,n)=1]$ 也就是小于等于n和n互质的数的个数<br>除数函数 $\sigma_k(n)=\sum_{d|n}d^k$ ,其中 $\sigma_0$ 经常记作 $d$ 或 $\tau$ ,$\sigma_1$经常记作$\sigma$ .<br>莫比乌斯函数 $\mu(n)=\begin{cases}1&amp;n=1\0&amp;\exist d&gt;1,d^2|n\(-1)^{\omega(n)}&amp;otherwise\end{cases}$ ,是加性函数<br>(人话就是说,1是1,有完全平方数就是0,否则就是按照积性函数-1之间相乘.)<br>$\omega(n)$ 表示n的本质不同质因子个数</p><p>(加性函数,指满足 $f(ab)=f(a)+f(b)$ 的函数)</p><p>积性函数推广:假如fg是积性函数,以下也都是积性函数:<br>$$f(x^p)\qquad f^p(x)\qquad f(x)g(x)\qquad f(x)*g(x)$$</p><h2 id="狄利克雷卷积">狄利克雷卷积</h2><p>对于两个数论函数fg,定义其结果h<br>$$h(x)=\sum_{d|x}f(d)g(\frac xd)=\sum_{ab=x}f(a)g(b)$$<br>即为<br>$$h=f*g$$</p><blockquote><p>性质:交换律结合律分配律.有一个特殊点的:<br>$f=g$ 和 $f<em>h=g</em>h$ 是充要条件,其中 $h(1)\neq0$ .</p></blockquote><p><strong>高维前缀和</strong>:铺垫一下,优化有用.高位前缀和就是状压dp,用于快速求解集合及其子集和.</p><p>可以对这道题中的模型进行抽象化,即:对于任意数论函数f,积性函数g,在 $O(n\log\log n)$ 的时间复杂度内求出狄利克雷卷积h.</p><p>将每个质数视为一个维度,则狄利克雷卷积就是一个带系数的高维前缀和,考虑分别处理每一个维度 $p_i$ ,每个 $p_k$ 都是一个物品,每个物品只转移一次,所以是一个01背包(DP统计所有方案的价值总和).物品 $p_k$ 的体积为 $p_k$ (这里总体积是每个物品的体积相乘),价值为 $g(p_k)$ (价值也相乘).</p><h3 id="常见卷积式子">常见卷积式子:</h3><p>$$\mathrm{id}<em>\mu=\varphi$$<br>$$\varphi</em>1=\mathrm{id}$$<br>$$\mu<em>1=\varepsilon$$<br>$$1</em>1=\mathrm{d}$$<br>$$\mathrm d*\mu=1*\varepsilon=1$$</p><h3 id="关于-mathrm-d-的高阶推导">关于 $\mathrm d$ 的高阶推导</h3><p>二元<br>$$\mathrm d(AB)=\sum_{i|A}\sum_{j|B}[\gcd(i,j)=1]$$<br>三元<br>$$\mathrm d(ABC)=\sum_{i|A}\sum_{j|B}\sum_{k|C}[\gcd(i,j)=1][\gcd(j,k)=1][\gcd(i,k)=1]$$<br>n维二元<br>$$\sigma^k(AB)=\sum_{i|A}\sum_{j|B}<a href="ij">\gcd(i,\frac Bj)=1</a>^k$$<br>n维三元<br>$$\sigma^k(ABC)=\sum_{i|A}\sum_{j|B}\sum_{l|C}[\gcd(i,\frac Bj)=1][\gcd(i,\frac Cl)=1]<a href="ijl">\gcd(j,\frac Cl)=1</a>^k$$</p><h2 id="并不-快乐的导式子时间">(并不)快乐的导式子时间</h2><p>常见技巧:变换枚举变量,在类欧几里得算法的时候也会用到.有点像二重积分三重积分那里使用一个变量去反卡另一个变量的值域,这个比较难说清,自己做题理解一下.</p><p>常用公式:<br>$$[\gcd(i,j)=k]=[\gcd(\frac ik,\frac jk)=1]$$</p><ul><li>反演结论1:<br>$$[\gcd(i,j)=1]=\sum_{d|\gcd(i,j)}\mu(d)$$</li><li>结论2: 若 $f(n)=(1<em>g)(n)$ ,则 $g(n)=(\mu</em>f)(n)$ .</li><li>结论3:(1~n中与n互质的数的和是这个)<br>$$\sum_{i=1}^{d}i[\gcd(i,d)=1]=\frac{\varphi(d)d}2$$</li></ul><blockquote><p>结论3的证明:<br>与d互质的数成对出现.<br>若id互质则有d-i与d互质<br>这样的数有$\frac{\varphi(d)d}2$对.</p></blockquote><h2 id="例题">例题</h2><ol><li>求<br>$$\begin{aligned}&amp;\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)\=&amp;\sum_{i=1}^n\sum_{j=1}^n\sum_{d|\gcd(i,j)}\varphi(d)\=&amp;\sum_{i=1}^n\sum_{j=1}^n\sum_{d|i,j}\varphi(d)\=&amp;\sum_{d=1}^n\Big\lfloor\frac nd\Big\rfloor^2\varphi(d)\end{aligned}$$</li></ol><blockquote><p>第一步:一个数等于其因子的欧拉函数和,也就是 $\varphi=1*\mathrm{id}$ .<br>第二步:d如果是gcd的因子,则d一定同时是ij的因子.<br>第三步:改变枚举变量,先枚举d,考虑ij对于式子的贡献(这么想,假如d是d,i和j都可以是k*d,所以最大就是有 $\lfloor\frac nd\rfloor$ 个贡献,也就是这么多的 $\varphi(d)$ ,同时注意到后面式子完全和ij没关系了,放心转化即可.)</p></blockquote><ol start="2"><li>求<br>$$\begin{aligned}&amp;\sum_{i=1}^n\sum_{j=1}^m\gcd(i,j)\=&amp;\sum_{k=1}^{\min(m,n)}\sum_{i=1}^n\sum_{j=1}^mk[\gcd(i,j)=k]\=&amp;\sum_{k=1}^{\min(m,n)}\sum_{i=1}^n\sum_{j=1}^mk[\gcd(\frac ik,\frac jk)=1]\=&amp;\sum_{k=1}^{\min(m,n)}\sum_{i=1}^{\lfloor\frac nk\rfloor}\sum_{j=1}^{\lfloor\frac mk\rfloor}k[\gcd(i,j)=1]\=&amp;\sum_{k=1}^{\min(m,n)}k\sum_{i=1}^{\lfloor\frac nk\rfloor}\sum_{j=1}^{\lfloor\frac mk\rfloor}\sum_{d|\gcd(i,j)}\mu(d)\=&amp;\sum_{k=1}^{\min}k\sum_{d=1}^{\min}\mu(d)\Big\lfloor\frac n{kd}\Big\rfloor\Big\lfloor\frac m{kd}\Big\rfloor\=&amp;\sum_{T=1}^{\min}\Big\lfloor\frac n{T}\Big\rfloor\Big\lfloor\frac m{T}\Big\rfloor\sum_{k|T}k\mu(\frac Tk)\=&amp;\sum_{T=1}^{\min}\Big\lfloor\frac n{T}\Big\rfloor\Big\lfloor\frac m{T}\Big\rfloor\varphi(T)\end{aligned}$$</li></ol><blockquote><p>前三步是正常的推式子.<br>第四步上了反演结论.<br>第五步更换枚举变量消掉了两个 $\sum$ .<br>第六步使用T=kd代换,发现式子中的卷积关系.<br>第七步使用家喻户晓的 $\varphi=\mu*\mathrm{id}$ .</p></blockquote><ol start="3"><li>求<br>$$\begin{aligned}&amp;\sum_{i=1}^n\sum_{j=1}^m\mathrm{lcm}(i,j)\=&amp;\sum_{i=1}^n\sum_{j=1}^m\frac{ij}{\gcd(i,j)}\=&amp;\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^{\min}\frac{ij}{k}[\gcd(i,j)=k]\=&amp;\sum_{k=1}^{\min}\sum_{i=1}^{\lfloor\frac nk\rfloor}\sum_{j=1}^{\lfloor\frac mk\rfloor}ijk[\gcd(i,j)=1]\=&amp;\sum_{k=1}^{\min}\sum_{i=1}^{\lfloor\frac nk\rfloor}\sum_{j=1}^{\lfloor\frac mk\rfloor}ijk\sum_{d|\gcd(i,j)}\mu(d)\=&amp;\sum_{k=1}^{\min}k\sum_{d=1}^{\min(\lfloor\frac nk\rfloor,\lfloor\frac mk\rfloor)}d^2\mu(d)\sum_{i=1}^{\lfloor\frac n{kd}\rfloor}i\sum_{j=1}^{\lfloor\frac m{kd}\rfloor}j\=&amp;\sum_{T=1}^{\min}T\sum_{d|T}d\mu(d)\sum_{i=1}^{\lfloor\frac nT\rfloor}i\sum_{j=1}^{\lfloor\frac mT\rfloor}j\end{aligned}$$</li></ol><blockquote><p>前两步正常化卷积式子.<br>第三步特别注意,因为ij除以k,所以后面要乘上一个k.<br>第四步反演结论.<br>第五步特别注意乘上$d^2$,因为枚举d的时候从1开始意味着ij还会发生值的变化.<br>第六步就是最终答案.使用方法就是,先证明T后面的函数是一个积性函数,然后线性筛算出来,T那一项直接前缀和算出来,最后两项是等差数列直接套公式求.</p></blockquote><ol start="4"><li>求<br>$$\begin{aligned}&amp;\sum_{i=1}^n\sum_{j=1}^md(ij)\=&amp;\sum_{i=1}^n\sum_{j=1}^m\sum_{x|i}\sum_{y|j}[\gcd(x,y)=1]\=&amp;\sum_{i=1}^n\sum_{j=1}^m\sum_{x|i}\sum_{y|j}\sum_{d|\gcd(x,y)}\mu(d)\=&amp;\sum_{i=1}^n\sum_{j=1}^m\sum_{x|i}\sum_{y|j}\sum_{d=1}^{\min}\mu(d)[d|\gcd(x,y)]\=&amp;\sum_{d=1}^{\min}\mu(d)\sum_{i=1}^n\sum_{j=1}^m\sum_{x|i}\sum_{y|j}[d|\gcd(x,y)]\=&amp;\sum_{d=1}^{\min}\mu(d)\sum_{i=1}^n\sum_{j=1}^m\Big\lfloor\frac ni\Big\rfloor\Big\lfloor\frac mj\Big\rfloor[d|\gcd(i,j)]\=&amp;\sum_{d=1}^{\min}\mu(d)\sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac md\rfloor}\Big\lfloor\frac n{id}\Big\rfloor\Big\lfloor\frac m{jd}\Big\rfloor\=&amp;\sum_{d=1}^{\min}\mu(d)\sum_{i=1}^{\lfloor\frac nd\rfloor}\Big\lfloor\frac n{id}\Big\rfloor\sum_{j=1}^{\lfloor\frac md\rfloor}\Big\lfloor\frac m{jd}\Big\rfloor\end{aligned}$$</li></ol><blockquote><p>第一步是约数公式.<br>第二步是莫反.<br>第三步把条件提出来,让d的条件变成区间.<br>第四步提出来 $\mu$ .<br>第五步考虑xy的贡献是这么多直接乘进去.<br>第六步是消掉最后条件的,方法为直接枚举di和dj.<br>第七步是最后整理式子,程序中可以数论分块解决(后面的 $f$ 可以 $O(n)$ 预处理).</p></blockquote><ol start="5"><li>求<br>$$\begin{aligned}&amp;\sum_{i=1}^n\mathrm{lcm}(i,n)\=&amp;n\sum_{d|n}\sum_{i=1}^n\frac id[\gcd(i,n)=d]\=&amp;n\sum_{d|n}\sum_{i=1}^{\frac nd}i[\gcd(i,\frac nd)=1]\=&amp;n\sum_{d|n}\sum_{i=1}^{d}i[\gcd(i,d)=1]\=&amp;n\sum_{d|n}\frac{\varphi(d)d}{2}\end{aligned}$$</li></ol><blockquote><p>第一步注意,因为n是固定的所以d不能从1开始,需要 $d|n$ .<br>第二步注意因为n是不变的,而i是变的,所以只需要乘一个n就可以.<br>第三步是因为,n|d,所以 $\frac nd\in d$ ,就有这个式子.<br>第四步就是结论3.</p></blockquote><ol start="6"><li>求(f()是斐波那契数列第几项)<br>$$\begin{aligned}&amp;\prod_{i=1}^n\prod_{j=1}^mf(\gcd(i,j))\=&amp;\prod_{k=1}^{\min}f(k)^{\sum_{i=1}^{\lfloor\frac nk\rfloor}\sum_{j=1}^{\lfloor\frac mk\rfloor}[\gcd(i,j)=1]}\=&amp;\prod_{k=1}^{\min}f(k)^{\sum_{i=1}^{\lfloor\frac nk\rfloor}\sum_{j=1}^{\lfloor\frac mk\rfloor}\sum_{e|\gcd(i,j)}\mu(e)}\=&amp;\prod_{k=1}^{\min}f(k)^{\sum_{e=1}^{\min(\lfloor\frac nk\rfloor,\lfloor\frac mk\rfloor)}\mu(e)\lfloor\frac n{ke}\rfloor\lfloor\frac m{ke}\rfloor}\=&amp;\prod_{T=1}^{\min}\prod_{k|T}f(k)^{\mu(\frac Tk)\lfloor\frac n{T}\rfloor\lfloor\frac m{T}\rfloor}\=&amp;\prod_{T=1}^{\min}\Big(\prod_{k|T}f(k)^{\mu(\frac Tk)}\Big)^{\lfloor\frac n{T}\rfloor\lfloor\frac m{T}\rfloor}\end{aligned}$$</li></ol><blockquote><p>第一步考虑斐波那契数列每一项对于答案的贡献(乘几次).<br>第二,三步莫反.<br>第四步是想把e的范围提出来,于是令T=ke,把T范围(其实就是原先e的范围)写在最下面.<br>第五步是解决方法:括号里的式子只与T有关,与nm无关,可以预处理,然后快速幂算出来结果加上去就可以了.</p></blockquote><ol start="7"><li>求<br>$$\begin{aligned}&amp;\sum_{i=1}^n\sum_{j=1}^m\gcd(i,j)^k\=&amp;\sum_{i=1}^n\sum_{j=1}^m\Big(\sum_{d=1}^{\min} d[\gcd(i,j)=d]\Big)^k\=&amp;\sum_{d=1}^{\min}\sum_{i=1}^n\sum_{j=1}^md^k[\gcd(i,j)=d]\=&amp;\sum_{d=1}^{\min}d^k\sum_{x=1}^{\lfloor\frac{\min}d\rfloor}\mu(x)\Big\lfloor\frac n{dx}\Big\rfloor\Big\lfloor\frac m{dx}\Big\rfloor\=&amp;\sum_{T=1}^{\min}\Big\lfloor\frac n{T}\Big\rfloor\Big\lfloor\frac m{T}\Big\rfloor\sum_{d|T}d^k\mu(\frac Td)\end{aligned}$$<br>其中<br>$$\begin{aligned}f(n)=&amp;\sum_{d|T}d^k\mu(\frac Td)\=&amp;\prod_{p_i}f(p_i^{x_i})\=&amp;\prod_{p_i}(p_i^{x_i}\cdot\mu(1)+p_i^{k(x_i-1)}\cdot\mu(p_i))\=&amp;\prod_{p_i}p_i^{k(x_i-1)}(p_i^k-1)\end{aligned}$$</li></ol><p>或者这么写?<br>$$\begin{aligned}&amp;\sum_{i=1}^n\sum_{j=1}^m\gcd(i,j)^k\=&amp;\sum_{i=1}^n\sum_{j=1}^m\Big(\sum_{d=1}^{\min}d[\gcd(i,j)=d]\Big)^k\=&amp;\sum_{d=1}^{\min}\sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac md\rfloor}(d[\gcd(i,j)=1])^k\=&amp;\sum_{d=1}^{\min}\sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac md\rfloor}\Big(\sum_{e|\gcd(i,j)} d\mu(e)\Big)^k\=&amp;\sum_{d=1}^{\min}\sum_{e=1}^{\lfloor\frac{\min}{d}\rfloor}\sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac md\rfloor}( d\mu(e))^k\=&amp;\sum_{d=1}^{\min}\sum_{e=1}^{\lfloor\frac{\min}{d}\rfloor}\Big\lfloor\frac n{de}\Big\rfloor\Big\lfloor\frac m{de}\Big\rfloor(d\mu(e))^k\=&amp;\sum_{T=1}^{\min}\sum_{d|T}\Big\lfloor\frac n{T}\Big\rfloor\Big\lfloor\frac m{T}\Big\rfloor(d\mu(\frac Td))^k\=&amp;\sum_{T=1}^{\min}\sum_{d|T}\Big\lfloor\frac n{T}\Big\rfloor\Big\lfloor\frac m{T}\Big\rfloor\varphi^k(d)\end{aligned}$$</p><blockquote><p>第一步是常见展开环节.<br>第二步是把次方乘进去(注意不要认为就是例1的phi的次方)<br>第三步是莫反.<br>第四步是令T=dx,代换进去.<br>最后的式子左边是积性函数,也就直接线筛处理了,复杂度 $O(n+T\sqrt n)$ .</p></blockquote><p>8.计算<br>$$\begin{aligned}&amp;\sum_{i=1}^n\sum_{j=1}^m\mathrm d(i)\mathrm d(j)\mathrm d(\gcd(i,j))\=&amp;\sum_{k=1}^{\min}\mathrm d(k)\sum_{i=1}^n\sum_{j=1}^m\mathrm d(i)\mathrm d(j)[\gcd(i,j)=k]\=&amp;\sum_{k=1}^{\min}\mathrm d(k)\sum_{i=1}^{\lfloor\frac nk\rfloor}\sum_{j=1}^{\lfloor\frac mk\rfloor}\mathrm d(ik)\mathrm d(jk)[\gcd(i,j)=1]\=&amp;\sum_{k=1}^{\min}\mathrm d(k)\sum_{e|\gcd(i,j)}\mu(e)\sum_{i=1}^{\lfloor\frac nk\rfloor}\sum_{j=1}^{\lfloor\frac mk\rfloor}\mathrm d(ik)\mathrm d(jk)\=&amp;\sum_{T=1}^{\min}\mathrm d(k)\mu(\frac Tk)\sum_{i=1}^{\lfloor\frac nT\rfloor}\sum_{j=1}^{\lfloor\frac mT\rfloor}\mathrm d(iT)\mathrm d(jT)\=&amp;\sum_{T=1}^{\min}\sum_{i=1}^{\lfloor\frac nT\rfloor}\mathrm d(iT)\sum_{j=1}^{\lfloor\frac mT\rfloor}\mathrm d(jT)\end{aligned}$$</p><blockquote><p>第一步是枚举gcd.<br>第二步是除一个d.<br>第三步是莫反.<br>第四步是套路替换.<br>第五步是因为 $d*\mu=1$ ,直接消掉了.</p></blockquote><ol start="9"><li>计算<br>$$\begin{aligned}&amp;\sum_{i=1}^{N}\sum_{j=1}^{N}\sum_{p=1}^{\lfloor\frac Nj\rfloor}\sum_{q=1}^{\lfloor\frac Nj\rfloor}[\gcd(i,j)=1][\gcd(p,q)=1]\=&amp;\sum_{i=1}^{N}\sum_{j=1}^{N}\sum_{p=1}^{N}\sum_{q=1}^{N}[\gcd(i,j)=1][\gcd(p,q)=j]\=&amp;\sum_{i=1}^{N}\sum_{p=1}^{N}\sum_{q=1}^{N}[\gcd(i,p,q)=1]\=&amp;\sum_{i=1}^{N}\sum_{p=1}^{N}\sum_{q=1}^{N}\sum_{d|\gcd(i,p,q)}\mu(d)\=&amp;\sum_{d=1}^N\sum_{i=1}^{\lfloor\frac Nd\rfloor}\sum_{p=1}^{\lfloor\frac Nd\rfloor}\sum_{q=1}^{\lfloor\frac Nd\rfloor}\mu(d)\=&amp;\sum_{d=1}^N\mu(d)\left\lfloor\frac Nd\right\rfloor^3\end{aligned}$$</li></ol><blockquote><p>我们发现把j带回去能得到更好的效果…<br>于是剩下的就简单了,基本上是板题.</p></blockquote><h2 id="一些比较牛逼的计算">一些比较牛逼的计算</h2><ol><li>欧拉函数的定义:p是质数,有<br>$$\varphi(j)=j\cdot\prod_{p|j}\frac{p-1}{p}$$</li><li>计算卷积 $\mathrm{id}<em>\varphi$ :<a href="https://www.cnblogs.com/PinkRabbit/p/8278728.html">摆结论</a>,由于直接分解即可,是 $O(\sqrt n)$ :<br>$$n=p_1^{b_1}p_2^{b_2}…p_k^{b_k}$$<br>$$\mathrm{id}</em>\varphi(n)=n\prod_{i=1}^k\frac{b_ip_i-b_i+p_i}{p_i}$$<br>缺点:一般积性函数计算,数论底子不扎实,化卷积式子(见题太少,紫题不满足需求了,建议来点黑的).</li></ol>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> NumberTheory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的测试以及更换工作</title>
      <link href="/2024/06/30/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%B5%8B%E8%AF%95%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%8D%A2%E5%B7%A5%E4%BD%9C/"/>
      <url>/2024/06/30/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%B5%8B%E8%AF%95%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%8D%A2%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>首先是网页测试:</p><h1>这是一级标题</h1><h2 id="这是二级标题">这是二级标题</h2><h3 id="这是三级标题">这是三级标题</h3><h4 id="这是四级标题">这是四级标题</h4><h5 id="这是五级标题">这是五级标题</h5><h6 id="这是六级标题">这是六级标题</h6><p><strong>这是粗体</strong></p><p><em>这是斜体</em></p><p><s>这是删除</s></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">114514</span></span><br></pre></td></tr></table></figure><blockquote><p>???</p><blockquote><p>???</p></blockquote></blockquote><table><thead><tr><th style="text-align:left">表格测试</th><th style="text-align:left">1</th><th style="text-align:left">2</th></tr></thead><tbody><tr><td style="text-align:left">3</td><td style="text-align:left">4</td><td style="text-align:left">5</td></tr></tbody></table><p>无序列表</p><ul><li>114514</li><li>114514</li><li>114514</li></ul><p>有序列表</p><ol><li>114514</li><li>114514</li><li>114514</li></ol><p><a href="https://jlu.edu.cn">链接</a></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/b55lh2jd.png" alt="云盘图炸了" title="流萤酱真可爱"></p><p>换行</p><hr><h1>最后笔者要做的更换</h1><p>洛谷的LaTeX编辑器和Flu博客用的不太一样,需要对语法稍加改变.</p><ol><li>MarkDown的代码结束,从<code>`````</code>变成<code>```</code></li><li>LaTeX的换行从<code>\\</code>改成<code>\\\</code></li><li>LaTeX的粗体从<code>\bold</code>改成<code>\mathbf</code></li><li>LaTeX的无穷从<code>\infin</code>改成<code>\infty</code></li></ol><h2 id="一点提示">一点提示</h2><p>常见LaTeX代码:(最后面那个是空格)<br>$$\ge,\le,\perp,\approx,\sim,\pm,\quad,$$</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\ge</span>,<span class="keyword">\le</span>,<span class="keyword">\perp</span>,<span class="keyword">\approx</span>,<span class="keyword">\sim</span>,<span class="keyword">\pm</span>,<span class="keyword">\quad</span>,</span><br></pre></td></tr></table></figure><p>常见LaTeX字体:(最后那个是默认的)<br>$$\texttt{LOrem},\textsf{LOrem},\textrm{LOrem}\\mathbb{LOrem},\mathcal{LOrem},\mathscr{LOrem},\mathfrak{LOrem},\\mathrm{LOrem},\mathbf{LOrem},LOrem$$</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\texttt</span>,<span class="keyword">\textsf</span>,<span class="keyword">\textrm</span></span><br><span class="line"><span class="keyword">\mathbb</span>,<span class="keyword">\mathcal</span>,<span class="keyword">\mathscr</span>,<span class="keyword">\mathfrak</span></span><br><span class="line"><span class="keyword">\mathrm</span>,<span class="keyword">\mathbf</span>,默认</span><br></pre></td></tr></table></figure><h2 id="标签制定">标签制定</h2><p>那就这样吧,大科目可以写学习笔记,小科目(比如莫比乌斯反演)不用写学习笔记.</p><p>tag是标签,一个文章可以有很多个标签.目前的标签有:</p><p>Contest:竞赛特有标签.<br>C++:万恶之源.<br>Algorithm:算法标签.<br>NumberTheory:数论标签.<br>OTH:太小众了,不知道分到哪个,或者纯纯工具的网页.<br>Physics:大物的特有标签.<br>Python:爬虫.</p><p>category是分类,一个文章只能有一个分类.目前的分类有:(将来可能会出像OIWiki一样的数据结构分类啊分类啊啥的)</p><p>DataStructure:数据结构标签.<br>Math:数学分类.<br>OTH:其他分类.<br>Graph&amp;Network:图论.<br>MachineLearn:机器学习.</p><h2 id="不常用但是还会用到的部分LaTeX">不常用但是还会用到的部分LaTeX</h2><p>数论<br>$\equiv$ <code>\equiv</code><br>$\prod$ <code>\prod</code><br>$\ge$ <code>\ge</code><br>$\le$ <code>\le</code><br>$\binom{114}{514}$ <code>\binom&#123;114&#125;&#123;514&#125;</code></p><p>离散<br>$\cup$ <code>\cup</code><br>$\cap$ <code>\cap</code><br>$\land$ <code>\land</code><br>$\lor$ <code>\lor</code><br>$\exist$ <code>\exist</code><br>$\forall$ <code>\forall</code></p>]]></content>
      
      
      <categories>
          
          <category> OTH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OTH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象程序设计A学习笔记</title>
      <link href="/2024/06/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/06/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>写在前面:OI打的好不等于这堂课不用认真学.OI是面向过程设计,搞出答案就完了,这个则是封装啊啥的一堆东西.OI确实可以让人灵活运用各种语法,但是这个$class$用法很多,都要认真看.</strong></p><p>程序=(算法+数据结构)s,使用对象框架组装程序.说白了就是,时代变了,有$MONEY$了,撑得起更大的程序了,不面向过程了,有对象了(雾)…</p><p>好像一个学期就只学了一个$class$的用法,有<strong>封装,继承,多态</strong>,这是三个基本特征.</p><p><strong>类与对象</strong>:类($class$)只是一个空的框架,对象是由类衍生出来的.它和结构体($struct$)的区别有以下三点:<br><strong>1.它有权限划分</strong>.这就是接下来会讲的$public,private,protected$.<br><strong>2.它有全局变量</strong>.就是那个$static$,虽然笔者不知道这玩意有啥用…反正$class$它就是有.<br><strong>3.它有合构析构函数</strong>,更方便用了.</p><p>$\mathbf{public,private,protected}$三种属性:$public$是所有人都能访问的,$private$和$protected$都是对象内部随便访问,对象外不可访问的,这俩的区别在继承(往下)那里会有介绍.默认啥也不写就是$private$,在碰到下一个标志前都是这个权限.</p><p>$\mathbf{static}$关键字:静态成员,静态函数.用法就是和$inline,register$一样,加在函数或者变量名前就好.$static$的作用是让函数或变量变成静态的,就是全局变量,想象一个学生对象,老师就是静态的,学生一届又一届,但是老师不变(排除特殊状况),老师就是静态的.老师根本不认识对象,只知道有多少个学生,学生去哪了被销毁了和老师没关系,大概这个意思.<strong>注意</strong>静态变量使用前记得先分配内存.举例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">node</span>()&#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">node</span>()&#123;</span><br><span class="line">cnt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prr</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> node::cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">node a;</span><br><span class="line">a.<span class="built_in">prr</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那句$cnt$声明删了会出错,因为没分配内存.$static$修变量的作用主要有以下三点:<br><strong>1.</strong> 流动统计.实时统计当前开了多少个对象.<br><strong>2.</strong> 作为标记符,代表特定的事件是否发生,比如磁盘读写,同时只能有一个读写磁盘,就用标记表示.<br><strong>3.</strong> 链表头指针或尾指针.</p><p><strong>类名遮挡</strong>:就是名字重了咋办的意思.类名允许和变量名一致,每次需要使用变量时就直接用,用到同名类时就加$class\space name$即可.同理函数中的变量名可以与类中的变量名重,使用的时候加上$::$即可.</p><p><strong>合构函数,析构函数</strong>:类新建成员初始化会调用的函数,成员被delete时调用的函数.新建一个对象默认会分配一个合构函数和一个析构函数,但是他们什么也不做,通过自己写合适的函数实现合理的初始化.<br>格式:与类同名,没返回值(初始化要什么返回值),析构就加一个~即可.<br><strong>注意</strong>系统在编译阶段检查到你写了合构或者析构之后默认的啥也不做合构或者析构函数会消失,也就是说你要是想合构函数传参的话记得写默认的情况,省的运行出错.下面是一个简简单单的示例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">node</span>(<span class="type">int</span> val)&#123;</span><br><span class="line">a=<span class="number">10</span>;</span><br><span class="line">b=val;</span><br><span class="line">c=<span class="number">0</span>;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">node</span>(<span class="type">int</span> val,<span class="type">int</span> vval,<span class="type">int</span> vvval)&#123;</span><br><span class="line">a=val;</span><br><span class="line">b=vval;</span><br><span class="line">c=vvval;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">node</span>()&#123;</span><br><span class="line">cnt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prr</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,cnt,a,b,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> node::cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">node <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">node <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">a.<span class="built_in">prr</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>::</strong> 类外可以写函数.方法对是类内声明,类外写$xx::xx(xx){xx}$函数即可写函数.类直接访问成员都是$::$,指针访问类成员用$-&gt;$,一个声明过的对象的直接调用就$.$就行了.</p><p><strong>默认值</strong>:函数在声明时候传参可以这样:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ko</span><span class="params">(<span class="type">int</span> val=<span class="number">10</span>,<span class="type">int</span> num=<span class="number">20</span>)</span></span>&#123;xx&#125;</span><br></pre></td></tr></table></figure><p>这样做的意思是,如果调用这个函数时缺少参数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">koi=<span class="built_in">ko</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>然后第一个数就会被调用的传参顶掉,第二个参数由于少会使用20这个默认值.注意缺省参数只能在后面缺,前面(比方说下面这个就是错的)缺参数系统不给过:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">koi=<span class="built_in">ko</span>(,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>类之间的关系</strong>:互不干涉内政.比如我需要一个学生类,学生里面套一个学生ID的类,此时声明一个学生会优先调用套娃里面的ID合构函数,然后再调用套娃外面的学生的构造函数,自动调用的,不用管.<br>但是这导致一个问题.我希望<strong>给ID传参</strong>该咋办呢?在学生的合构函数不能调用ID的合构函数,因为不能干涉内政,但是如果新建一个ID会直接在合构函数运行之后销毁掉(函数内部声明变量开的栈区空间),咋子办?</p><p>新语法来了,专门解决这个问题的(如果有好多个对象就逗号隔开,像下面一样).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Student</span>(<span class="type">int</span> a=<span class="number">10</span>,<span class="type">int</span> b=<span class="number">10</span>):<span class="built_in">ID</span>(b),<span class="built_in">xx</span>(xx)&#123;xx&#125;</span><br></pre></td></tr></table></figure><p>这个冒号后面括号前面的就是对ID先进行初始化,然后再对主的学生对象进行合构的体现.如果不写冒号以及后面的合构函数,就会调用默认无参数的合构函数.</p><p><strong>新.天.地</strong>:这个冒号很灵性啊,就可以对常量数据成员和引用数据成员进行初始化.比方说下面一段代码就初始化了一个常量和一个引用成员.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ko</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ko</span>(<span class="type">int</span> val):<span class="built_in">op</span>(<span class="number">114514</span>),<span class="built_in">ip</span>(val)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> op;</span><br><span class="line"><span class="type">int</span> &amp;ip;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n=<span class="number">114</span>;</span><br><span class="line"><span class="function">ko <span class="title">aaa</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造对象的顺序</strong>:以下几点:<br><strong>1.</strong> 局部和静态对象按照声明顺序构造(函数中新建一个变量)<br><strong>2.</strong> 静态对象只被构造一次<br><strong>3.</strong> 全局对象都在$main$之前进行构造<br><strong>4.</strong> 全局对象构造时无特殊顺序<br><strong>5. 成员以其在类中的声明顺序构造</strong>:解释一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ko</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ko</span>(<span class="type">int</span> val):<span class="built_in">b</span>(val),<span class="built_in">a</span>(b+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">ko <span class="title">a</span><span class="params">(<span class="number">114</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">858993459</span> <span class="number">114</span></span><br></pre></td></tr></table></figure><p>这份码因为最底下$ab$顺序导致调用合构函数时顺序变化,产生了野值.</p><p><strong>重载运算符</strong>:这里主要讲$++$和$–$的运算.你是否想过如何重载$a++$?这里就会有介绍.<br>首先,大家都知道的,<strong>内部类型不允许重载</strong>,比方说$int$.这个很好理解,这玩意要让你搞了$C++$会大乱的.<br>然后是操作数变不了,还有几个诸如$-&gt;$,$?:$,$::$,$.$,$@$(新运算符)不允许重载之类的规定.<br>如下就是一个简单的码,其中重载了自加:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ko</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ko</span>(<span class="type">int</span> val=<span class="number">10</span>,<span class="type">int</span> vval=<span class="number">10</span>):<span class="built_in">b</span>(val),<span class="built_in">a</span>(vval)&#123;&#125;</span><br><span class="line">~<span class="built_in">ko</span>()&#123;&#125;</span><br><span class="line">ko&amp; <span class="keyword">operator</span> ++()&#123;</span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">ko <span class="keyword">operator</span> ++(<span class="type">int</span>)&#123;</span><br><span class="line"><span class="function">ko <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prr</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">ko <span class="title">a</span><span class="params">(<span class="number">4</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">(a++).<span class="built_in">prr</span>();</span><br><span class="line">(++a).<span class="built_in">prr</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是自加,$C++$约定区别在于一个$int$.</p><p>$\mathbf{new,delete}$:为什么我们需要它?<br>原因很简单,分配空间的时候,$new$会调用合构函数,而$delete$的时候又会调用析构函数.也就是说,不常用的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>其实是一个调用合构函数的过程.原来是这么回事.</p><p><strong>拷贝构造函数</strong>:为了防止乱用$=$导致权限分配或者数据分配混乱的问题,有了拷贝构造函数.一般传参传$&amp;$对象.<br><strong>注意</strong>:有的时候对象分配了资源(比如堆内存),拷贝直接复制地址是要出错的,所以自己写一个拷贝构造函数分配内存很有必要.</p><p><strong>无名对象</strong>:正如你所见,没名字的对象.这玩意有用,写作:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ko</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>用法有:<br><strong>1.</strong> 函数参数.假如函数传参要一个对象,就可以写一个无名对象顶上去.<br><strong>2.</strong> 初始化引用以及初始化对象定义.如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ko&amp; koi=<span class="built_in">ko</span>(<span class="number">10</span>);</span><br><span class="line">ko koip=<span class="built_in">ko</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><strong>C++的试探</strong>:大家都知道,在$C++$中,$5/2$和$5.0/2$是两个完全不一样的东西.$C++$知道如何把整数转成$double$,也知道计算结果.但是对于我们写的类,$C++$的格式转换要靠我们实现.<br>如何实现呢?就靠我们写的合构函数.<br>如下是一段$C++$进行格式转换的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS<span class="comment">//这句话的意思是在VS上使用strcpy这种不安全的函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ko</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ko</span>(<span class="type">const</span> <span class="type">char</span> arg[])&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(arr,arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prr</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,arr);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">ko</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> arr[<span class="number">30</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">koi</span><span class="params">(ko op)</span></span>&#123;</span><br><span class="line">op.<span class="built_in">prr</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">koi</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到,传参传一段字符串,自动匹配了一个合构函数,然后调用了,进行后续的运算($const\space char[\space]$和$char[\space]$不一样的,不然匹配不上).<br>$C++$有几点要求:<br><strong>1.</strong> 只会尝试有一个参数的合构函数<br><strong>2.</strong> 当有二义性时立即放弃尝试(比如,学生老师用一个打印函数,名字又是都有的部分,$C++$发现可以是老师也可以是学生,立刻退出了).</p><p>$\mathbf{friend}$:友元(杰哥)函数.有的时候普通函数也需要访问对象的保护成员(聴話,讓我康康!),为了加快效率.比如矩阵和向量的乘法,乘法的函数不可能同时是两个函数的成员,所以就让它是个普通函数,通过友元的联系来实现乘法.举个例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tsc</span>;<span class="comment">//这行的作用是让下面的friend中的prr认识tsc</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ko</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ko</span>()&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">num[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">prr</span><span class="params">(ko a,tsc b)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tsc</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">tsc</span>()&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">num[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">prr</span><span class="params">(ko a,tsc b)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prr</span><span class="params">(ko a,tsc b)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;++i)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a.num[i]+b.num[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ko a;</span><br><span class="line">tsc b;</span><br><span class="line"><span class="built_in">prr</span>(a,b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>友元函数除了对于标记友元的可以看他的赤酱外,就是个普通函数.一个类的成员可以是另一个类的友元,使用$::$选中函数,一个类也可以是另一个类的友元,直接$friend\space class\space name$.友元的第二个作用:方便重载操作符的使用.</p><p><strong>继承</strong>:就是在原有的状态上加点东西,让他变成一个新的类.比如,研究生在大学生基础上加点自己的东西.语法如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">yanjiusheng</span>:<span class="keyword">public</span> daxvesheng&#123;xx&#125;;</span><br></pre></td></tr></table></figure><p>继承有什么作用呢？<br><strong>1.</strong> 可以通过改一个小类来实现继承大类的修改,更方便维护.<br><strong>2.</strong> 继承可以让$C++$做隐式格式转换.比如函数要求传大学生的参,我传一个研究生的参,也是可以被接受的.如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tsc</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ko</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ko</span>()&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">num[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">prr</span><span class="params">(ko a)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tsc</span>:<span class="keyword">public</span> ko&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">tsc</span>()&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">num[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prr</span><span class="params">(ko a)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;++i)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a.num[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ko a;</span><br><span class="line">tsc b;</span><br><span class="line"><span class="built_in">prr</span>(a);</span><br><span class="line"><span class="built_in">prr</span>(b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承方式</strong>:在这里,$protected$和$private$会进行区分.<br>一个类作为基类(大学生)时,其$public$和$protected$都可以随便被派生类(研究生)任意访问和调用,但是$private$真的就是谁也用不了,除非声明友类.<br>看例子,冒号后面的$public\space ko$这个权限分给的是类之后的东西.假如改成$private$或者$protected$,下面的$prr(b)$就会报错,理由是成员不可访问.(反正就记住$private$最神秘就对了,严严实实的)<br>注意到例子中的$ko$和$tsc$都有名字叫$num$的数组,为什么不冲突?其实只要访问$ko$中的$num$数组时加个$ko::$就没问题了.</p><p><strong>调整访问控制</strong>:就是改权限.冒号后面加的权限因为是取高的很容易啥也不给看,就需要改权限.如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tsc</span>:<span class="keyword">public</span> ko&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> ko::num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这就把$tsc$派生类的$ko$中的$num$调成了公有了.</p><p>继承和组合的关系:略,一堆废话.</p><p>多继承:加逗号隔开,加权限即可.但是这个时候注意变量名字加$::$区分是源自哪里的.</p><p><strong>虚拟继承</strong>:加$virtual$.虚拟继承的含义是,如果没有该类就新建一个,如果有了就不用动了,用建好的那一个.比如,$victim$和天选和$tsc$(再临)都是$\mathbf{Alan\space Becker}$画的,但是再临拥有前两者的一切战力,怎么表示?代码如下:</p><p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.sEdp7C8oeRzmx3cKBM0yxQAAAA?rs=1&amp;pid=ImgDetMain" alt="炸了"><br>再临</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animation</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Running.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> atk;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">victim</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> animation&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rev</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Revenge.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">the_chosen_one</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> animation&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dam</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Crushing.Damaging.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">the_second_coming</span>:<span class="keyword">public</span> victim,<span class="keyword">public</span> the_chosen_one&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AN</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Drawing.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">the_second_coming a;</span><br><span class="line">a.<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样加$virtual$就会让再临只有一个$animation$了.</p><p><strong>注意</strong>:虚拟继承和虚拟函数是两个截然不同的概念.</p><p><strong>构造顺序</strong>:你学过成员里面套类,继承,虚拟,etc.<br>真的建一个类他们的顺序怎么办呢?为此规定:<br><strong>1.</strong> 虚拟先构造,顺序按照继承顺序<br><strong>2.</strong> 非虚拟的继承构造,按照继承顺序<br><strong>3.</strong> 成员对象<br><strong>4.</strong> 类自己的合构函数</p><p><strong>多态:若语言不支持多态,则不能被成为面向对象的语言.</strong></p><p>这里就会讲$virtual$的用法.比如,一个订单系统,分普通用户和$\mathbf{VIP}$用户,他们的买东西结算算法不太一样(打折),但是VIP除了打折好像也没啥不同了,我只想用一个函数实现计算,就需要用到虚函数.</p><p>$\mathbf{virtual}$:和$inline$一样,挂在函数的前面发挥作用.它的意思是迟后联编,说人话就是会覆盖,后面的同名函数会覆盖前面的函数,所以后面的函数加不加$virtual$其实没区别,只要前面加了就行了.比个例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">user</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">user</span>(<span class="type">int</span> val=<span class="number">998</span>)&#123;</span><br><span class="line">buy=val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> buy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> buy;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VIP</span>:<span class="keyword">public</span> user&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">VIP</span>(<span class="type">int</span> val=<span class="number">998</span>):<span class="built_in">user</span>(val)&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> buy/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">VIP <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a.<span class="built_in">calc</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个简单的VIP用户打折的程序,重写了$calc$让不同用户计算方式不同.</p><p><strong>失败的迟后联编</strong>:计算函数传参不同,返回值不同,etc所有不能被看成相同函数的情况.</p><p><strong>可返回不同类</strong>:B继承A的,函数有两个,一个返回值是A,一个返回B,这个时候就可以用$virtual$进行联编.</p><p><strong>虚函数的限制</strong>:众所周知,$C++$追求快.所以只会选择个别的函数整成虚函数,那么限制就来了:内联不可以,只有类的成员函数才可以,合构析构不可以,静态不可以.</p><p><strong>类的冗余</strong>:害,其实就是自己关系没导清,多整了几个变量…解决办法就是多开几个类包含以下就没事了…</p><p><strong>抽象类与纯虚函数</strong>:只要有至少一个纯虚函数,这个类就是抽象类.纯虚函数就是函数声明时后面加=0,前面加$virtual$.比如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">ko</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>首先注意,纯虚函数不可以实例化.也就是说括号后面大括号不能有.抽象类不可以实例对象,所以抽象类就是用来继承的,继承的子类重写那个纯虚函数,就完了,子类可以对象化.所以抽象类又被称作接口.</p><p><strong>为什么要抽象类</strong>?方便指针的使用.先前提到了,继承的情况下,派生类的指针完全可以当成母类的指针去用,因为成员是一样的.这里就是可以用抽象类指针传参,然后调用直接放上派生类的指针,$C++$会自己匹配的.</p><hr><h3 id="笔者最后追加的东西-分文件编写">笔者最后追加的东西:分文件编写</h3><p>太重要了,做课设几千行代码不分文件很难维护的(虽然笔者就是这样硬写的…QwQ),而且今天才发的通知要求作业分文件编写…啊总之我就是加了这么个东西,以飨($\mathbf{xi\check{a}ng}$)读者(老套话了).</p><p>那啥,现在你要写一个$Visual Studio$程序.人有五名,主文件有三个.</p><p>首先,要写好一个头文件.头文件一般是$.h$的格式.新建一个空项目,添加一个空项.</p><p>头文件的<strong>基本结构</strong>:会有详细注释的,放心看</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//name:function.h</span></span><br><span class="line"><span class="comment">//author:NaraFluorine</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once<span class="comment">//这句话的意思是防止头文件重复包含</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS<span class="comment">//安全问题,后面会讲到</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span><span class="comment">//在这里包含所有头文件名</span></span></span><br><span class="line"><span class="comment">//#include&lt;xxx&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FUNCTION_H<span class="comment">//如果没有定义这个,那就执行以下句子,还是防止头文件多次包含的</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNCTION_H<span class="comment">//定义这个,其实名字随便起的,一般大家都这么写</span></span></span><br><span class="line"><span class="comment">//头文件开始写了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> n;<span class="comment">//在function.cpp中定义的变量这里写成这个</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prr</span><span class="params">(<span class="type">int</span> num)</span></span>;<span class="comment">//在function.cpp中声明的函数这里写成这个</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">//头文件写完了结束了</span></span></span><br></pre></td></tr></table></figure><p>头文件对应的实现文件的<strong>基本结构</strong>(头文件就是画大饼的):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//name:function.cpp</span></span><br><span class="line"><span class="comment">//author:NaraFluorine</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;function.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prr</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;<span class="comment">//头文件只声明,没大括号,这里实现头文件的大饼</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主文件的<strong>基本结构</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//name:main.cpp</span></span><br><span class="line"><span class="comment">//author:NaraFluorine</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;function.h&quot;</span><span class="comment">//为什么不用尖角括号后面会讲</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n=<span class="number">114</span>;</span><br><span class="line"><span class="built_in">prr</span>(<span class="number">250</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好,这就完了.每个模块负责不同的函数,可以把大工程划分为一个一个小零件,一部分出错不需要整体重新编译.</p><p>有个部分忘写了,是$class$的用法,记住一个事情,$class$的声明都在头文件里面,然后函数就是正常的画大饼就好,但是对应的$cpp$要写成展开的,同时注意标清哪个$class$,比如下面的例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//poly.h节选</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">poly</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//poly.cpp节选</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poly::a</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//展开写函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后对于重载运算符实例化可以写在外面,但是记得两点不同,一是操作数记得整俩,二是记得声明友元,否则看不了内存(这是全局重载和成员重载的区别).</p><p><strong>问题解答</strong>:<br><strong>1.</strong> 安全问题:$VS$是不赞成你使用$scanf$和$printf$的,因为他们不安全.为什么不安全笔者不知道,反正$VS$不赞成你用,想用可以选择更安全的$scanf_s$,或者像笔者那样加上这句话就可以无视警告接着用.<br><strong>2.</strong> 关于$include$后面的&lt;&gt;“”:尖角和引号的差异在于优先搜索哪里.正常的使用尖角的情况是大家使用库文件的时候,就是那些众所周知的头文件,如$stdio.h$或者$algorithm$,系统看到尖角会优先搜索库文件.然后引号的意思是系统优先搜索该$.cpp$对应的文件夹找这个头文件,一般自己写头文件的会用引号包起来,当然你用引号包库文件也不会有错,使用引号包住功能实现良好的$.cpp$文件也能运行的.<br><strong>3.</strong> $VS$:$Microsoft\space Visual\space Studio$,简称$VS$,是一个编辑器.一般写大型项目会用到这个东西 <s>,比如我们组四千五百行的课设</s>.为什么要用$VS$而不是$Dev$,因为功能全.但是由于安全啊(上文)或者不让用$__int128$呀,编译慢啊(初次启动编译三十秒,后面一两秒出来)之类的,笔者自己学习算法还是喜欢用$Dev$.</p><p>好$\mathbf{tm}$长啊,我半个学期这是差了多少节课啊QwQ…</p><p>但是最起码我把几百页的书用一篇文章就讲完了,这是十分好学,一看就懂的.</p><p><strong>UPD20240609:</strong></p><h1>做题总结</h1><p>众所周知,学的和考试考的往往是两个东西.Flu收获不小(套话).</p><p><strong>C++内存分配</strong>:<a href="https://blog.csdn.net/weixin_48896613/article/details/127371045">算了,懒得写了,看这个吧</a></p><h1>面向对象Cache</h1><p>这里放一些做题碰到的一些问题,随着考试结束,这篇帖子也会结束.</p><p>C++多文件的好处不是能同时编译生成多个可执行文件.</p><p>执行a.f(100)成功时,f可能的参数表不可以是f(int&amp;),但是可以是f(const int&amp;)</p><p>protected方式下,派生类对象的指针不可以转换成基类指针.</p><p><strong>静态成员的初始化</strong>:</p><p>一个类不能实例化对象有哪几种情况:1抽象类2构造函数是私有的</p><p>静态成员函数没有this指针(所以不可以加virtual,const).</p><p>this指针是一个指针常量.(<code>const A*</code>)指向<strong>类对象</strong> 而不是<strong>类类型</strong>,小心,看清楚了</p><p><strong>友元</strong>:C++友元不具有传递性</p><p>某些运算符重载只能在类内实现:<code>= () [] -&gt;</code></p><p>const的作用:先向左匹配,左边没有东西才会向右匹配,如:<code>int* const p</code>表示一个常指针,而<code>const int* p</code>和<code>int const* p</code>表示都是一个指向常量的指针.</p><p>构造函数要么都有缺省值,要么都没有缺省值. 对</p><p><strong>内联函数</strong>:运行时插到每一个调用函数的地方.</p><p>抽象类通常也需要构造函数.</p><p><strong>常成员函数</strong>:可以被非常成员调用.</p><p><strong>常量对象</strong>:只可以调用类的常成员函数和静态成员函数,不可以调用非常成员函数.</p><p>不允许创建指向自身类型的常量指针和引用.(套娃的官方说法)</p><p>构造函数重载错误:<code>A();A(int=0,int=0);</code></p><p>耦合度:继承的耦合度高于组合,实战中应尽量选择组合而不是继承(也就是耦合度尽量低).</p><p>通过声明私有禁止乱拷贝,拷贝构造函数.</p><p><strong>虚表和虚指针</strong>:虚指针每个对象都有一个,但是虚表是每个类只有一个的东西(也可以有虚表组).</p><p><strong>虚基类</strong>:C++由于支持多重继承可能导致名字冲突,所以提供了这个.虚拟继承的基类就叫虚基类.</p><p><strong>虚函数访问</strong>:非虚非静可以访问虚函数.</p><p>接口:C++支持接口.</p><p>B b和B* pB两种格式作为类A的数据成员的区别:Bb是一般不需要拷贝构造函数的,而pB通常需要拷贝构造函数.pB的时候B可以是抽象类而Bb不可以是抽象类.</p><p><strong>关联,聚集关系</strong>:关联分为单向关联和双向关联,双向关联是A中有B,B中有A的这么一个关系,聚集可以理解为组合,代码上没有差异.</p><p><strong>封装</strong>:可以定义私有成员和保护成员.</p><p><strong>多态</strong>:面向对象语言中,接口的多种不同实现方式即为多态.多态性允许父对象被设置为和子对象相等的技术,赋值以后父对象可以根据当前赋值给子对象的特性以不同方式运作,允许子类将类型指针赋值给父类型指针.多态性在C++和Object Pascal中都是用虚函数实现的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fuck</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">b</span>:<span class="keyword">public</span> a&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fuck</span><span class="params">()</span><span class="keyword">override</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c</span>:<span class="keyword">public</span> a&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fuck</span><span class="params">()</span><span class="keyword">override</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">a *ppp=<span class="keyword">new</span> c;</span><br><span class="line">ppp-&gt;<span class="built_in">fuck</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态的真谛:声明一个大的,然后因为大的覆写抽象类了,</p><p>类中没虚函数就没虚表了吗?nonono,如果他的基类有,他还是会有虚表的.</p><p>private和protected的区别:继承后子类可见不可见的问题.</p><p>catch支持多态地捕获派生异常.异常可以本层处理也可以部分处理后向上层抛出.(类型不需要严格相同)异常可以在外层函数中捕获,也可以在当前函数中捕获.举例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;<span class="built_in">f</span>();&#125;<span class="built_in">catch</span>()&#123;&#125;</span><br></pre></td></tr></table></figure><p>如果f中没有try catch,f可以被catch捕获.</p><p>父子同名函数:1都不是虚函数2父不是虚函数子类是虚函数3都是虚函数</p><p><strong>函数占位参数</strong>:和默认值相反,占位参数只要出现必须填满.而且,正如其名,他只有类型没有名字,而且必须对应上,比个例子:<code>f(int,int k,int i=0)</code>这里的没名字int就叫占位参数,他只要出现就必须被填上,否则函数会匹配失败.这种占位的也可以有参数,比方说<code>int=0</code>之类的</p><p>内存:构造时new了好多内存是不算在类大小里面的.</p><p>成员函数:A以下情况不可以调用B:1A是静态函数B不是2A是常成员函数B不是</p><p><strong>函数重载</strong>:体会一下,必须<strong>完全一样</strong> 才能触发重载.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>)</span></span>;和<span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span>和<span class="type">int</span> <span class="title">f</span><span class="params">()</span><span class="type">const</span></span></span><br></pre></td></tr></table></figure><p>不会构成二义性,会构成重载.判断依据:参数个数,参数类型,参数顺序,函数是否为const.</p><p><strong>基类的成员函数可以和派生类重名,但是数据成员不可以重名</strong></p><p>抽象类的基类也是抽象类.</p><p>如何避免A外再派生其他类:同时满足:A的构造函数正常public写,然后A的析构函数设置成私有而且不进行实现(或者设置成纯虚函数)可以防止其他类从A派生.</p><p><strong>初始化列表</strong>:其实就是那个:a(),b(){}这个部分.有四种情况:1常量2引用3基类缺少无参数构造函数4类套类需要传参的情况.5其他需要在类初始化之前就需要初始化的情况.</p><p>前加加:<code>A&amp; operator ++()&#123;&#125;</code>后加加<code>A&amp; operator ++(int)&#123;&#125;</code>区别在于一个int.<br>顺带提一嘴,所有的operator返回值参考:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span>&#123;</span><br><span class="line"><span class="type">int</span> dat;</span><br><span class="line">a <span class="keyword">operator</span> +(a&amp; io);</span><br><span class="line">a <span class="keyword">operator</span> -(a&amp; io);</span><br><span class="line">a <span class="keyword">operator</span> *(a&amp; io);</span><br><span class="line">a <span class="keyword">operator</span> /(a&amp; io);</span><br><span class="line"></span><br><span class="line">a&amp; <span class="keyword">operator</span> =(a&amp; io);</span><br><span class="line"></span><br><span class="line">a&amp; <span class="keyword">operator</span> ++()&#123;</span><br><span class="line">dat++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">a&amp; <span class="keyword">operator</span> ++(<span class="type">int</span>)&#123;<span class="comment">//注意运算顺序</span></span><br><span class="line"><span class="function">a <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">++(*<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">a&amp; <span class="keyword">operator</span> --();</span><br><span class="line">a&amp; <span class="keyword">operator</span> --(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">a&amp; <span class="keyword">operator</span> +=(a&amp; io);</span><br><span class="line">a&amp; <span class="keyword">operator</span> -=(a&amp; io);</span><br><span class="line">a&amp; <span class="keyword">operator</span> *=(a&amp; io);</span><br><span class="line">a&amp; <span class="keyword">operator</span> /=(a&amp; io);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> ==(a&amp; io);</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> !=(a&amp; io);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原因:赋值运算的结果是左值,应当按引用返回.</p><p><strong>常见错误</strong>:</p><p>double转float是不安全的.</p><p>析构函数有参数</p><p>类A开头默认私有的</p><p>乱加const的</p><p>继承未完全覆盖虚函数的(不能实例化)</p><p>继承调用私有参数的(权限问题)</p><p>不写<code>using namespace std;</code>然后用标准库的</p><p>少隐式格式转换的</p><p>少构造函数的</p><h3 id="大题">大题</h3><p>看到一个写法是:<code>std::vector&lt;std::string&gt; f()&#123;return &#123;&quot;message1&quot;,&quot;message2&quot;&#125;;&#125;</code>维克托好像可以用大括号构造的.</p><h3 id="关键字">关键字</h3><p>overide:覆写虚函数时加上的,比个例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fuck</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">b</span>:<span class="keyword">public</span> a&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fuck</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;fuck you!\nCyka blyat!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fuck</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;fuck you!\nCyka blyat!&quot;</span>;</span><br><span class="line">&#125;<span class="comment">//这三份代码实际跑起来没有差异,所以知道override是什么就行了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fuck</span><span class="params">()</span><span class="keyword">override</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;fuck you!\nCyka blyat!&quot;</span>;</span><br><span class="line">&#125;<span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line">b aa;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">aa.<span class="built_in">fuck</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加强代码规范的,不写也罢.(为了拿更多分,请你写上)</p><p>namespace:名字空间.有的时候有好多函数都叫一个名字,就需要名字空间来进行区分.名字空间不应当被放在头文件里面.名字空间也可以嵌套.</p><p><code>dynamic_cast&lt;&gt;()</code>:类型的向上转换.比如父类派生好多子类,子类转父类是安全的,但是dynamic_cast&lt;儿子&gt;(父类变量)则是转换成儿子的.众所周知每个爹都不想当儿子,于是这种转换需要代价.</p><p>explicit:构造函数加一个这个可以禁止隐式格式转换.</p><p>完结.</p>]]></content>
      
      
      <categories>
          
          <category> OTH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学物理B学习笔记</title>
      <link href="/2024/06/08/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/06/08/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>RT,这是大物的笔记.(草,劳改课还有一篇三千字的论文等着我…)</p><p>听说大物就是高中物理加点微积分的东西,我怎么这么不信啊…</p><p>考试范围是2-8章,别问为什么缺东西.</p><h1>第2章 机械振动</h1><h2 id="2-1-简谐振动">2.1 简谐振动</h2><p>胡克定律<br>$$F=-kx$$<br>设物体质量为m,牛二得<br>$$F=ma=m\frac{\mathrm d^2x}{\mathrm dt^2}$$<br>将上二式合并改写得<br>$$\frac{\mathrm d^2x}{\mathrm dt^2}=-\frac kmx=-\omega^2x$$<br>式子的解是<br>$$x=A\cos(\omega t+\varphi)$$<br>其中A和varphi都是积分常数.<br>式中<br>$$\omega^2=\frac km$$<br>$\omega$是一个系统自身性质决定的常量.拓展:任意满足下式的都可以被称为简谐运动(式子的意思是加速度与位移均匀变化)<br>$$\frac{\mathrm d^2y}{\mathrm dt^2}=-\omega^2y$$<br>任意时刻的速度和加速度,自己求导算.下面摆以下式子,别记,看看咋写的.<br>$$\begin{aligned}\upsilon&amp;=\frac{\mathrm dx}{\mathrm dt}=-\omega A\sin(\omega t+\varphi)\\ a&amp;=\frac{\mathrm d\upsilon}{\mathrm dt}=-\omega^2A\cos(\omega t+\varphi)\end{aligned}$$<br><strong>振幅</strong>:A.</p><p><strong>周期</strong>:T,单位s.(其中mk都是振子的自身物理属性,可见这些都是固有的)<br>$$T=\frac{2\pi}\omega=2\pi\sqrt{\frac mk}$$<br><strong>振动频率</strong>:$\nu$,单位Hz.<br>$$\nu=\frac\omega{2\pi}=\frac 1T=\frac1{2\pi}\sqrt\frac km$$<br><strong>圆频率</strong>:$2\pi$秒内震动次数,单位$\mathrm{rad\cdot s}^{-1}$.<br>$$\omega=2\pi\nu$$<br><strong>相位</strong>:$(\omega t+\varphi)$,又叫位相,又叫相.<br><strong>初相</strong>:$\varphi$.</p><p>求解初相啥的自己算吧…以后部分公式点到为止,不写长啥样,让你知道哦有这么个事就行,1记不住2能推导,写他干嘛?</p><p><strong>相位差</strong>:<br>$$\Delta\varphi=(\omega_2t+\varphi_2)-(\omega_1t+\varphi_1)$$<br>同频率简谐相位差公式略.<br>如果$\Delta\varphi=2k\pi$叫做同相<br>$\Delta\varphi=\pi+2k\pi$叫做反相.负的叫落后,正的叫领先,范围在$[-\pi,\pi]$.</p><p><strong>简谐运动能量</strong>:就是$E=\frac12kA^2$,平衡点在$\pm\frac{\sqrt2}2A$处,自己证.<br><strong>旋转矢量法</strong>:有一个点围着x逆时针转,投影点就是x,初始时和x轴夹角是$(\omega t+\varphi)$.</p><h3 id="简谐振动的合成">简谐振动的合成</h3><h4 id="同方向同频">同方向同频</h4><p>合振幅<br>$$A=\sqrt{A_1^2+A_2^2+2A_1A_2\cos(\varphi_2-\varphi_1)}$$<br>初相满足<br>$$\tan\varphi=\frac{A_1\sin\varphi_1+A_2\sin\varphi_2}{A_1\cos\varphi_1+A_2\cos\varphi_2}$$<br>$\varphi$角的象限可以通过振动的矢量图直接判定.</p><p><strong>同方向频率相近简谐振动合成</strong>:略,很复杂不让你算.<br><strong>2.3*振动的分解和频谱分析</strong><br><strong>2.4*阻尼振动 受迫振动 共振</strong><br>这俩都加星号,考试不考,不写.</p><h1>第3章 机械波</h1><p>机械波产生条件:<strong>波源和弹性介质</strong>.</p><p>声音是纵波,光是横波.</p><p><strong>波线,波面</strong>:表示波的传递方向,任意时刻振动相位相同的成为波面(波阵面,同相面),最前面的波面叫 <strong>波前</strong>.波线与波面垂直.球面波,正如字面意思.</p><p><strong>波长,周期,频率</strong>:$\lambda$,完整波的长度$T,\nu$.<br><strong>波速</strong>:用$u$表示.公式:<br>$$\lambda=uT$$<br>$$u=\lambda T=\nu\lambda$$<br><strong>波函数</strong>:以下公式表示:<br>$$y_0(t)=A\cos(\omega t+\varphi)$$<br>时间落后:<br>$$y=A\cos\Big[\omega\Big(t-\frac xu\Big)+\varphi\Big]$$<br><strong>波形方程</strong>:波在某点形成的曲线.</p><p><strong>波形向前推移</strong>:经过dt时间,出现在x+dx处,公式为<br>$$A\cos[\omega(t-\frac xu)+\varphi]=A\cos[\omega(t+\Delta t-\frac{x+\Delta x}u)+\varphi]$$<br><strong>行波</strong>:向前推移,走的波叫行波.</p><h3 id="波动方程">波动方程</h3><p>好神秘的样子,升一手三级标题.<br>无吸收的各向同性的三维空间的一切传播的波动过程均满足下式:<br>$$\frac{\partial^2\psi}{\partial x^2}+\frac{\partial^2\psi}{\partial y^2}+\frac{\partial^2\psi}{\partial z^2}=\frac 1{u^2}\frac{\partial^2\psi}{\partial t^2}$$<br>其中的$\psi$可以代表任何物理量.波函数啊啥的.</p><h3 id="波的能量-能流密度">波的能量 能流密度</h3><p><strong>能量密度</strong>:介质单位体积内的波动能量.<br>$$w=\frac{\mathrm dE}{\mathrm dV}=\rho A^2\omega^2\sin^2\omega(t-\frac xu)$$<br>这个是随时间变化的,平均能量密度是<br>$$\overline w=\frac 1T\int_0^T\rho A^2\omega^2\sin^2\omega(t-\frac xu)\mathrm dt=\frac 12\rho A^2\omega^2$$<br><strong>能流</strong>:单位时间内,通过介质某面积的能量.<br>$$P=\frac{\mathrm dE}{\mathrm dt}=wuS=\rho A^2\omega^2uS\sin^2\omega(t-\frac xu)$$<br><strong>平均能流</strong>:<br>$$\overline P=\overline wus=\frac 12\rho A^2\omega^2uS$$<br><strong>能流密度</strong>:单位时间内垂直于波线的单位面积平均能量.(也叫波强,单位$\mathrm{W\cdot m^{-2}}$)<br>$$I=\frac{\overline P}S=\frac 12\rho A^2\omega^2u=\overline wu$$<br>矢量式:<br>$$\overrightarrow I=\overline w\cdot\overrightarrow u=\frac 12\rho A^2\omega^2\overrightarrow u$$</p><p><strong>声波</strong>:20-20000Hz.声波的强度叫声强,声强级是比较声波强度的概念.单位B(贝尔),实际一般使用分贝(dB),$1B=10dB$.<br>以$10^{-12}\mathrm{W\cdot m^{-2}}$为基准声强.($I_0$)<br>$$L=\lg\frac I{I_0}(\mathrm B)=10\lg\frac I{I_0}(\mathrm{dB})$$<br><strong>波的衍射反射折射叠加,惠更斯原理</strong>:略(乐)</p><h3 id="波的干涉">波的干涉</h3><p>两个波方程在P点的干涉,合起来是<br>$$A=\sqrt{A_1^2+A_2^2+2A_1A_2\cos\Delta\varphi}$$<br>其中<br>$$\Delta\varphi=\varphi_1-\varphi_2-\frac{2\pi}\lambda(r_2-r_1)$$<br>式子可以理解为波函数先在P点的波形方程,然后两个波形方程叠加(回归上一章了)<br>初相$\varphi$满足<br>$$\tan\varphi=\frac{A_1\sin(\varphi_1-\frac{2\pi r_1}\lambda)+A_2\sin(\varphi_2-\frac{2\pi r_2}\lambda)}{A_1\cos(\varphi_1-\frac{2\pi r_1}\lambda)+A_2\cos(\varphi_2-\frac{2\pi r_2}\lambda)}$$<br>然后还是那句老话:2k pi振动加强,pi+2k pi振动减弱.<br>实际条件中两个相干波源可能是同一个震源驱动的,初相相同,干涉极值可以用波程差表示.<br>$$\delta=r_2-r_1=k\lambda\\ \delta=r_2-r_1=(2k+1)\frac\lambda2$$<br>干涉加强和干涉减弱的式子.整数波长加强,半数波长减弱.</p><h3 id="驻波">驻波</h3><p>干涉的一种特殊情况,合成的波并不向前传递,表现为某些点就是一直不动,然后这些点把绳子分开,像跳绳一样.</p><p><strong>波节</strong>:振动不动的点.<br><strong>波腹</strong>:有些点的振幅始终最大.</p><p>设两个波的初相都是0,波动方程为<br>$$y=A\cos2\pi(\frac tT-\frac x\lambda)$$<br>叠加一下,用个和差化积,得到<br>$$y=2A\cos2\pi\frac x\lambda\cos\frac{2\pi}Tt$$<br>所以波节满足振动位移是0,带入解出<br>$$x=\pm(2k+1)\frac\lambda4$$<br>同理波腹也能这么求出来:<br>$$x=\pm k\frac\lambda2$$<br>他俩之间有半个波长距离.</p><h3 id="半波损失">半波损失</h3><p>一般情况下,半波损失和波的种类,两种介质的性质和入射角大小都有关.但是波垂直入射时,半波损失由介质密度和波速乘积$\rho v$决定.这个数大的叫波密介质,这个小的叫波疏介质,波疏到波密有半波损失,反之没有,界面是驻波波腹.</p><h4 id="弦上驻波">弦上驻波</h4><p>由于两固定端必为波节,所以弦长是半波长的整数倍,有<br>$$L=n\frac\lambda2$$<br>所以频率能求出来是<br>$$\nu_n=n\frac u{2L}$$<br>所以满足条件才能形成驻波,分别是基频,一次谐频,二次谐频,三次谐频…(取决于n的取值)</p><h3 id="多普勒效应">多普勒效应</h3><p>其实就是速度变成$u+u_B$,别的都一样,换个参考系就完事了.</p><h1>第4章 静电场</h1><p>基本电荷量(油滴实验测的):<br>$$e=1.602176462\times10^{-19}\mathrm C$$<br>库仑力:<br>$$\overrightarrow F=k\frac{q_1q_2}{r^2}\overrightarrow e_r$$<br>其中r是矢量$\overrightarrow r$的大小,$\overrightarrow e$是方向矢量,k是一个常数,大小为<br>$$k=8.9880\times10^9\mathrm{N\cdot m^2\cdot C^{-2}}\approx9\times10^9\mathrm{N\cdot m^2\cdot C^{-2}}$$<br>为了简化公式,我们定义一个真空介电常量,或真空电容率即<br>$$\varepsilon_0=\frac1{4\pi k}=8.85\times10^{-12}\mathrm{C^2\cdot N^{-1}\cdot m^{-2}}$$<br>(所以有下式,为了和高中转换思路):<br>$$k=4\pi\varepsilon_0$$<br>公式改写为<br>$$\overrightarrow F=\frac{q_1q_2}{4\pi\varepsilon_0r^2}\overrightarrow e_r$$<br><strong>电场强度</strong>:<br>$$\overrightarrow E=\frac{\overrightarrow F}{q_0}$$<br>好几个电场那就矢量叠加,公式略.<br><strong>受力</strong>:<br>$$\overrightarrow F=q_0\overrightarrow E$$<br><strong>点电荷场强</strong>:<br>$$\overrightarrow E=\frac q{4\pi\varepsilon_0r^2}\overrightarrow e_r$$<br>(r的方向是产生电场的电荷直接指向试验电荷)<br>好几个点电荷:直接矢量相加.<br><strong>连续带电体的场强</strong>:(划分为好多个点电荷元$\mathrm dq$求电场元$\mathrm dE$)矢量积分<br>$$\overrightarrow E=\int\mathrm d\overrightarrow E=\frac 1{4\pi\varepsilon_0}\int\frac{\mathrm dq}{r^2}\overrightarrow e_r$$<br>可以分解为<br>$$E_x=\int\mathrm dE_x,E_y=\int\mathrm dE_y,E_z=\int\mathrm dE_z\\ E=\sqrt{E_x^2+E_y^2+E_z^2}$$</p><p><strong>电偶极子</strong>:相隔较近的两个等量异号的点电荷.<br><strong>电偶极矩</strong>:大小是单个极子的电量乘距离,方向负到正.即<br>$$\overrightarrow p=q\overrightarrow l$$</p><h3 id="静电场中的电介质-电位移矢量">静电场中的电介质 电位移矢量</h3><p>就是说,分子受电场作用自己也会一字排开,然后产生一个极化电荷的电场,然后抵消原来的电场.公式<br>$$\overrightarrow E=\frac{\overrightarrow E_0}{\varepsilon_r}$$<br>式中$\varepsilon_r$叫相对介电常数(没错,就是高中电容那里的东西),$\overrightarrow E_0$是原来的电场.真空的介电常数为1,空气近似1.<br>假如电场太过强力,会把分子拆开变成自由电荷(击穿),临界电场强度叫 <strong>介电强度</strong>.<br><strong>电介质的介电常数</strong>:<br>$$\varepsilon=\varepsilon_0\varepsilon_r$$<br>这个$\varepsilon$的作用是替换之前的$\varepsilon_0$,代表某介质中的 <strong>介电常数</strong> 使用,别的不变.</p><p><strong>电极化强度</strong>:电介质单位体积内电偶极矩的矢量和.<br>$$\overrightarrow P=\frac{\sum\overrightarrow p_{分子}}{\Delta V}$$<br>反映了介质内电极化的强弱和方向.<br>极化电荷与电极化强度之间的关系:设两平面的自由电荷面密度是$\sigma$和$-\sigma$,有<br>$$\sigma’=\frac{\varepsilon_r-1}{\varepsilon_r}\sigma$$<br>表示自由电荷密度$(\sigma)$和极化电荷密度$(\sigma’)$的关系.<br>利用$q=\sigma S$带入得<br>$$\overrightarrow P=\frac{\varepsilon_r-1}{\varepsilon_r}\sigma=\varepsilon_0(\varepsilon_r-1)E=\overrightarrow P=\varepsilon_0\chi_e\overrightarrow E$$<br>(定义$\chi_e=\varepsilon_r-1$表示电极化率).理论上是个常数,但是实际上极化介质需要时间,高频电场会让介电常数与外加电场频率有关.</p><p><strong>电位移矢量</strong>:定义如下<br>$$\overrightarrow D=\varepsilon_0\overrightarrow E+\overrightarrow P$$<br>单位$\mathrm{C\cdot m^{-2}}$.<br>平板电场的特例:(等于电荷面密度)<br>$$D=\sigma$$<br>仍然满足矢量叠加原理.<br>$$D=\frac{\mathrm d\varPhi_e}{\mathrm dS_\perp}$$<br><strong>这表明,电场中某点电位移矢量大小等于该点处电位移线的密度.</strong></p><p>这个时候要祭出一个牛逼的公式帮我们衔接高中:<br>$$\boxed{E=\frac D\varepsilon}$$</p><h3 id="静电场中的高斯定理">静电场中的高斯定理</h3><p><strong>电场线,电位移线</strong>:永不闭合(无旋性),切线方向垂直,永不相交.电位移线线和电场线一毛一样,只是量纲不太一样.</p><p><strong>电通量</strong>:用$\varPhi_e$表示.<br>$$\varPhi_e=\overrightarrow D\cdot\overrightarrow S$$<br>任意曲面:<br>$$\varPhi_e=\int_S\overrightarrow D\cdot\mathrm d\overrightarrow S$$<br>闭合曲面:<br>$$\varPhi_e=\oint_S\overrightarrow D\cdot\mathrm d\overrightarrow S$$<br><strong>高斯定理</strong>:空间内分布好多个点电荷,空间内做一个任意形状的闭合曲面(叫做高斯面),有的点电荷在面内有的在面外,通过该面的电通量只与面内的点电荷有关,等于其中的自由电荷量的代数和.表示为:<br>$$\oint_S\overrightarrow D\cdot\mathrm d\overrightarrow S=\sum_{(S内)}q_i$$</p><p><strong>直线的电荷线密度</strong>:$\lambda$.作用:<br>一段线的带电量<br>$$\sum q_i=\lambda l$$<br>很方便.</p><h3 id="几个结论">几个结论</h3><p><strong>球面的电场强度</strong><br>$$E=\begin{cases}\frac q{4\pi\varepsilon r^2}&amp;(r&gt;R)\\ 0&amp;(r&lt;R)\end{cases}$$<br><strong>球体的电场强度</strong>($\varepsilon_1$表示内部介电常数,2是外部的)<br>$$E=\begin{cases}\frac q{4\pi\varepsilon_2r^2}&amp;(r&gt;R)\\ \frac{qr}{4\pi\varepsilon_1R^3}&amp;(r&lt;R)\end{cases}$$</p><h4 id="柱对称的状况">柱对称的状况</h4><p>$$E=\frac\lambda{2\pi\varepsilon r}$$<br><strong>圆柱面的情况</strong>:同理,内部是0外部和上面公式一毛一样.</p><p><strong>圆柱体的状况</strong>:我逐渐理解&quot;电荷体密度&quot;是什么意思了…就是&quot;电荷 体密度&quot;和&quot;电荷 线密度&quot;,单位不一样,直接乘面积或者体积就是对应的电荷量…所以这个可以自己导了.</p><p><strong>无限大均匀带电平面的分布</strong>:<br>$$E=\frac{\sigma}{2\varepsilon}$$</p><h3 id="静电场的环路定理-电势">静电场的环路定理 电势</h3><p>任何做功与路径无关的电场叫做 <strong>保守场</strong>.静电场是保守场,静电力是保守力.</p><h2 id="电势">电势</h2><p>(高中整天谈的东西,升一手二级标题不过分吧)<br>$$U_A=\int^\infty\overrightarrow E\cdot\mathrm d\overrightarrow l$$<br>两点的电势差:<br>$$U_{ab}=U_a-U_b$$<br>又叫电压,符号福特.</p><p><strong>等势面</strong>:略,太熟悉了.</p><p><strong>电场强度和电势梯度</strong>:有<br>$$\overrightarrow E=-\nabla U$$<br>意思是某点电场强度就是电势梯度的负值.</p><p><strong>注意</strong>:1.场强方向是电势衰减最快的方向.<br>2.场强大小和变化率有关,与电势值并无直接关系.</p><p><strong>静电场中的导体</strong>:记住一个结论:越尖端积聚电荷量越大.<br><strong>静电屏蔽</strong>:网罩,尽量减少电场对精密器械的影响.<br><strong>接地</strong>:金属空腔内放一个电子会往外辐射电场,但是如果空腔接地那就不会有电场溢出.</p><h3 id="电容">电容</h3><p>公式<br>$$C=\frac qU$$<br>单位 法拉.<br>$$\mathrm{1F=1C/V,1F=10^6\mu F=10^{12}pF}$$<br><strong>求电容</strong>:</p><p><strong>平板容器</strong>:先求电场:<br>$$D=\sigma,E=\frac\sigma\varepsilon$$<br>两点间电势差<br>$$U_{AB}=Ed=\frac{qd}{\varepsilon S}$$<br>所以<br>$$C=\frac{\varepsilon S}d$$<br>有<br>$$\frac C{C_0}=\frac \varepsilon{\varepsilon_0}=\varepsilon_r$$<br>带r的那个是相对介电常数.</p><p><strong>圆柱形电容器的电容</strong>:<br>先求电场:<br>$$E=\frac \lambda{2\pi\varepsilon r}$$<br>然后求电势差<br>$$U_{AB}=\int^B_A\overrightarrow E\cdot\mathrm d\overrightarrow l=\int^{R_B}_ {R_A}\frac\lambda{2\pi\varepsilon r}\mathrm dr=\frac\lambda{2\pi\varepsilon}\ln\frac{R_B}{R_A}$$<br>故有<br>$$C=\frac{2\pi\varepsilon l}{\ln\frac{R_B}{R_A}}$$<br><strong>球形容器的电容</strong>:老规矩,先求电场.<br>$$E=\frac q{4\pi\varepsilon r^2}$$<br>然后求出来电势差<br>$$U_{AB}=\int^B_A\overrightarrow E\cdot\mathrm d\overrightarrow l=\int^{R_B}_ {R_A}\frac q{4\pi\varepsilon r^2}\mathrm dr=\frac q{4\pi\varepsilon}\Big(\frac 1{R_A}-\frac 1{R_B}\Big)$$<br>最后求出来电容:<br>$$C=\frac q{U_{AB}}=4\pi\varepsilon\frac{R_AR_B}{R_B-R_A}$$<br><strong>电容串联</strong>:<br>$$\frac 1C=\frac 1{C_1}+\frac 1{C_2}+…$$<br>也就是说更不容易击穿了,但是电容变小了.<br><strong>电容并联</strong>:<br>$$C=C_1+C_2+…$$<br>直接相加,电容变大,但是更容易被击穿,取决于能力最低的那个.</p><p><strong>电容能量</strong>:<br>$$W_e=\frac 12CU^2_{AB}=\frac 12U_{AB}Q$$<br><strong>电场能量</strong>:先引入电场能量密度的概念,用$w_e$表示:<br>$$w_e=\frac 12DE=\frac 12\varepsilon E^2=\frac 12\overrightarrow D\cdot\overrightarrow E$$<br>所以(V是电场空间所占体积)<br>$$W_e=\frac 12\varepsilon E^2V=\int w_e\mathrm dV$$</p><h1>第5章 稳恒磁场</h1><p>耶比,到磁场了…</p><h3 id="电流和电流密度">电流和电流密度</h3><p>电流的定义式<br>$$I=\frac{\mathrm dq}{\mathrm dt}$$<br>电流密度使用$\overrightarrow J$表示,公式为<br>$$\overrightarrow J=\frac{\mathrm dI}{\mathrm dS_\perp}=\rho_e\overrightarrow v$$<br>垂直电流线.其中$\rho_e$是平均电流密度,$\overrightarrow v$是该点电荷运动速度的平均值,称为迁移速度.<br>$$\overrightarrow J=ne\overrightarrow v$$<br>其中n是单位体积内载流子数目,e是载流子电荷量.如果有好几种电荷和不同的速度那就是他们的矢量和.</p><h3 id="稳恒电场-欧姆定律">稳恒电场 欧姆定律</h3><p>$$I=\frac UR$$<br>适用范围,金属导体,电解液.<br><strong>电导</strong>:单位S(西门子),欧姆倒数.<br>$$G=\frac1R$$<br>电阻率:<br>$$R=\rho\frac lS$$<br>不均匀时:<br>$$R=\int\frac{\rho\mathrm dl}S$$<br><strong>电导率</strong>:<br>$$\sigma=\frac1\rho$$<br>电阻率和温度之间有以下关系:<br>$$\rho=\rho_0(1+\alpha t)$$<br>其中$\alpha$叫做电阻温度系数.</p><p><strong>魔改欧姆定律</strong>:<br>$$\overrightarrow J=\sigma\overrightarrow E$$<br>其中$\overrightarrow E$是电场强度.对非稳恒情况也适用,具有更大的普遍性.</p><p><strong>电动势</strong><br>$$\overrightarrow E_k=\frac{\overrightarrow F_k}q$$<br>叫做 <strong>非静电场强</strong>,他的作用使得正极积聚正电荷,负极积聚负电荷,形成电流.<br>$$\varepsilon=\frac Aq=\oint_L\overrightarrow E_k\cdot\mathrm d\overrightarrow l$$<br>式中$\varepsilon$叫做电动势,单位是伏特.</p><h3 id="磁场">磁场</h3><p><strong>磁感应强度</strong>:(最大力的时候是电子垂直磁场运动(废话))<br>$$B=\frac{F_{\max}}{qv}$$<br>单位特斯拉(T).<br><strong>电流元产生磁场</strong>:设电流元为$I\mathrm d\overrightarrow l$,方向与电流相同,于是有<br>$$\mathrm d\overrightarrow B=k\frac{I\mathrm d\overrightarrow l\times\overrightarrow r}{r^3}$$<br>k为比例系数,大小和上式单位有关.如果国际单位制就是:<br>$$\mathrm d\overrightarrow B=\frac{\mu_0}{4\pi}\frac{I\mathrm d\overrightarrow l\times\overrightarrow r}{r^3}$$<br>积分形式是<br>$$\overrightarrow B=\int_L\mathrm d\overrightarrow B=\int_L\frac{\mu_0}{4\pi}\frac{I\mathrm d\overrightarrow l\times\overrightarrow r}{r^3}$$<br>其中$\mu_0=4\pi\times10^{-7}\mathrm{T\cdot m\cdot A^{-1}}$叫做真空的磁导率.</p><p><strong>运动电荷的磁场</strong>:<br>$$\overrightarrow B_1=\frac{\mathrm d\overrightarrow B}N=\frac{\mu_0}{4\pi}\frac{q\overrightarrow v\times\overrightarrow r}{r^3}$$</p><h3 id="上面俩定律的应用">上面俩定律的应用</h3><p>求磁场呗…说什么废话.</p><p><strong>无限长直导线在某点产生的磁场</strong>(a是距离):<br>$$B=\frac{\mu_0I}{2\pi a}$$<br><strong>环形导线的磁场</strong>(中心线上):<br>$$B=\frac{\mu_0}2\frac{R^2I}{(R^2+x^2)^{\frac32}}$$<br><strong>直螺线管的磁场</strong>:(这个细讲讲,会导式子就行)<br>因为螺线管很密,所以每个电流元可以取$n\mathrm dl$,这条段上线圈在P点产生的磁感应强度就是<br>$$\mathrm dB=\frac{\mu_0}{2}\frac{R^2In\mathrm dl}{(R^2+l^2)^\frac32}$$<br>考虑对B求积分,引入变量$\beta$表示矢径之间的夹角,看图发现$l=Rc\tan\beta,\mathrm dl=-R\csc^2\beta\mathrm d\beta$,利用$R^2+l^2=R^2\csc^2\beta$得<br>$$B=\int-\frac{\mu_0}2nI\sin\beta\mathrm d\beta$$<br>$\beta$的上界和下限分别为$\beta_1,\beta_2$,带入得<br>$$B=\frac{\mu_0}2nI(\cos\beta_2-\cos\beta_1)$$<br>方向沿轴线向右.无限长:<br>$$B=\mu_0nI$$<br>对于长直螺线管,边缘的大小是二分之中间的大小.</p><p><strong>磁感线</strong>:几个性质</p><ol><li>任意两条磁感线不会相交.(因为任意一点方向是唯一确定的)</li><li>磁感线是无头无尾的闭合曲线.</li><li>磁场较强的地方磁感线比较密集.</li></ol><p><strong>磁通量 磁场中的高斯定理</strong>:<br>单位Wb(韦伯).<br>$$\varPhi_m=\int_S\overrightarrow B\cdot\mathrm d\overrightarrow S$$<br>高斯定理:对于任意闭合曲面的总磁通量为0(这回就很鸡肋了,只表明了磁场是无源场).<br>$$\oint_SB\cos\theta\mathrm dS=\oint_S\overrightarrow B\cdot\mathrm d\overrightarrow S=0$$</p><h3 id="磁介质-磁化强度">磁介质,磁化强度</h3><p>略,加星了不讲.</p><p>$$\overrightarrow H=\frac{\overrightarrow B}\mu$$<br>$\mu$被称为介质的磁导率,有$\mu=\mu_0\mu_r$,H是新引入的概念,表示磁场强度.</p><p>哈哈,略个几把,后面要用到前面的概念你给我说不讲我去?</p><h3 id="安培环路定律">安培环路定律</h3><p>环流:(记住得顺着磁场线)<br>$$\oint_L\overrightarrow H\cdot\mathrm d\overrightarrow l=\oint_LH\mathrm dl=\frac{I}{2\pi r}\oint\mathrm dl=\frac I{2\pi r}\cdot2\pi r=I$$<br>上式表明积分和只与传导电流有关.反向积分结果是负的.<br><strong>多个导线</strong>:<br>$$\oint_L\overrightarrow H\cdot\mathrm d\overrightarrow l=\oint_LH\cos\theta\mathrm dl=\sum I_i$$<br>上式被称为安培环路定律.</p><h3 id="磁场对载流导线的作用">磁场对载流导线的作用</h3><p><strong>安培力公式</strong>:<br>$$\overrightarrow F=\int_LI\mathrm d\overrightarrow l\times\overrightarrow B$$<br><strong>洛伦兹力</strong>:<br>$$F_{\max}=qvB$$<br>$$\overrightarrow F=q\overrightarrow v\times\overrightarrow B$$<br>洛伦兹力公式.(左力右电的口诀仍记心间…)</p><p><strong>转圈圈~</strong><br>$$R=\frac{mv_0}{qB}$$<br>$$T=\frac{2\pi R}{v_0}=\frac{2\pi m}{qB}$$<br>螺距:转一圈差多少距离(螺旋升天的时候)(这里把速度分解了,升天的速度是$v_0\cos\theta$)<br>$$h=\frac{2\pi mv_0\cos\theta}{qB}$$<br><strong>霍尔效应</strong>:额,吃老底吧,没啥好说的.</p><h1>第6章 电磁场理论基础</h1><p><strong>电磁感应</strong>:<br><strong>感生电动势</strong>:<br>$$\varepsilon=-\frac{\mathrm d\varPhi}{\mathrm dt}$$<br><strong>电荷</strong>:<br>$$q=\int_{\Delta\varPhi}-\frac1R\mathrm d\varPhi$$<br><strong>楞次定律</strong>:阻碍.</p><h3 id="感生和动生电动势">感生和动生电动势</h3><h4 id="动生电势">动生电势</h4><p>$$\varepsilon=\int_a^b(\overrightarrow v\times\overrightarrow B)\cdot\mathrm d\overrightarrow l$$<br>三者垂直有<br>$$\varepsilon=Bvl$$<br>(上面的是正常的导体棒移动的电动势)<br>$$\mathrm d\varepsilon=Bv\mathrm dr=B\omega r\mathrm dr$$<br>$$\varepsilon=\int\mathrm d\varepsilon=\int_0^1B\omega r\mathrm dr=\frac 12B\omega l^2$$<br>导体棒旋转产生的电动势.</p><h4 id="感生电势">感生电势</h4><p>$$\oint_L\overrightarrow E_k\cdot\mathrm d\overrightarrow l=-\frac{\mathrm d}{\mathrm dt}\int_S\overrightarrow B\cdot\mathrm d\overrightarrow S$$<br>$$\oint_L\overrightarrow E_k\cdot\mathrm d\overrightarrow l=-\int_S\frac{\partial\overrightarrow B}{\partial t}\cdot\mathrm d\overrightarrow S$$<br>两个式子(害,无非就是磁通量变化)</p><p><strong>涡流和趋肤效应</strong>:涡流不解释,趋肤效应是导线在高频交流电作用下电流会主要趋近导线表面,所以常常用多股导线代替一根长直导线,而且可以利用涡流导致的趋肤效应淬火,表面快速升温淬火变硬,但是内部还是维持原先的韧性.</p><h3 id="自感">自感</h3><p>有一种预感,自感会很恐怖…<br>$$\varPhi=LI$$<br>L是自感系数,单位亨利(H)<br>$$\varepsilon_L=-L\frac{\mathrm dI}{\mathrm dt}$$<br>$$\varepsilon_L=-\frac{\mathrm d\varPhi}{\mathrm dt}=-(L\frac{\mathrm dI}{\mathrm dt}+I\frac{\mathrm dL}{\mathrm dt})$$<br>感生电动势阻碍.</p><p><strong>自感电路中的衰减和增长过程</strong>:弛豫时间$t=\tau=L/R$<br>然后自己求积分算.</p><h3 id="磁场的能量">磁场的能量</h3><p>自感线圈存储的能量:(其实就是螺线管)<br>$$W_m=\frac12LI^2$$<br><strong>磁场能量密度</strong>:<br>$$w_m=\frac{B^2}{2\mu}=\frac12BH=\frac12\mu H^2$$<br>推广:<br>$$W_m=\int_V\mathrm dW_m=\int_Vw_m\mathrm dV=\int_V\frac{B^2}{2\mu}\mathrm dV$$</p><hr><p><strong>题外话</strong>:电缆长为l,半径r,体积设为<br>$$\mathrm dV=2\pi r\mathrm dr$$<br>体会一下,好像是对面积公式求导然后在积分的时候把同轴电缆的两个参数带进去,不需要无脑求体积.</p><h3 id="位移电流">位移电流</h3><p><strong>非恒定电流的磁场中,安培环路定律不再适用.</strong>(因为非恒定状况下,电流不连续)</p><p>麦克斯韦说,能等效一个电流出来,叫&quot;位移电流&quot;,能够让变化电场的高斯定理仍然成立.<br>$$\oint_S\overrightarrow D\cdot\mathrm d\overrightarrow S=q$$<br>然后先对时间求导,有<br>$$\oint_S\frac{\partial\overrightarrow D}{\partial t}\cdot\mathrm d\overrightarrow S=\frac{\mathrm dq}{\mathrm dt}$$<br>带入方程可得<br>$$\oint_S(\overrightarrow j+\frac{\partial\overrightarrow D}{\partial t})\cdot\mathrm d\overrightarrow S=0$$<br>这个&quot;勾&quot;就是 <strong>位移电流</strong>,满足<br>$$\overrightarrow j_d=\frac{\partial\overrightarrow D}{\partial t}$$<br>所以<br>$$I_d=\int_S\overrightarrow j_d\cdot\mathrm d\overrightarrow S$$<br><strong>全电流</strong>:传导电流和位移电流的总和.是连续的.有<br>$$\oint_L\overrightarrow H\cdot\mathrm d\overrightarrow L=I_全=I+I_d=\int_S(\overrightarrow j+\frac{\partial\overrightarrow D}{\partial t})\cdot\mathrm d\overrightarrow S$$<br>叫做全电流定律.</p><h3 id="麦克斯韦方程组">麦克斯韦方程组</h3><p>静电场和稳恒磁场的基本方程.<br>$$\oint\overrightarrow D\cdot\mathrm d\overrightarrow S=q\\ <br>\oint\overrightarrow E\cdot\mathrm d\overrightarrow l=-\frac{\mathrm d\varPhi}{\mathrm dt}=-\int_S\frac{\partial\overrightarrow B}{\partial t}\cdot\mathrm d\overrightarrow S\\ <br>\oint_S\overrightarrow B\cdot\mathrm d\overrightarrow S=0\\ <br>\oint_L\overrightarrow H\cdot\mathrm d\overrightarrow l=I+I_d=\int_S(\overrightarrow J+\frac{\partial\overrightarrow D}{\partial t})\cdot\mathrm d\overrightarrow S<br>$$<br>很牛逼,但是不教怎么用.(估计就是看看牛逼得了)</p><h3 id="电磁波">电磁波</h3><p>传播速率:(下面的c是光速)<br>$$u=\frac 1{\sqrt{\mu\varepsilon}}\\ c=\frac 1{\sqrt{\mu_0\varepsilon_0}}$$<br>电磁波的波函数:<br>$$E=E_0\cos\omega(t-\frac zu)$$<br>$$H=H_0\cos\omega(t-\frac zu)$$<br>任何时刻,$\overrightarrow E,\overrightarrow H$和波的传播方向都构成一对右旋的直角坐标系.<br><img src="https://pic4.zhimg.com/v2-df0659a8e768790ecb729e2d587e5afd_r.jpg?source=1940ef5c" alt="图炸了"></p><p>而且$\overrightarrow E\times\overrightarrow H$总是沿着波的方向.(所以光是横波)</p><p><strong>任意时刻有</strong>:<br>$$\sqrt\mu H=\sqrt\varepsilon E$$<br>E和H分别在各自的平面上传播,体现了光的偏振性.</p><p><strong>电磁波的能量</strong>:<br>$$S=\frac 12u(\varepsilon E^2+\mu H^2)=EH$$<br>把光速带进去自己算结论式子.同理,矢量式是他俩叉乘.<br><strong>平面电磁波的强度表示式</strong>:<br>$$I=\frac12E_0H_0$$<br>剩下的自己推.</p><p><strong>电磁波谱</strong>:从能量低到高分别是:<br>无线电波,红外线,可见光,紫外线,X射线,$\gamma$射线</p><h1>第7章 光的干涉</h1><p>由于生理上引起感光作用的是$\overrightarrow E$而不是$\overrightarrow H$,所以把E叫做光矢量.</p><p>叠加时,各点光强为<br>$$I=I_1+I_2+2\sqrt{I_1I_2}\cos\Delta\varphi$$<br>相位差<br>$$\Delta\varphi=(\varphi_1-\varphi_2)-\frac{2\pi}{\lambda}(r_1-r_2)$$<br>表明,叠加光强具有偶数k pi时干涉极大,奇数k pi时干涉极小.</p><p><strong>光程差</strong>:光在折射率n的介质中传播的几何路程为r,相当于在真空中传播$L=nr$,叫做光程.</p><p>相位差:<br>$$\Delta\varphi=\varphi_2-\varphi_1-2\pi\frac{n_2r_2-n_1r_1}\lambda$$<br>光程差就是二者相减:<br>$$\delta=n_2r_2-n_1r_1$$</p><p>所以暗纹判定可能会很好用:(phi用2k pi判定)<br>$$\delta=\begin{cases}\pm k\lambda&amp;亮\\ \pm(2k+1)\frac\lambda2&amp;暗\end{cases}$$<br>一个结论:透镜虽然会引起光传播路径的差异,但是不会产生光程差的变化.</p><h3 id="获得相干光的办法">获得相干光的办法</h3><p><strong>分波面法</strong>:平行光先透过一个单缝然后分成一束光衍射,然后后面放一个双缝.</p><p><strong>分振幅法</strong>:一块玻璃,然后一束光打在上面会发生反射和折射,反射的光直接出去了,折射的打到玻璃底部再反射出去,可以获得两束相干光</p><p><strong>附加条件</strong>:1两束光不可振幅相差太大,否则看不出来.2光程差不可太大,不然一束光道路另一束还没到,会很难评.</p><h3 id="分波阵面干涉">分波阵面干涉</h3><p><strong>杨氏干涉</strong>(高中实验)<br>$$x=\pm k\frac Da\lambda$$<br>这是明条纹的位置,k是整数,a是两光源之间的距离,D是筒的长度.<br>$$x=\pm(2k+1)\frac{D\lambda}{2a}$$<br><strong>劳埃镜实验</strong>:<br>一束光源和一个镜子,镜子用来反射光模拟一个虚拟的相干光源,剩下的不用多说了,1能看干涉条纹,2能观测到反射光的相位发生了跃变.</p><h3 id="分振幅干涉">分振幅干涉</h3><p>(有点看懵逼了,感觉需要考场自己写自己导式子,这里先挖个坑)</p><p><strong>薄膜干涉</strong>:</p><p><img src="https://img.mianfeiwendang.com/pic/d7173276b7690f6b4392b677/1-810-jpg_6-1080-0-0-1080.jpg" alt="你是一个一个一个炸掉的图啊啊啊啊"></p><p>所以两束光,一个过薄膜一个没有,中间会有固定的光程差,满足相干光的条件.<br>$$\delta=2e\sqrt{n_2^2-n_1^2\sin^2i}+\frac\lambda2=\begin{cases}k\lambda&amp;亮啊,很亮啊\\ (2k+1)\frac\lambda2&amp;黑的\end{cases}$$<br>式子最后加的半个波长是半波损失,发生在光从1表面反射到透镜的过程(e是薄膜的厚度,i是入射角,n1是空气折射率,n2是薄膜折射率).</p><p>可以发现,在一个薄膜干涉系统中,光程差最后取决于入射角.不同倾角的入射光最后都会形成不同的干涉条纹,叫做 <strong>等倾干涉</strong>.条纹是内疏外密的明暗相间圆环.</p><p>但是可以看到,有一部分光直接透射出去了,这两束透射光也是可以进行干涉的,光程差是<br>$$\delta=2e\sqrt{n_2^2-n_1^2\sin^2i}$$<br>这里是没有半波损失的,所以发现反射光干涉强了透射光干涉就会减弱,这是符合能量守恒定律的.</p><p><strong>劈尖干涉</strong>:其实就是 <strong>等厚干涉</strong>.凡厚度相同的地方都会是同一条干涉条纹.</p><p>实验:两个玻璃片边上垫一层纸(劈尖角一般都很小),然后用光垂直入射,会让直接反射和透射玻璃被劈尖反射的光发生干涉.<br>$$\delta=2n_2e+\frac\lambda2$$<br>老规矩,k入是加强,n2是两个劈尖中间的介质e是劈尖厚度,全程和玻璃板没任何关系,甚至换成空气劈尖都没问题.<br>$$l=\frac\lambda{2n_2\theta}$$<br>表示两个干涉条纹之间的距离</p><p><strong>牛顿环</strong>:也是一种等厚干涉.光程差:<br>$$\delta=2e+\frac\lambda2$$<br>光程差和半波损失,还是k入明环否则暗环.<br>$$e_k=\frac{r_k^2}{2R}$$<br>其中R是透镜曲率半径.e是对应的空气柱的厚度,也就是<br>$$r_k^2=2Re_k-e_k^2$$<br>所以明环:<br>$$r_k=\sqrt{(k-\frac12)R\lambda}$$<br>暗环:<br>$$r_k=\sqrt{kR\lambda}$$</p><h1>第8章 光的衍射</h1><p>这一章开始就看不懂了…光的波动函数还需要好好看看才能解析这部分的内容…</p><p>只有很小的时候,狭缝甚至和光的波长相比拟的时候衍射现象才明显.</p><p>先分开:当光源和接收屏或二者之一距离有限时叫菲涅尔衍射,或者叫近场衍射,都无限的时候(入射光和衍射光都是平行光的时候)叫夫琅禾费衍射,或远场衍射.</p><p><strong>因为夫琅禾费衍射在实际应用中十分重要,而且数学处理比菲涅尔衍射要简单,所以本章只讨论夫琅禾费衍射(老师人真好,%%%).</strong></p><h2 id="菲涅尔衍射">菲涅尔衍射</h2><p><strong>惠更斯原理</strong>:介质中传播到的各点,都可以看成是发射子波的波源,其后的任一时刻,子波的包迹就是新的波阵面.</p><p>略,太tm复杂了.Flu看不懂,在这里赌一手不考这逼玩意.</p><h2 id="夫琅禾费衍射">夫琅禾费衍射</h2><p>(这里只考虑 <strong>单缝衍射</strong> 的状况)远场衍射,使用两个凸透镜用来聚光.结构长这样:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">光-&gt;()|()-&gt;   |</span><br></pre></td></tr></table></figure><p>|上有一条小狭缝,假设太小了你看不到(我是不会说我没找到开了一个洞的符号的)()表示凸透镜(有俩)</p><p><strong>俩透镜作用</strong>:第一个是点光源,透镜会把发散的光变成平行光,然后通过狭缝.第二个透镜的目的是汇聚,把平行光衍射的一个方向的光汇聚在一起,然后打在屏幕上会发生干涉.</p><p>入射方向:$\varphi$</p><p>不同角度入射的光会有不同程度的光程差,最中间的叫中央明纹,是最大的干涉纹(都加强).否则会有光程差,最大的光程差是最上面的光和最下面的光,事实上决定一个条纹是亮还是暗就取决于这个.<br>$$\delta=BC=a\sin\varphi$$<br>(这个是光程差)</p><p>式子里面的BC是一个方向到透镜的夹角的一个小路程:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*|  /    /</span><br><span class="line"> | /    /</span><br><span class="line">A|/    /</span><br><span class="line"> |\   /</span><br><span class="line"> |  \/<span class="built_in">C</span>(假设BC垂直AC)</span><br><span class="line"> |  /</span><br><span class="line"> | /</span><br><span class="line">B|/</span><br></pre></td></tr></table></figure><p>然后就有最后的公式<br>$$\delta=a\sin\varphi=\begin{cases}0&amp;中央明纹\\ \pm2k\frac\lambda2&amp;暗纹\\ \pm(2k+1)\frac\lambda2&amp;明纹\end{cases}$$</p><h3 id="特别注意">特别注意</h3><p>只有这里是2k入是暗纹,原因是偶数个波长差时AB可以被分成偶数个半波带,然后彼此抵消,就是暗纹的结果了.注意只有这里是特殊的,千万不要记混.</p><h3 id="单缝衍射条纹特点">单缝衍射条纹特点</h3><p>x是条纹和中心O的距离,f是透镜焦距,a是狭缝宽,有<br>$$x=\begin{cases}\pm2k\frac{f\lambda}{2a}&amp;暗\\ \pm(2k+1)\frac{f\lambda}{2a}&amp;明\end{cases}$$<br>注意k从1开始取.</p><p>小结论:中央明条纹宽度是正常条纹宽度的2倍,而且衍射条纹是均匀不变的.(条纹距离可以用两个相邻另一种条纹相减算)</p><h2 id="光栅衍射">光栅衍射</h2><p>光栅就是一个一个小格凑一起的,分为 <strong>反射光栅</strong> 和 <strong>透射光栅</strong>.</p><p>透光的宽度是a,不透光的宽度是b,凑一起就是 <strong>光栅常数</strong>(a+b),一般数量级都在$\mathrm{10^{-5}-10^{-6}m}$的数量级.</p><h3 id="光栅方程">光栅方程</h3><p><strong>主极大</strong>:满足方程的条纹叫主极大.<br>$$(a+b)\sin\varphi=\pm2k\pi,k=0,1,2,…$$<br><strong>极小(暗纹)</strong>:<br>$$(a+b)\sin\varphi=\pm\frac{k’}N\lambda$$<br><strong>次极大</strong>:既满足主极大式子又满足单缝衍射暗条纹条件$a\sin\varphi=k’\lambda$证明第k大条纹不再出现,称为光栅缺级现象.</p><p>所以有缺级的级数是<br>$$k=\frac{a+b}ak’$$</p><h3 id="光栅光谱">光栅光谱</h3><p>第几级就是k=几,直接带进去算.</p><p><strong>色散本领</strong>:<br>$$D_l=\frac{kf}{(a+b)\cos\theta}$$</p><p>完结!喜( )个锤子,真$\mathbf{tm}$长</p>]]></content>
      
      
      <categories>
          
          <category> OTH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Physics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/17/hello-world/"/>
      <url>/2024/05/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><p>人话:Hexo常见指令看这里</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> OTH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OTH </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
