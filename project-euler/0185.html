<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="万能的Astrageldon佬通过Vibe-Coding把这个题给秒了.这么好的库不用可惜了 线性规划… User1234567891011121314151617181920212223242526272829303132333435Number guessing. A set of guessed numbers, along with the hits of digits with both">
<meta property="og:type" content="website">
<meta property="og:title" content="pe-0185">
<meta property="og:url" content="https://narafluorine.github.io/project-euler/0185.html">
<meta property="og:site_name" content="NaraFluorine&#39;s blog">
<meta property="og:description" content="万能的Astrageldon佬通过Vibe-Coding把这个题给秒了.这么好的库不用可惜了 线性规划… User1234567891011121314151617181920212223242526272829303132333435Number guessing. A set of guessed numbers, along with the hits of digits with both">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-12-17T03:45:14.000Z">
<meta property="article:modified_time" content="2025-12-21T07:24:02.422Z">
<meta property="article:author" content="Fluorine Wang">
<meta property="article:tag" content="Math">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>pe-0185</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="NaraFluorine's blog" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4 ">
        
          <header id="header">
  <a class="u-url u-uid" href="/">
  
    
      <img id="logo" alt class="u-logo" src="/images/logo.png" />
    
  
    <div id="title">
      <h1 class="p-name">NaraFluorine&#39;s blog</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="目录"><i class="fa-solid fa-bars fa-2x"></i></a>
      </li>
      <!--
     --><li><a href="/">首页</a></li><!--
   --><!--
     --><li><a href="/about/">关于</a></li><!--
   --><!--
     --><li><a href="/archives/">归档</a></li><!--
   --><!--
     --><li><a href="/tags/">标签</a></li><!--
   --><!--
     --><li><a href="/categories/">分类</a></li><!--
   --><!--
     --><li><a href="/search/">搜索</a></li><!--
   --><!--
     --><li><a href="/friends/">友链</a></li><!--
   --><!--
     --><li><a href="/QSL/">QSL</a></li><!--
   -->
    </ul>
  </div>
  <!--RSS-->
  <!-- {%- if theme.sidebar_rss %}
  <div class="">
    <a target="_blank" class="social-link" href="{{ url_for(theme.sidebar_rss.link) }}" style="color: {{ theme.sidebar_rss.color }};">
      <span class="icon">
        <i class="{{ theme.sidebar_rss.icon }}"></i>
      </span>
      <span class="label">{{ theme.sidebar_rss.text }}</span>
    </a>
  </div>
  {%- endif %} -->
  <!--RSS-->
</header>

        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <p>万能的Astrageldon佬通过Vibe-Coding把这个题给秒了.<br><a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.milp.html">这么好的库</a>不用可惜了</p>
<p>线性规划…</p>
<h2 id="User"><a href="#User" class="headerlink" title="User"></a>User</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Number guessing. A set of guessed numbers, along with the hits of digits with both number and position correct. (Provide an reliable algorithm to) Find the target number. </span><br><span class="line"></span><br><span class="line">The answer is unique </span><br><span class="line">Example: </span><br><span class="line">90342 ;2 correct </span><br><span class="line">70794 ;0 correct </span><br><span class="line">39458 ;2 correct </span><br><span class="line">34109 ;1 correct </span><br><span class="line">51545 ;2 correct </span><br><span class="line">12531 ;1 correct </span><br><span class="line">answer: 39542 </span><br><span class="line"></span><br><span class="line">Example 2: </span><br><span class="line">5616185650518293 ;2 correct </span><br><span class="line">3847439647293047 ;1 correct </span><br><span class="line">5855462940810587 ;3 correct </span><br><span class="line">9742855507068353 ;3 correct </span><br><span class="line">4296849643607543 ;3 correct </span><br><span class="line">3174248439465858 ;1 correct </span><br><span class="line">4513559094146117 ;2 correct </span><br><span class="line">7890971548908067 ;3 correct </span><br><span class="line">8157356344118483 ;1 correct </span><br><span class="line">2615250744386899 ;2 correct </span><br><span class="line">8690095851526254 ;3 correct </span><br><span class="line">6375711915077050 ;1 correct </span><br><span class="line">6913859173121360 ;1 correct </span><br><span class="line">6442889055042768 ;2 correct </span><br><span class="line">2321386104303845 ;0 correct </span><br><span class="line">2326509471271448 ;2 correct </span><br><span class="line">5251583379644322 ;2 correct </span><br><span class="line">1748270476758276 ;3 correct </span><br><span class="line">4895722652190306 ;1 correct </span><br><span class="line">3041631117224635 ;3 correct </span><br><span class="line">1841236454324589 ;3 correct </span><br><span class="line">2659862637316867 ;2 correct</span><br></pre></td></tr></table></figure>
<h2 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Nice puzzle — this is just a constraint-satisfaction problem: each guess gives an exact equality on how many positions must match the secret. Below I give a few reliable ways to solve it (from simplest/brute force to solver encodings), an efficient backtracking algorithm with pruning you can run immediately, and a short explanation why it works.</span><br><span class="line"></span><br><span class="line">Idea (short)</span><br><span class="line"></span><br><span class="line">Let the secret be an N-digit string s[0..N-1]. For each guess g we know:</span><br><span class="line"></span><br><span class="line">matches(g, s) := number of indices i with s[i] == g[i]  == given_count_g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">So each guess is a constraint on the number of equal positions (a Hamming-match constraint). Find an s that satisfies all constraints. If the answer is unique, this returns that one.</span><br><span class="line"></span><br><span class="line">Method 1 — Backtracking with pruning (practical &amp; reliable)</span><br><span class="line"></span><br><span class="line">Backtracking tries digits for positions one by one; prune early whenever any guess cannot possibly reach its required match count given the already assigned positions.</span><br><span class="line"></span><br><span class="line">Key pruning test for each guess g during search:</span><br><span class="line"></span><br><span class="line">fixed = number of positions already assigned where assigned_digit == g[pos].</span><br><span class="line"></span><br><span class="line">remaining = number of positions not yet assigned.</span><br><span class="line"></span><br><span class="line">If fixed &gt; required_g then impossible → prune.</span><br><span class="line"></span><br><span class="line">If fixed + remaining &lt; required_g then impossible → prune.</span><br><span class="line"></span><br><span class="line">These two checks are sufficient to cut huge parts of search and are correct because any unassigned position could at best become a match later (or not).</span><br><span class="line"></span><br><span class="line">To make search fast:</span><br><span class="line"></span><br><span class="line">Choose positions in a constrained order (e.g. positions where guesses disagree most — positions with many different digits among guesses), that creates earlier pruning.</span><br><span class="line"></span><br><span class="line">If you know the secret cannot start with 0 (no leading zero), enforce that.</span><br><span class="line"></span><br><span class="line">Below is a ready-to-run Python implementation (pure, no external solver required).</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python: backtracking solver for the &quot;exact-position&quot; number-guessing puzzle.</span></span><br><span class="line"><span class="comment"># Input: guesses: list of strings (all same length), counts: list of ints</span></span><br><span class="line"><span class="comment"># Output: list of all solutions (usually 0 or 1 as user said &quot;unique&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve_by_backtrack</span>(<span class="params">guesses: <span class="type">List</span>[<span class="built_in">str</span>], counts: <span class="type">List</span>[<span class="built_in">int</span>], allow_leading_zero: <span class="built_in">bool</span> = <span class="literal">True</span></span>):</span><br><span class="line">    N = <span class="built_in">len</span>(guesses[<span class="number">0</span>])</span><br><span class="line">    G = <span class="built_in">len</span>(guesses)</span><br><span class="line">    <span class="comment"># sanity</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">all</span>(<span class="built_in">len</span>(g) == N <span class="keyword">for</span> g <span class="keyword">in</span> guesses)</span><br><span class="line">    <span class="comment"># order positions by &quot;constraintness&quot;: positions with most distinct guess digits first</span></span><br><span class="line">    pos_scores = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        distinct_digits = <span class="built_in">len</span>(<span class="built_in">set</span>(g[i] <span class="keyword">for</span> g <span class="keyword">in</span> guesses))</span><br><span class="line">        pos_scores.append(( -distinct_digits, i))  <span class="comment"># negative so sort desc</span></span><br><span class="line">    pos_scores.sort()</span><br><span class="line">    order = [p <span class="keyword">for</span> (_, p) <span class="keyword">in</span> pos_scores]   <span class="comment"># list of positions to assign in this order</span></span><br><span class="line"></span><br><span class="line">    assigned = [<span class="string">&#x27;?&#x27;</span>] * N</span><br><span class="line">    solutions = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Precompute per-guess arrays for quick update</span></span><br><span class="line">    <span class="comment"># We&#x27;ll track fixedMatches[gi] = current fixed matches for guess gi</span></span><br><span class="line">    fixedMatches = [<span class="number">0</span>] * G</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">depth</span>):</span><br><span class="line">        <span class="keyword">if</span> depth == N:</span><br><span class="line">            <span class="comment"># check final solution</span></span><br><span class="line">            s = <span class="string">&#x27;&#x27;</span>.join(assigned)</span><br><span class="line">            <span class="keyword">for</span> gi, g <span class="keyword">in</span> <span class="built_in">enumerate</span>(guesses):</span><br><span class="line">                matches = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N) <span class="keyword">if</span> s[i] == g[i])</span><br><span class="line">                <span class="keyword">if</span> matches != counts[gi]:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            solutions.append(<span class="string">&#x27;&#x27;</span>.join(assigned))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        pos = order[depth]</span><br><span class="line">        digits = [<span class="built_in">str</span>(d) <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">        <span class="comment"># optional: avoid leading zero if not allowed</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> allow_leading_zero <span class="keyword">and</span> pos == <span class="number">0</span>:</span><br><span class="line">            digits = [<span class="built_in">str</span>(d) <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> digits:</span><br><span class="line">            <span class="comment"># assign</span></span><br><span class="line">            assigned[pos] = d</span><br><span class="line">            <span class="comment"># update fixedMatches incrementally, but remember to undo</span></span><br><span class="line">            changed = []</span><br><span class="line">            prune = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> gi, g <span class="keyword">in</span> <span class="built_in">enumerate</span>(guesses):</span><br><span class="line">                <span class="keyword">if</span> g[pos] == d:</span><br><span class="line">                    fixedMatches[gi] += <span class="number">1</span></span><br><span class="line">                    changed.append(gi)</span><br><span class="line">            <span class="comment"># Now prune using feasibility for each guess</span></span><br><span class="line">            remaining_unassigned = N - (depth + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> gi <span class="keyword">in</span> <span class="built_in">range</span>(G):</span><br><span class="line">                fixed = fixedMatches[gi]</span><br><span class="line">                required = counts[gi]</span><br><span class="line">                <span class="comment"># maximum possible matches achievable = fixed + remaining_unassigned</span></span><br><span class="line">                <span class="keyword">if</span> fixed &gt; required <span class="keyword">or</span> fixed + remaining_unassigned &lt; required:</span><br><span class="line">                    prune = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> prune:</span><br><span class="line">                backtrack(depth + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># undo</span></span><br><span class="line">            <span class="keyword">for</span> gi <span class="keyword">in</span> changed:</span><br><span class="line">                fixedMatches[gi] -= <span class="number">1</span></span><br><span class="line">            assigned[pos] = <span class="string">&#x27;?&#x27;</span></span><br><span class="line">            <span class="comment"># optional early stop if we already found &gt;1 solutions (if you only need uniqueness)</span></span><br><span class="line">            <span class="comment"># if len(solutions) &gt; 1: return</span></span><br><span class="line"></span><br><span class="line">    backtrack(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> solutions</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example usage:</span></span><br><span class="line"><span class="comment"># guesses = [&quot;90342&quot;,&quot;70794&quot;,&quot;39458&quot;,&quot;34109&quot;,&quot;51545&quot;,&quot;12531&quot;]</span></span><br><span class="line"><span class="comment"># counts = [2,0,2,1,2,1]</span></span><br><span class="line"><span class="comment"># print(solve_by_backtrack(guesses, counts, allow_leading_zero=True))</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">This code finds the correct candidate quickly for the 5-digit example and scales to lengths like 16 (second example) reasonably well because constraints are strong.</span><br><span class="line"></span><br><span class="line">Method 2 — Integer Linear Programming (ILP) / SAT (systematic + scalable)</span><br><span class="line"></span><br><span class="line">A direct exact encoding as a binary/integer program:</span><br><span class="line"></span><br><span class="line">Variables:</span><br><span class="line"></span><br><span class="line">x_&#123;i,d&#125; ∈ &#123;0,1&#125; for i ∈ [0..N-1], d ∈ &#123;0..9&#125;. x_&#123;i,d&#125;=1 means secret&#x27;s position i holds digit d.</span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">For each position i: sum_&#123;d=0..9&#125; x_&#123;i,d&#125; = 1 (exactly one digit per position).</span><br><span class="line"></span><br><span class="line">For each guess g with required k: sum_&#123;i=0..N-1&#125; x_&#123;i, g[i]&#125; = k (the number of positions that pick the same digit as guess at that position must equal k).</span><br><span class="line"></span><br><span class="line">This is a small 0/1 ILP with N*10 variables and N + G constraints. Any ILP or SAT solver will find the (unique) solution reliably and very fast for realistic N (even N=20 is trivial). For SAT, encode the cardinality constraints with standard encodings (or use a SAT solver with cardinality support).</span><br><span class="line"></span><br><span class="line">Why the backtracking pruning is correct</span><br><span class="line"></span><br><span class="line">When you’ve assigned some positions, for each guess the currently matched positions are fixed matches; the remaining unassigned positions can at best become matches later. So the two inequalities</span><br><span class="line"></span><br><span class="line">fixed_matches &lt;= required &lt;= fixed_matches + remaining_unassigned</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">are necessary conditions; if either fails the partial assignment cannot lead to a valid full assignment, so pruning is safe.</span><br><span class="line"></span><br><span class="line">Complexity notes and practical tips</span><br><span class="line"></span><br><span class="line">Worst-case complexity is still up to 10^N, but with realistic guess sets (many guesses) pruning reduces search drastically.</span><br><span class="line"></span><br><span class="line">Sorting positions by how many distinct guess digits appear there (or by entropy) increases pruning speed.</span><br><span class="line"></span><br><span class="line">If digits may repeat across positions, the algorithms above already handle it.</span><br><span class="line"></span><br><span class="line">If you need maximum robustness, use the ILP/SAT encoding with a solver (very reliable for guaranteed unique solution).</span><br><span class="line"></span><br><span class="line">If you want to prove uniqueness: if your solver returns one solution, add one additional constraint forbidding that solution and re-run; if no other solutions exist, it’s unique.</span><br><span class="line"></span><br><span class="line">Applying to your examples</span><br><span class="line"></span><br><span class="line">The first example (the 5-digit one you gave) is solved quickly by the backtracker and yields 39542 (as you wrote).</span><br><span class="line"></span><br><span class="line">The long 16-digit example is exactly the puzzle that is commonly solved by either the backtracking with pruning above or by an ILP/SAT encoding; both will return the unique 16-digit secret.</span><br><span class="line"></span><br><span class="line">If you want, I can:</span><br><span class="line"></span><br><span class="line">give you a runnable script that reads guesses from a file and prints the unique solution (ready to paste/run), or</span><br><span class="line"></span><br><span class="line">show the ILP formulation in a format usable by e.g. pulp/OR-Tools, or</span><br><span class="line"></span><br><span class="line">run the backtracker on either of your two examples and show the exact runtime/solution (you can tell me whether I should assume leading zeros are allowed). Which would you prefer?</span><br></pre></td></tr></table></figure>
<h2 id="User-1"><a href="#User-1" class="headerlink" title="User"></a>User</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Is that solvable using scipy.optimize.milp? </span><br><span class="line"></span><br><span class="line">That is to say, if this is an integer linear programming issue? </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Doc: </span><br><span class="line"></span><br><span class="line">milp(c, *, integrality=None, bounds=None, constraints=None, options=None) Mixed-integer linear programming Solves problems of the following form: \min_x c^T x such that b_l \le Ax \le b_u, l \le x \le u, x_i\in\mathbb&#123;Z&#125;, i\in X_i where x is a vector of decision variables; c, b_l, b_u, l, and u are vectors; A is a matrix, and X_i is the set of indices of decision variables that must be integral. (In this context, a variable that can assume only integer values is said to be “integral”; it has an “integrality” constraint.) Alternatively, that’s: minimize: c @ x such that: b_l &lt;= A @ x &lt;= b_u l &lt;= x &lt;= u Specified elements of x must be integers By default, l = 0 and u = np.inf unless specified with bounds. Parameters: c1D dense array_like The coefficients of the linear objective function to be minimized. c is converted to a double precision array before the problem is solved. integrality1D dense array_like, optional Indicates the type of integrality constraint on each decision variable. 0 : Continuous variable; no integrality constraint. 1 : Integer variable; decision variable must be an integer within bounds. 2 : Semi-continuous variable; decision variable must be within bounds or take value 0. 3 : Semi-integer variable; decision variable must be an integer within bounds or take value 0. By default, all variables are continuous. integrality is converted to an array of integers before the problem is solved. boundsscipy.optimize.Bounds, optional Bounds on the decision variables. Lower and upper bounds are converted to double precision arrays before the problem is solved. The keep_feasible parameter of the Bounds object is ignored. If not specified, all decision variables are constrained to be non-negative. constraintssequence of scipy.optimize.LinearConstraint, optional Linear constraints of the optimization problem. Arguments may be one of the following: A single LinearConstraint object A single tuple that can be converted to a LinearConstraint object as LinearConstraint(*constraints) A sequence composed entirely of objects of type 1. and 2. Before the problem is solved, all values are converted to double precision, and the matrices of constraint coefficients are converted to instances of scipy.sparse.csc_array. The keep_feasible parameter of LinearConstraint objects is ignored. optionsdict, optional A dictionary of solver options. The following keys are recognized. dispbool (default: False) Set to True if indicators of optimization status are to be printed to the console during optimization. node_limitint, optional The maximum number of nodes (linear program relaxations) to solve before stopping. Default is no maximum number of nodes. presolvebool (default: True) Presolve attempts to identify trivial infeasibilities, identify trivial unboundedness, and simplify the problem before sending it to the main solver. time_limitfloat, optional The maximum number of seconds allotted to solve the problem. Default is no time limit. mip_rel_gapfloat, optional Termination criterion for MIP solver: solver will terminate when the gap between the primal objective value and the dual objective bound, scaled by the primal objective value, is &lt;= mip_rel_gap. Returns: resOptimizeResult An instance of scipy.optimize.OptimizeResult. The object is guaranteed to have the following attributes. statusint An integer representing the exit status of the algorithm. 0 : Optimal solution found. 1 : Iteration or time limit reached. 2 : Problem is infeasible. 3 : Problem is unbounded. 4 : Other; see message for details. successbool True when an optimal solution is found and False otherwise. messagestr A string descriptor of the exit status of the algorithm. The following attributes will also be present, but the values may be None, depending on the solution status. x ndarray The values of the decision variables that minimize the objective function while satisfying the constraints. fun float The optimal value of the objective function c @ x. mip_node_count int The number of subproblems or “nodes” solved by the MILP solver. mip_dual_bound float The MILP solver’s final estimate of the lower bound on the optimal solution. mip_gap float The difference between the primal objective value and the dual objective bound, scaled by the primal objective value.</span><br></pre></td></tr></table></figure>
<h2 id="GPT-1"><a href="#GPT-1" class="headerlink" title="GPT"></a>GPT</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Yes — this is a perfect fit for scipy.optimize.milp. The problem is a small 0/1 MILP:</span><br><span class="line"></span><br><span class="line">variables x_&#123;i,d&#125; ∈ &#123;0,1&#125; meaning “position i has digit d” (so N*10 variables),</span><br><span class="line"></span><br><span class="line">for every position i: sum_&#123;d=0..9&#125; x_&#123;i,d&#125; = 1 (exactly one digit per position),</span><br><span class="line"></span><br><span class="line">for every guess g with required count k: sum_&#123;i=0..N-1&#125; x_&#123;i,g[i]&#125; = k (exactly k position matches with that guess),</span><br><span class="line"></span><br><span class="line">bounds 0 ≤ x ≤ 1 and integrality = integer (so bounds force binaries).</span><br><span class="line"></span><br><span class="line">Below is a ready-to-run implementation using scipy.optimize.milp. It also includes an optional uniqueness check (adds a constraint forbidding the found solution and re-solves). Paste &amp; run in a Python environment with SciPy ≥1.11 (milp API).</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.sparse <span class="keyword">import</span> lil_matrix</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> Bounds, LinearConstraint, milp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve_with_scipy_milp</span>(<span class="params">guesses, counts, allow_leading_zero=<span class="literal">True</span>, options=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    guesses: list of equal-length digit-strings, e.g. [&quot;90342&quot;,&quot;70794&quot;,...]</span></span><br><span class="line"><span class="string">    counts:  list of integers (match counts for each guess)</span></span><br><span class="line"><span class="string">    allow_leading_zero: if False, forbid digit 0 at position 0</span></span><br><span class="line"><span class="string">    options: dict passed to milp(..., options=options)</span></span><br><span class="line"><span class="string">    Returns: (solution_string or None, milp_result)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    G = <span class="built_in">len</span>(guesses)</span><br><span class="line">    N = <span class="built_in">len</span>(guesses[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">all</span>(<span class="built_in">len</span>(g) == N <span class="keyword">for</span> g <span class="keyword">in</span> guesses)</span><br><span class="line">    <span class="comment"># number of variables = N positions * 10 digits</span></span><br><span class="line">    nvars = N * <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># objective (zero — we only want feasibility)</span></span><br><span class="line">    c = np.zeros(nvars)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># integrality: make all integer (1 =&gt; integer). Bounds 0..1 then force binary.</span></span><br><span class="line">    integrality = np.ones(nvars, dtype=<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># bounds: 0 &lt;= x &lt;= 1 for all variables</span></span><br><span class="line">    lb = np.zeros(nvars, dtype=<span class="built_in">float</span>)</span><br><span class="line">    ub = np.ones(nvars, dtype=<span class="built_in">float</span>)</span><br><span class="line">    <span class="comment"># forbid leading zero if requested</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> allow_leading_zero:</span><br><span class="line">        <span class="comment"># variable index for position 0 digit 0 is idx = 0*10 + 0 = 0</span></span><br><span class="line">        ub[<span class="number">0</span>] = <span class="number">0.0</span>  <span class="comment"># x_&#123;0,0&#125; == 0</span></span><br><span class="line"></span><br><span class="line">    bounds = Bounds(lb, ub)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Build linear constraints Ax with equality bounds (use bl == bu)</span></span><br><span class="line">    <span class="comment"># Number of constraints = N (position constraints) + G (guess-count constraints)</span></span><br><span class="line">    m = N + G</span><br><span class="line">    A = lil_matrix((m, nvars), dtype=<span class="built_in">int</span>)</span><br><span class="line">    bl = np.zeros(m, dtype=<span class="built_in">float</span>)</span><br><span class="line">    bu = np.zeros(m, dtype=<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1) position constraints: for each position i, sum_d x_&#123;i,d&#125; == 1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        row = i</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            idx = i*<span class="number">10</span> + d</span><br><span class="line">            A[row, idx] = <span class="number">1</span></span><br><span class="line">        bl[row] = bu[row] = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2) guess constraints: for each guess g, sum_i x_&#123;i, g[i]&#125; == counts[g]</span></span><br><span class="line">    <span class="keyword">for</span> gi, g <span class="keyword">in</span> <span class="built_in">enumerate</span>(guesses):</span><br><span class="line">        row = N + gi</span><br><span class="line">        cnt = counts[gi]</span><br><span class="line">        bl[row] = bu[row] = <span class="built_in">float</span>(cnt)</span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(g):</span><br><span class="line">            d = <span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)  <span class="comment"># digit</span></span><br><span class="line">            idx = i*<span class="number">10</span> + d</span><br><span class="line">            <span class="comment"># each position contributes at most 1 to the match with this guess</span></span><br><span class="line">            A[row, idx] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    A = A.tocsc()</span><br><span class="line">    lincon = LinearConstraint(A, bl, bu)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Solve</span></span><br><span class="line">    res = milp(c, integrality=integrality, bounds=bounds, constraints=[lincon], options=options)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> res.success:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># extract solution digits (round because solver works in doubles)</span></span><br><span class="line">    x = res.x</span><br><span class="line">    <span class="comment"># tolerance for deciding 1 vs 0</span></span><br><span class="line">    sol_digits = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        chosen = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            idx = i*<span class="number">10</span> + d</span><br><span class="line">            <span class="keyword">if</span> x[idx] &gt; <span class="number">0.5</span>:  <span class="comment"># should be very close to 0 or 1</span></span><br><span class="line">                chosen = d</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> chosen == -<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># unexpected; treat as failure</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>, res</span><br><span class="line">        sol_digits.append(<span class="built_in">str</span>(chosen))</span><br><span class="line">    solution = <span class="string">&#x27;&#x27;</span>.join(sol_digits)</span><br><span class="line">    <span class="keyword">return</span> solution, res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_uniqueness</span>(<span class="params">guesses, counts, solution, options=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Add a constraint forbidding &#x27;solution&#x27; and re-solve. If infeasible, original solution was unique.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    N = <span class="built_in">len</span>(solution)</span><br><span class="line">    nvars = N * <span class="number">10</span></span><br><span class="line">    <span class="comment"># Build the same base constraints as before</span></span><br><span class="line">    <span class="comment"># (copy/paste from solve_with_scipy_milp or refactor)</span></span><br><span class="line">    c = np.zeros(nvars)</span><br><span class="line">    integrality = np.ones(nvars, dtype=<span class="built_in">int</span>)</span><br><span class="line">    lb = np.zeros(nvars, dtype=<span class="built_in">float</span>)</span><br><span class="line">    ub = np.ones(nvars, dtype=<span class="built_in">float</span>)</span><br><span class="line">    bounds = Bounds(lb, ub)</span><br><span class="line"></span><br><span class="line">    m = N + <span class="built_in">len</span>(guesses)</span><br><span class="line">    A = lil_matrix((m+<span class="number">1</span>, nvars), dtype=<span class="built_in">int</span>)  <span class="comment"># +1 for the &quot;forbid solution&quot; constraint</span></span><br><span class="line">    bl = np.zeros(m+<span class="number">1</span>, dtype=<span class="built_in">float</span>)</span><br><span class="line">    bu = np.zeros(m+<span class="number">1</span>, dtype=<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># position constraints</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        row = i</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            idx = i*<span class="number">10</span> + d</span><br><span class="line">            A[row, idx] = <span class="number">1</span></span><br><span class="line">        bl[row] = bu[row] = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># guess constraints</span></span><br><span class="line">    <span class="keyword">for</span> gi, g <span class="keyword">in</span> <span class="built_in">enumerate</span>(guesses):</span><br><span class="line">        row = N + gi</span><br><span class="line">        cnt = counts[gi]</span><br><span class="line">        bl[row] = bu[row] = <span class="built_in">float</span>(cnt)</span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(g):</span><br><span class="line">            d = <span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            idx = i*<span class="number">10</span> + d</span><br><span class="line">            A[row, idx] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># forbid exact same solution: sum_&#123;i&#125; x_&#123;i, sol[i]&#125; &lt;= N-1</span></span><br><span class="line">    forbid_row = m</span><br><span class="line">    <span class="keyword">for</span> i, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(solution):</span><br><span class="line">        d = <span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        idx = i*<span class="number">10</span> + d</span><br><span class="line">        A[forbid_row, idx] = <span class="number">1</span></span><br><span class="line">    bl[forbid_row] = -np.inf</span><br><span class="line">    bu[forbid_row] = N - <span class="number">1</span>  <span class="comment"># force at least one position differ</span></span><br><span class="line"></span><br><span class="line">    A = A.tocsc()</span><br><span class="line">    lincon = LinearConstraint(A, bl, bu)</span><br><span class="line">    res2 = milp(c, integrality=integrality, bounds=bounds, constraints=[lincon], options=options)</span><br><span class="line">    <span class="comment"># If res2.status == 2 (infeasible) then no other solution exists =&gt; unique</span></span><br><span class="line">    <span class="keyword">return</span> res2</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Example usage with the 1st sample ---</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    guesses = [<span class="string">&quot;90342&quot;</span>,<span class="string">&quot;70794&quot;</span>,<span class="string">&quot;39458&quot;</span>,<span class="string">&quot;34109&quot;</span>,<span class="string">&quot;51545&quot;</span>,<span class="string">&quot;12531&quot;</span>]</span><br><span class="line">    counts  = [<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">    sol, r = solve_with_scipy_milp(guesses, counts, allow_leading_zero=<span class="literal">True</span>,</span><br><span class="line">                                  options=&#123;<span class="string">&quot;presolve&quot;</span>: <span class="literal">True</span>, <span class="string">&quot;disp&quot;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;solution:&quot;</span>, sol)</span><br><span class="line">    <span class="comment"># uniqueness check</span></span><br><span class="line">    <span class="keyword">if</span> sol <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        r2 = check_uniqueness(guesses, counts, sol, options=&#123;<span class="string">&quot;presolve&quot;</span>: <span class="literal">True</span>&#125;)</span><br><span class="line">        <span class="keyword">if</span> r2.status == <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Unique solution confirmed (no other solution).&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Another solution exists or solver returned feasible alternative; check r2.status:&quot;</span>, r2.status)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Notes &amp; tips</span><br><span class="line"></span><br><span class="line">Binary vs integer: integrality=1 + 0 ≤ x ≤ 1 forces binary variables (0 or 1). We use that pattern above.</span><br><span class="line"></span><br><span class="line">Objective: we used zero objective (c = 0) so solver finds any feasible integer solution. If you want a deterministic tie-breaker (not normally necessary) you can set a tiny lexicographic objective, but zero objective is fine.</span><br><span class="line"></span><br><span class="line">Numerical tolerance: res.x is double; check using &gt; 0.5 (or round) to decide which variables are chosen.</span><br><span class="line"></span><br><span class="line">Performance: tiny problem sizes (e.g. N=16 =&gt; 160 variables) are trivial for modern MILP solvers; SciPy’s MILP will quickly find a solution.</span><br><span class="line"></span><br><span class="line">Uniqueness test: after you get a solution, add the “forbid exact solution” constraint (sum chosen_vars ≤ N-1) and resolve. If result is infeasible, the solution is unique. (I included check_uniqueness above.)</span><br><span class="line"></span><br><span class="line">Leading-zero rule: to forbid leading zero set ub[idx_for_pos0_digit0] = 0.</span><br><span class="line"></span><br><span class="line">Solver options: you can pass options=&#123;&#x27;time_limit&#x27;:..., &#x27;node_limit&#x27;:..., &#x27;presolve&#x27;: True&#125;.</span><br><span class="line"></span><br><span class="line">Caveats</span><br><span class="line"></span><br><span class="line">SciPy’s milp is a wrapper around its internal MIP solver (IPX or HiGHS MIP backend depending on your SciPy version); it works fine on these sizes. If you need advanced tuning or best performance you can also use specialized MILP solvers (CBC, Gurobi, CPLEX, OR-Tools), but that’s unnecessary for typical puzzles.</span><br><span class="line"></span><br><span class="line">Because the MILP is exact (integrality enforced), the solution is combinatorially exact; numerical rounding is only used to interpret the returned double vector.</span><br><span class="line"></span><br><span class="line">If you like, I can:</span><br><span class="line"></span><br><span class="line">produce a small runnable script that reads guesses from a file or stdin and prints the unique solution and verification, or</span><br><span class="line"></span><br><span class="line">show the equivalent pulp or ortools encoding instead. Which do you prefer?</span><br></pre></td></tr></table></figure>
        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024-2026
    Fluorine Wang
  </div>
  <!-- 不蒜子统计 -->
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
  <!-- 不蒜子统计 -->
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/tags/">标签</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     --><!--
       --><li><a href="/friends/">友链</a></li><!--
     --><!--
       --><li><a href="/QSL/">QSL</a></li><!--
     -->
      </ul>
    </nav>
  </div>

</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
