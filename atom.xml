<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fluorine&#39;s blog</title>
  
  <subtitle>菜 Noob</subtitle>
  <link href="https://narafluorine.github.io/atom.xml" rel="self"/>
  
  <link href="https://narafluorine.github.io/"/>
  <updated>2024-10-12T14:53:06.751Z</updated>
  <id>https://narafluorine.github.io/</id>
  
  <author>
    <name>Fluorine Wengers</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>生成函数</title>
    <link href="https://narafluorine.github.io/2024/10/12/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    <id>https://narafluorine.github.io/2024/10/12/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</id>
    <published>2024-10-12T13:20:37.000Z</published>
    <updated>2024-10-12T14:53:06.751Z</updated>
    
    <content type="html"><![CDATA[<p>生成函数,又叫</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;生成函数,又叫&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Math" scheme="https://narafluorine.github.io/categories/Math/"/>
    
    
    <category term="NumberTheory" scheme="https://narafluorine.github.io/tags/NumberTheory/"/>
    
  </entry>
  
  <entry>
    <title>树剖</title>
    <link href="https://narafluorine.github.io/2024/10/12/%E6%A0%91%E5%89%96/"/>
    <id>https://narafluorine.github.io/2024/10/12/%E6%A0%91%E5%89%96/</id>
    <published>2024-10-11T17:29:40.000Z</published>
    <updated>2024-10-12T02:34:09.635Z</updated>
    
    <content type="html"><![CDATA[<p>Flu:长大以后,我要学树剖,麻麻可高兴了,给我爱吃的大嘴巴子…</p><p>非得学一些用不到的算法干啥…</p><h2 id="代码解释">代码解释</h2><h3 id="处理u到v的最短路径">处理u到v的最短路径</h3><p>id就是dfn.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qRange</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;<span class="comment">//当两个点不在同一条链上 </span></span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])<span class="built_in">swap</span>(x,y);<span class="comment">//把x点改为所在链顶端的深度更深的那个点</span></span><br><span class="line">        res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[x]],id[x]);<span class="comment">//ans加上x点到x所在链顶端 这一段区间的点权和</span></span><br><span class="line">        ans+=res;</span><br><span class="line">        ans%=mod;<span class="comment">//按题意取模 </span></span><br><span class="line">        x=fa[top[x]];<span class="comment">//把x跳到x所在链顶端的那个点的上面一个点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直到两个点处于一条链上</span></span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y])<span class="built_in">swap</span>(x,y);<span class="comment">//把x点深度更深的那个点</span></span><br><span class="line">    res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[y]);<span class="comment">//这时再加上此时两个点的区间和即可</span></span><br><span class="line">    ans+=res;</span><br><span class="line">    <span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理rt为根的子树">处理rt为根的子树</h3><p>结论:树rt的子树的区间是 <code>[dfn[n],dfn[n]+siz[n]-1]</code> .</p><p>所以这玩意比两个点还好改.</p><h2 id="树剖解决的问题">树剖解决的问题</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Flu:长大以后,我要学树剖,麻麻可高兴了,给我爱吃的大嘴巴子…&lt;/p&gt;
&lt;p&gt;非得学一些用不到的算法干啥…&lt;/p&gt;
&lt;h2 id=&quot;代码解释&quot;&gt;代码解释&lt;/h2&gt;
&lt;h3 id=&quot;处理u到v的最短路径&quot;&gt;处理u到v的最短路径&lt;/h3&gt;
&lt;p&gt;id就是dfn.&lt;/p&gt;
&lt;f</summary>
      
    
    
    
    <category term="DataStructure" scheme="https://narafluorine.github.io/categories/DataStructure/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>网页收藏夹</title>
    <link href="https://narafluorine.github.io/2024/10/07/%E7%BD%91%E9%A1%B5%E6%94%B6%E8%97%8F%E5%A4%B9/"/>
    <id>https://narafluorine.github.io/2024/10/07/%E7%BD%91%E9%A1%B5%E6%94%B6%E8%97%8F%E5%A4%B9/</id>
    <published>2024-10-07T09:20:19.000Z</published>
    <updated>2024-10-07T09:22:46.123Z</updated>
    
    <content type="html"><![CDATA[<p>不常用的网页会放到这里.</p><h2 id="游戏">游戏</h2><h2 id="OJ">OJ</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不常用的网页会放到这里.&lt;/p&gt;
&lt;h2 id=&quot;游戏&quot;&gt;游戏&lt;/h2&gt;
&lt;h2 id=&quot;OJ&quot;&gt;OJ&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/categories/OTH/"/>
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/tags/OTH/"/>
    
  </entry>
  
  <entry>
    <title>Linux笔记</title>
    <link href="https://narafluorine.github.io/2024/09/23/Linux%E7%AC%94%E8%AE%B0/"/>
    <id>https://narafluorine.github.io/2024/09/23/Linux%E7%AC%94%E8%AE%B0/</id>
    <published>2024-09-23T14:11:34.000Z</published>
    <updated>2024-09-24T01:56:26.845Z</updated>
    
    <content type="html"><![CDATA[<p>舍友今天告诉我说是这周五多了一节Linux课,地点是在计算机楼…哦豁完蛋,Flu准备花几天时间速通一下Linux,真是没办法…</p><h2 id="Linux史">Linux史</h2><p>妈的,想不通为什么啥课都他妈要先讲讲历史…讲历史就算了,还他妈考试考,这就是什么逼东西…</p><p>咕咕,Flu要尽快学会使用Linux.</p><h2 id="使用">使用</h2><h3 id="Putty登录简述">Putty登录简述</h3><h3 id="管理员">管理员</h3><p>root,根用户.拥有最高权限.<br>普通用户的提示符是 <code>$</code> ,管理员的命令提示符是 <code>#</code> .(这个可以设置,丰富系统信息)</p><h3 id="命令">命令</h3><p>格式是 <code>$ 命令 [-选项] [参数]</code> 表示三个字段.</p><h3 id="简单的命令手册">简单的命令手册</h3><p><code>passwd</code> :修改密码.<br><code>passwd username</code> :修改别人密码.(显然,只有管理员可以)(root用户创建新用户时分配初始口令)<br><code>exit</code> :退出系统.<br><code>logout</code> :退出系统.<br><code>[Ctrl+d]</code> :退出系统.<br><code>date</code> :系统告诉你当前时间.<br><code>:  </code> :<br>`` :</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;舍友今天告诉我说是这周五多了一节Linux课,地点是在计算机楼…哦豁完蛋,Flu准备花几天时间速通一下Linux,真是没办法…&lt;/p&gt;
&lt;h2 id=&quot;Linux史&quot;&gt;Linux史&lt;/h2&gt;
&lt;p&gt;妈的,想不通为什么啥课都他妈要先讲讲历史…讲历史就算了,还他妈考试考,这就是</summary>
      
    
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/categories/OTH/"/>
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/tags/OTH/"/>
    
  </entry>
  
  <entry>
    <title>ICPC网络赛</title>
    <link href="https://narafluorine.github.io/2024/09/21/ICPC%E7%BD%91%E7%BB%9C%E8%B5%9B/"/>
    <id>https://narafluorine.github.io/2024/09/21/ICPC%E7%BD%91%E7%BB%9C%E8%B5%9B/</id>
    <published>2024-09-21T15:40:02.000Z</published>
    <updated>2024-09-23T02:57:07.515Z</updated>
    
    <content type="html"><![CDATA[<p>第三场网络赛,我们的新队员终于来了,我们队终于不是倒数第一了…</p><p>而且是正数第十一…终于能超过劳伦斯哥哥了,开心.</p><h2 id="收获">收获</h2><ol><li>我学了一个假的Dev_C++…新队友是四指打字的,速度不清楚,反正打起字来空格用的比较多,码风是标准的高中OIer码风,算数之间空格加的多,大括号另起一行.</li></ol><blockquote><p>Flu觉得有必要练习一下学习如何使用Dev_C++.</p></blockquote><ol start="2"><li>Flu第一次做出来期望题,居然是在考场…</li></ol><blockquote><p>有必要多看看期望题.</p></blockquote><ol start="3"><li>手滑多交了两发.A题读假了导致浪费了至少一个小时,Flu的高低位输出错了导致至少多半个小时,队友开的都快出来了Flu才改好…</li></ol><blockquote><p>不错,最后一场Flu做对了两个题提供了一个题的板子,也算功德圆满,没沦落为战犯.</p></blockquote><ol start="4"><li>发现浏览器的一个命令: <code>site:xxx.com</code> 可以锁定搜索范围就是该网页.</li></ol><h2 id="补题">补题</h2><h3 id="2L">2L</h3><p>系统初始时会给你一个随机 $[1,T]$ 的值 $t_0$ ,每过一秒, $t_0$ 会自动减1,减完之后你可以选择刷新页面或者不刷新等着 $t_0$ 变成0,从第0秒到 $t_0$ 变成0的这段时间被称作罚时,你希望最小化罚时期望.</p><p>这个题意外地很简单…我们发现每一次刷新都是随机的,所以可以转移.直接设当前期望是 $E$ ,以及罚时为 $[1,x]$ 时不动等自然变成0, $[x+1,T]$ 时手动刷新,可以列出方程<br>$$E=\frac1T\frac{(1+x)x}2+\frac{T-x}T(1+E)$$<br>解一下发现是一个关于T的基本不等式.最小值取在 $x=\sqrt{2T}$ 的位置.<br>题解:从这里开始检查 $x=\lfloor\sqrt{2T}\rfloor$ 和 $\lceil\sqrt{2T}\rceil$ 即可.<br>直接暴力检查.中间因为卡了一下快读(其实是Flu多检查了一下x-1的情况),还T了一发.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第三场网络赛,我们的新队员终于来了,我们队终于不是倒数第一了…&lt;/p&gt;
&lt;p&gt;而且是正数第十一…终于能超过劳伦斯哥哥了,开心.&lt;/p&gt;
&lt;h2 id=&quot;收获&quot;&gt;收获&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;我学了一个假的Dev_C++…新队友是四指打字的,速度不清楚,反正打起字来空格用</summary>
      
    
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/categories/OTH/"/>
    
    
    <category term="Contest" scheme="https://narafluorine.github.io/tags/Contest/"/>
    
  </entry>
  
  <entry>
    <title>二分图</title>
    <link href="https://narafluorine.github.io/2024/09/19/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <id>https://narafluorine.github.io/2024/09/19/%E4%BA%8C%E5%88%86%E5%9B%BE/</id>
    <published>2024-09-19T12:08:14.000Z</published>
    <updated>2024-09-19T14:37:52.312Z</updated>
    
    <content type="html"><![CDATA[<p>二分图就是,点可以分成两拨,左边会和右边连线,然后左边或右边都不会有连向自己的线.</p><p>今天碰到了一个很有意思的题.特此讲一下二分图的匈牙利算法.</p><ol><li>有一辆大巴车,每排能坐两个人,每个人有两个希望坐上的排数,请你给出最多能使多少人满足愿望.</li></ol><p>如何解决一个点能匹配两个人的问题呢?我们可以扩大点集,让人同时和a+n的点连线.这样就可以转换为一个二分图了,直接跑最大匹配就行.</p><p>拓展:貌似点能承受的个数变成 $f(n)$ 也行,只需要简简单单装到一个umap里面就行了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;二分图就是,点可以分成两拨,左边会和右边连线,然后左边或右边都不会有连向自己的线.&lt;/p&gt;
&lt;p&gt;今天碰到了一个很有意思的题.特此讲一下二分图的匈牙利算法.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有一辆大巴车,每排能坐两个人,每个人有两个希望坐上的排数,请你给出最多能使多少人满足愿望.</summary>
      
    
    
    
    <category term="Graph&amp;Network" scheme="https://narafluorine.github.io/categories/Graph-Network/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>哈希</title>
    <link href="https://narafluorine.github.io/2024/09/18/%E5%93%88%E5%B8%8C/"/>
    <id>https://narafluorine.github.io/2024/09/18/%E5%93%88%E5%B8%8C/</id>
    <published>2024-09-17T16:57:48.000Z</published>
    <updated>2024-09-19T03:12:40.802Z</updated>
    
    <content type="html"><![CDATA[<p>如何辨别哈希题?大概就通过一句话:</p><blockquote><p>当需要用 $Θ(1)$ 的时间快速比较两个 $Θ(n)$ 的东西时.</p></blockquote><p>哈希是干嘛的?提供一种映射关系,能够把字符串或者树通过某种加密关系换算成一个数,从而进行比较或者直接排序.</p><p>自然,撞哈希的概率关乎哈希算法的核心.</p><h2 id="生日悖论">生日悖论</h2><p>大概意思就是,任意约 $\sqrt n$ 个元素的时候元素相同的概率就会很高(n是值域).为了防止撞哈希,我们要让值域尽可能大(也就是选择1e16-1e18级别的质数).</p><h2 id="二维哈希">二维哈希</h2><p>矩阵哈希,要求 $O(1)$ 求出相同大小的子矩阵的哈希值.</p><p>我们要从矩阵中提取一个大小为(y,x)的矩阵,咋办?<br>首先要预处理阶乘(处理到矩阵行列最大值就可以了).二位哈希采取双进制的操作,一个是行之间的进制位(1299709),另一个是列之间乘再加的进制位(1e9+7).</p><p>然后要建立哈希表.由于二维哈希是前缀式的,所以要乘上一位再加这一位的数据.然后再前缀和一样的乘,每一位乘列的进制位.参考代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">p1[<span class="number">0</span>]=p2[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">p1[i]=p1[i<span class="number">-1</span>]*dom;</span><br><span class="line">p2[i]=p2[i<span class="number">-1</span>]*mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">x[i][j]=x[i][j<span class="number">-1</span>]*dom+<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">y[i][j]=y[i][j<span class="number">-1</span>]*dom+<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">x[i][j]+=x[i<span class="number">-1</span>][j]*mod;</span><br><span class="line">y[i][j]+=y[i<span class="number">-1</span>][j]*mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公式:<br>$$ask(x_1,x_2,y_1,y_2)=h[x_2][y_2]-h[x_2][y_1-1]*base_1[y_2-y_1+1]-h[x_1-1][y_2]*base_2[x_2-x_1+1]-h[x_1-1][y_1-1]*base_1[y_2-y_1+1]*base_2[x_2-x_1+1]$$<br>参考代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rp=y[i][j]-y[i-k][j]*p2[k]-y[i][j-k]*p1[k]+y[i-k][j-k]*p2[k]*p1[k];</span><br><span class="line"><span class="comment">//p2是1e9+7,p1是小的行之间的质数,k是子矩阵长度</span></span><br></pre></td></tr></table></figure><p>好像子矩阵都可以O(1)求.</p><h2 id="字符串哈希">字符串哈希</h2><p><s>Flu刚开始学字符串哈希的时候真的就是只学哈希来了,umap该开的还是开,字符串哈希完了装umap里,乐</s></p><p>字符串哈希,就是把一段字符串哈希变成一个数(双哈希是变成一对数),然后可以进行排序,然后直接检测有多少哈希值就行了(也就是多少种不同的字符串).</p><p>字符串哈希一般都是进制哈希.主要分为三种实现方法:<strong>自然溢出法(也就是模 $2^64$),单模哈希法(一个很大的质数),双模哈希(返回一对哈希值,据说很难卡掉)</strong>.</p><h2 id="例题">例题</h2><ol><li>矩阵哈希:给你两个矩阵,问两个矩阵中最大的重合子矩阵的大小(边长)是多少.</li></ol><p>我们发现边长是单调的,于是考虑二分.设 $k$ 是当前查验的边长.我们把两个矩阵的所有子矩阵直接哈希加到哈希表里面,然后排个序,直接比较(采用umap可以再掉一个log).时间复杂度是 $O(n^2\log^2n)$ .</p><h2 id="手写哈希表">手写哈希表</h2><p>一般而言有两种方式:拉链法和顺次法.</p><p>我们开一段连续空间,然后在空间内提供哈希算法,模上空间大小,大概就是实际的存储位置.<br><strong>拉链法</strong>:每个单点是一个链表,存储的时候如果哈希冲突就链表加一个节点,访问的时候遍历链表.<br><strong>顺次法</strong>:存储的时候如果哈希冲突,直接顺次访问(n+1),(n+2)等元素.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何辨别哈希题?大概就通过一句话:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当需要用 $Θ(1)$ 的时间快速比较两个 $Θ(n)$ 的东西时.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;哈希是干嘛的?提供一种映射关系,能够把字符串或者树通过某种加密关系换算成一个数,从而进</summary>
      
    
    
    
    <category term="DataStructure" scheme="https://narafluorine.github.io/categories/DataStructure/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>模拟退火</title>
    <link href="https://narafluorine.github.io/2024/09/12/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"/>
    <id>https://narafluorine.github.io/2024/09/12/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/</id>
    <published>2024-09-12T06:02:25.000Z</published>
    <updated>2024-09-12T06:09:35.583Z</updated>
    
    <content type="html"><![CDATA[<p>很简单,我们逐渐退火让答案稳定在某段区间内.</p><p>算法不讲解了,什么以多项式概率接受啥的哪都没用,主要讲怎么应用模拟退火.</p><p>个人认为比较困难的点是如何&quot;渐进地&quot;生成新的逼近的随机答案,不然模拟退火就是单纯的随机数碰答案.</p><h2 id="二元函数求最值">二元函数求最值</h2><h2 id="三分xy的情况">三分xy的情况</h2><p>我们以吊打xxx为例.加入x值定死,势能变化随y是一个单峰函数.</p><p>也就是说,我们可以三分y从而达到理想效果.</p><p>如何三分?考虑一个单峰,假如落在三分中间,那么怎么收缩都是涵盖的.<br>假如没有,我们三分的两个点会是一个明显递增或者递减的趋势,此时收紧,也就是说一次收缩大概1/3,剩下的2/3接着三分即可;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很简单,我们逐渐退火让答案稳定在某段区间内.&lt;/p&gt;
&lt;p&gt;算法不讲解了,什么以多项式概率接受啥的哪都没用,主要讲怎么应用模拟退火.&lt;/p&gt;
&lt;p&gt;个人认为比较困难的点是如何&amp;quot;渐进地&amp;quot;生成新的逼近的随机答案,不然模拟退火就是单纯的随机数碰答案.&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Math" scheme="https://narafluorine.github.io/categories/Math/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>概率与组合数学</title>
    <link href="https://narafluorine.github.io/2024/09/12/%E2%80%9C%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E2%80%9D/"/>
    <id>https://narafluorine.github.io/2024/09/12/%E2%80%9C%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E2%80%9D/</id>
    <published>2024-09-12T06:01:57.000Z</published>
    <updated>2024-09-14T12:53:47.388Z</updated>
    
    <content type="html"><![CDATA[<p>万恶之源组合数学.以及概率.</p><h2 id="插板法">插板法</h2><p>求 $a_1+…+a_k=n$ 的正整数解的个数.答案就是<br>$$\binom{n-1}{k-1}$$<br>非负整数解:借数.<br>$$\binom{n+k-1}{n}$$<br>每组至少要分到 $a_i$ 个呢?假设 $x’$ 是删完必须要加的,我们就转换为求非负解了.<br>$$\binom{n-\sum a_i+k-1}{n-\sum a_i}$$<br>不相邻排列:其实还是借数插在中间,然后组合.<br>$$\binom{n-k+1}{k}$$</p><h2 id="组合数公式">组合数公式</h2><p>$$\binom nm=\binom n{n-m}$$<br>$$\binom nk+\binom n{k+1}=\binom{n+1}k$$<br>$$\binom nk=\frac nk\binom{n-1}{k-1}$$<br>$$\binom nm=\binom n{m-1}+\binom{n-1}{m-1}$$<br>DP求杨辉三角的时候用这个.<br>$$\sum_{i=0}^n\binom ni=2^n$$<br>二项式定理取a=1,b=1的特殊情况.<br>$$\sum_{i=0}^n(-1)^i\binom ni=[n=0]$$<br>二项式定理取a=1,b=-1的特殊情况.<br>$$\sum_{i=0}^m\binom ni\binom m{n-i}=\binom{n+m}m,(n\ge m)$$<br>拆组合数的式子.某些数据结构题会遇到.<br>$$\sum_{i=0}^n\binom ni^2=\binom{2n}n$$<br>上一个式子的特殊情况(n=m).<br>$$\sum_{i=0}^ni\binom ni=n2^{n-1}$$<br>求导可证.<br>$$\sum_{i=0}^ni^2\binom ni=\frac{n(n+1)}22^{n-1}$$<br>也是多项式求导可证.<br>$$\sum_{i=0}^n\binom ik=\binom {n+1}{k+1}$$<br>子集分析可证.<br>$$\binom nr\binom rk=\binom nk\binom{n-k}{r-k}$$<br>定义证明.<br>$$\sum_{i=0}^n\binom{n-i}i=F_{n+1}$$<br>其中, $F_n$ 是斐波那契数列.</p><p><strong>多重组合数</strong> :多重集的排列数就是多重组合数.多重集的排列可以理解为有一个集合 $S={n_1a_1,n_2a_2,…,n_ka_k}$ ,有这么多种相同元素,他的全排列叫做多重组合数,公式<br>$$\binom{n}{n_1,n_2,…,n_k}=\frac{n!}{\prod_{i=1}^kn_i!}$$</p><h2 id="圆排列">圆排列</h2><p>部分圆排列公式:<br>$$Q_n^r=\frac{A_n^r}r=\frac{n!}{r\times(n-r)!}$$</p><h2 id="二项式反演">二项式反演</h2><p>设 $f_n$ 是n个元素形成特定结构的方案数, $g_n$ 是从n个元素选 $i,i\ge0$ 个元素形成结构的方案数.根据f求g有<br>$$g_n=\sum_{i=0}^n\binom nif_i$$<br>根据g求f则有<br>$$f_n=\sum_{i=0}^n\binom ni(-1)^{n-i}g_i$$<br>这个逆推的过程就叫二项式反演.</p><h2 id="容斥原理">容斥原理</h2><p>$$\left|\bigcup_{i=1}^nS_i\right|=\sum_{m=1}^n(-1)^{m-1}\sum_{a_i&lt;a_{i+1}}\left|\bigcap_{i=1}^mS_{a_i}\right|$$<br>下面是求交的容斥.<br>$$\left|\bigcap_{i=1}^nS_i\right|=|U|-\left|\bigcup_{i=1}^n\overline{S_i}\right|$$<br><strong>容斥模型</strong> :式子<br>$$\left|\bigcap_{a_i&lt;a_{i+1}}^{1\le i\le k}S_{a_i}\right|$$<br>的不定方程形式是<br>$$\sum_{i=1}^nx_i=m-\sum_{i=1}^k(b_{a_i}+1)$$</p><h2 id="容斥应用">容斥应用</h2><ol><li>硬币计数:给四种硬币的面值,n次询问每次询问给出四种硬币的数量以及s表示这么多个硬币能够拼凑出s的方案数.</li></ol><p>套模型:也就是求解<br>$$\sum_{i=1}^4C_ix_i=S-\sum_{i=1}^kC_{a_i}(D_{a_i}+1)$$<br>我们首先考虑无限金币,此时就是完全背包.假如一枚金币超过了应当的容量,就要减去对应的差值,枚举子集即可.</p><h2 id="常见误区">常见误区</h2><ol><li>误用组合数<br>概述:由于上一个选了之后会影响下一次选的概率,导致单纯组合数的结果并不是概率出来的结果.</li></ol><blockquote><p>例子:n张A票n张B票,买票的时候是抛硬币决定卖哪张票,问最后两个位置是相同票的概率,此时设想第一位选了一种的时候第二位会发生概率变换导致单纯组合数的概率并不是真正的概率.(问题出在结果判定上,假如没另一种票了就直接剩下的一样,也就是说组合数的概率不一样)<br>$$\xcancel{\frac{n-1}{2n-1}}$$<br>正解:DP,其实也能算组合数,假设最后两张票不一样,就会是前2n-2张票有n-1张A和B票.这个时候的概率就是<br>$$P=C^{n-1}_{2n-2}\Big(\frac12\Big)^{2n-2}=\frac{(2n-2)!}{4^{n-1}(n-1)!(n-1)!}$$<br>实现O(n)计算.答案是1-P.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;万恶之源组合数学.以及概率.&lt;/p&gt;
&lt;h2 id=&quot;插板法&quot;&gt;插板法&lt;/h2&gt;
&lt;p&gt;求 $a_1+…+a_k=n$ 的正整数解的个数.答案就是&lt;br&gt;
$$&#92;binom{n-1}{k-1}$$&lt;br&gt;
非负整数解:借数.&lt;br&gt;
$$&#92;binom{n+k-1}{n}$$</summary>
      
    
    
    
    <category term="Math" scheme="https://narafluorine.github.io/categories/Math/"/>
    
    
    <category term="NumberTheory" scheme="https://narafluorine.github.io/tags/NumberTheory/"/>
    
  </entry>
  
  <entry>
    <title>三角函数库</title>
    <link href="https://narafluorine.github.io/2024/09/11/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%BA%93/"/>
    <id>https://narafluorine.github.io/2024/09/11/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%BA%93/</id>
    <published>2024-09-11T05:04:16.000Z</published>
    <updated>2024-09-11T10:46:55.460Z</updated>
    
    <content type="html"><![CDATA[<p>常见的三角函数库.以及 <code>float</code> , <code>double</code> 范围.</p><h2 id="float">float</h2><p>范围大概是 <code>1e-38~1e38</code> .精度大概是7位.</p><h2 id="double">double</h2><p>范围: <code>1e-308~1e308</code> .精度大概是15-16位.</p><h2 id="三角函数">三角函数</h2><p><code>sin</code><br><code>cos</code><br><code>tan</code><br><code>asin</code><br><code>acos</code><br><code>atan</code><br><code>atan2(double y,double x)</code> :传入 $(y,x)$ ,输出与 $x$ 轴正方向角度(坐标轴下是负值).</p><p>参数: <code>sin</code> , <code>sinf</code> , <code>sinl</code> ,其实都差不多,单纯是传入参数的区别.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;常见的三角函数库.以及 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; 范围.&lt;/p&gt;
&lt;h2 id=&quot;float&quot;&gt;float&lt;/h2&gt;
&lt;p&gt;范围大概是 &lt;code&gt;1e-38~1e38&lt;/code&gt; .精度大概是7位.&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    <category term="Math" scheme="https://narafluorine.github.io/categories/Math/"/>
    
    
    <category term="C++" scheme="https://narafluorine.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>万能欧几里得</title>
    <link href="https://narafluorine.github.io/2024/09/10/%E4%B8%87%E8%83%BD%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    <id>https://narafluorine.github.io/2024/09/10/%E4%B8%87%E8%83%BD%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</id>
    <published>2024-09-10T09:54:53.000Z</published>
    <updated>2024-09-10T13:26:14.676Z</updated>
    
    <content type="html"><![CDATA[<p>万能欧几里得推式子的时间.</p><p>万能欧几里得的作用是求一些类似辗转相除的算法,需要递归求解的东西.万能欧几里得的泛用性在于主板子基本不用换,只需要稍微修改合并部分的代码.</p><p>可以使用矩阵的思想.</p><ol><li>求<br>$$\sum_{i=0}^{n}\left\lfloor\frac{ai+b}{c}\right\rfloor, \sum_{i=0}^{n}\left\lfloor\frac{ai+b}{c}\right\rfloor^{2}, \sum_{i=0}^{n}i\left\lfloor\frac{ai+b}{c}\right\rfloor $$<br>设<br>$$f(x)=\lfloor\frac{Px+R}Q\rfloor $$<br>求：<br>$$\sum_{i=1}^nf(i),\sum_{i=1}^nf^2(i),\sum_{i=1}^nif(i)$$<br>下文设$y=f(x)$,即求：<br>$$A=\sum y,B=\sum y^{2},C=\sum xy$$<br>一般万欧都需要维护$U$和$R$的数量(记为$u$和$r$).</li></ol><p>合并两段信息$I_0$与$I_{1}$,结果为$I$ ,考虑增量:<br>$$y\leftarrow y_1+u_0 \<br>x\leftarrow x_1+r_0$$<br>$$\begin{aligned}<br>A-A_0&amp;=\sum y \<br>&amp;=\sum(y_1+u_0) \<br>&amp;=\sum y_1+u_0r_1 \<br>&amp;=A_1+u_0r_1 \<br>B-B_{0} &amp;=\sum y^2 \<br>&amp;=\sum(y_1+u_0)^2 \<br>&amp;=\sum y_1^2+2u_0\sum y_1+u_0^2r_1 \<br>&amp;=B_1+2u_0A_1+u_0^2r_1 \<br>C-C_0 &amp;=\sum xy \<br>&amp;=\sum(x_1+r_0)(y_1+u_0) \<br>&amp;=\sum x_1y_1+u_0\sum x_1+r_0\sum y_1+u_0r_0r_1 \<br>&amp;=C_1+u_0\frac{r_1(r_1+1)}2+r_0A_1+u_0r_0r_1<br>\end{aligned}$$<br>也就是说 $\sum$ 里面(y)加 $u$ ,外面加 $r$ .</p><h2 id="弊端">弊端</h2><p>$$\sum\sqrt{y},\sum x^y,\sum a^{xy},\sum2^{2^y},\sum Asin(wy+\phi)$$<br>由于单维影响无法差分线性,即我们无法设计出一个好的矩阵来表达其值,所以上述式子均无法计算.</p><p>崩:loj138没调出来.<br>loj6440.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> enter fout&lt;&lt;<span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> space fout&lt;&lt;<span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dot fout&lt;&lt;<span class="string">&quot;,&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> oui fout&lt;&lt;<span class="string">&quot;Yes&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> non fout&lt;&lt;<span class="string">&quot;No&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si fout&lt;&lt;<span class="string">&quot;?&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> fastio&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> bufl=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> base1[<span class="number">16</span>]=&#123;<span class="number">1</span>,<span class="number">1e-1</span>,<span class="number">1e-2</span>,<span class="number">1e-3</span>,<span class="number">1e-4</span>,<span class="number">1e-5</span>,<span class="number">1e-6</span>,<span class="number">1e-7</span>,<span class="number">1e-8</span>,<span class="number">1e-9</span>,<span class="number">1e-10</span>,<span class="number">1e-11</span>,<span class="number">1e-12</span>,<span class="number">1e-13</span>,<span class="number">1e-14</span>,<span class="number">1e-15</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> base2[<span class="number">16</span>]=&#123;<span class="number">1</span>,<span class="number">1e1</span>,<span class="number">1e2</span>,<span class="number">1e3</span>,<span class="number">1e4</span>,<span class="number">1e5</span>,<span class="number">1e6</span>,<span class="number">1e7</span>,<span class="number">1e8</span>,<span class="number">1e9</span>,<span class="number">1e10</span>,<span class="number">1e11</span>,<span class="number">1e12</span>,<span class="number">1e13</span>,<span class="number">1e14</span>,<span class="number">1e15</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IN</span>&#123;</span><br><span class="line">FILE *IT;<span class="type">char</span> ibuf[bufl],*is=ibuf,*it=ibuf;</span><br><span class="line"><span class="built_in">IN</span>()&#123;IT=stdin;&#125;<span class="built_in">IN</span>(<span class="type">char</span> *a)&#123;IT=<span class="built_in">fopen</span>(a,<span class="string">&quot;r&quot;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getChar</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(is==it)&#123;it=(is=ibuf)+<span class="built_in">fread</span>(ibuf,<span class="number">1</span>,bufl,IT);<span class="keyword">if</span>(is==it)<span class="keyword">return</span> EOF;&#125;<span class="keyword">return</span> *is++;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getInt</span><span class="params">(Temp &amp;a)</span></span>&#123;a=<span class="number">0</span>;<span class="type">int</span> b=<span class="number">0</span>,c=<span class="built_in">getChar</span>();<span class="keyword">while</span>(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)b^=(c==<span class="number">45</span>),c=<span class="built_in">getChar</span>();<span class="keyword">while</span>(c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>)a=(a&lt;&lt;<span class="number">1</span>)+(a&lt;&lt;<span class="number">3</span>)+c<span class="number">-48</span>,c=<span class="built_in">getChar</span>();<span class="keyword">if</span>(b)a=-a;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getDouble</span><span class="params">(Temp &amp;a)</span></span>&#123;a=<span class="number">0</span>;<span class="type">int</span> b=<span class="number">0</span>,c=<span class="built_in">getChar</span>(),d=<span class="number">0</span>;__int128 e=<span class="number">0</span>,f=<span class="number">0</span>;<span class="keyword">while</span>(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)b^=(c==<span class="number">45</span>),c=<span class="built_in">getChar</span>();<span class="keyword">while</span>(c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>)e=(e&lt;&lt;<span class="number">1</span>)+(e&lt;&lt;<span class="number">3</span>)+c<span class="number">-48</span>,c=<span class="built_in">getChar</span>();<span class="keyword">if</span>(c==<span class="number">46</span>)&#123;c=<span class="built_in">getChar</span>();<span class="keyword">while</span>(c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>)d++,f=(f&lt;&lt;<span class="number">1</span>)+(f&lt;&lt;<span class="number">3</span>)+c<span class="number">-48</span>,c=<span class="built_in">getChar</span>();&#125;a=e+base1[d]*f;<span class="keyword">if</span>(b)a=-a;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">char</span> &amp;a)&#123;a=<span class="built_in">getChar</span>();<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">char</span> *a)&#123;<span class="keyword">do</span>&#123;*a=<span class="built_in">getChar</span>();&#125;<span class="keyword">while</span>(*a&lt;=<span class="number">32</span>);<span class="keyword">while</span>(*a&gt;<span class="number">32</span>)*++a=<span class="built_in">getChar</span>();*a=<span class="number">0</span>;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(string &amp;a)&#123;<span class="type">char</span> b=<span class="built_in">getChar</span>();<span class="keyword">while</span>(b&lt;=<span class="number">32</span>)b=<span class="built_in">getChar</span>();<span class="keyword">while</span>(b&gt;<span class="number">32</span>)a+=b,b=<span class="built_in">getChar</span>();<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">int</span> &amp;a)&#123;<span class="built_in">getInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">long</span> <span class="type">long</span> &amp;a)&#123;<span class="built_in">getInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(__int128 &amp;a)&#123;<span class="built_in">getInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">float</span> &amp;a)&#123;<span class="built_in">getDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">double</span> &amp;a)&#123;<span class="built_in">getDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">long</span> <span class="type">double</span> &amp;a)&#123;<span class="built_in">getDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OUT</span>&#123;</span><br><span class="line">FILE *IT;<span class="type">char</span> obuf[bufl],*os=obuf,*ot=obuf+bufl;<span class="type">int</span> Eps;<span class="type">long</span> <span class="type">double</span> Acc;</span><br><span class="line"><span class="built_in">OUT</span>()&#123;IT=stdout,Eps=<span class="number">6</span>,Acc=<span class="number">0.5</span>;&#125;<span class="built_in">OUT</span>(<span class="type">char</span> *a)&#123;IT=<span class="built_in">fopen</span>(a,<span class="string">&quot;w&quot;</span>),Eps=<span class="number">6</span>,Acc=<span class="number">0.5</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ChangEps</span><span class="params">(<span class="type">int</span> x=<span class="number">6</span>)</span></span>&#123;Eps=x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">flush</span><span class="params">()</span></span>&#123;<span class="built_in">fwrite</span>(obuf,<span class="number">1</span>,os-obuf,IT);os=obuf;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putChar</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;*os++=a;<span class="keyword">if</span>(os==ot)<span class="built_in">flush</span>();&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putInt</span><span class="params">(Temp a)</span></span>&#123;<span class="keyword">if</span>(a&lt;<span class="number">0</span>)&#123;<span class="built_in">putChar</span>(<span class="number">45</span>);a=-a;&#125;<span class="keyword">if</span>(a&lt;<span class="number">10</span>)&#123;<span class="built_in">putChar</span>(a+<span class="number">48</span>);<span class="keyword">return</span>;&#125;<span class="built_in">putInt</span>(a/<span class="number">10</span>);<span class="built_in">putChar</span>(a%<span class="number">10</span>+<span class="number">48</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putLeading</span><span class="params">(Temp a,<span class="type">int</span> b)</span></span>&#123;<span class="keyword">if</span>(!b)<span class="keyword">return</span>;<span class="built_in">putLeading</span>(a/<span class="number">10</span>,b<span class="number">-1</span>);<span class="built_in">putChar</span>(a%<span class="number">10</span>+<span class="number">48</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putDouble</span><span class="params">(Temp a)</span></span>&#123;<span class="keyword">if</span>(a&lt;<span class="number">0</span>)&#123;<span class="built_in">putChar</span>(<span class="number">45</span>);a=-a;&#125;__int128 b=a;<span class="built_in">putInt</span>(b);a-=b;a*=base2[Eps];b=a+Acc;<span class="built_in">putChar</span>(<span class="number">46</span>);<span class="built_in">putLeading</span>(b,Eps);&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">char</span> a)&#123;<span class="built_in">putChar</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> <span class="type">char</span> *a)&#123;<span class="keyword">while</span>(*a)<span class="built_in">putChar</span>(*a++);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(string a)&#123;<span class="keyword">for</span>(<span class="keyword">auto</span> c:a)<span class="built_in">putChar</span>(c);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">int</span> a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">long</span> <span class="type">long</span> a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(__int128 a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">unsigned</span> <span class="type">int</span> a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">unsigned</span> __int128 a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">float</span> a)&#123;<span class="built_in">putDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">double</span> a)&#123;<span class="built_in">putDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">long</span> <span class="type">double</span> a)&#123;<span class="built_in">putDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">~<span class="built_in">OUT</span>()&#123;<span class="built_in">flush</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">fastio::IN fin;</span><br><span class="line">fastio::OUT fout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">long</span> <span class="type">long</span> p=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">long</span> <span class="type">long</span> mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">qqp</span><span class="params">(T1 b,T2 po)</span></span>&#123;</span><br><span class="line">T1 res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(po&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(po&amp;<span class="number">1</span>)</span><br><span class="line">res=res*b%p;</span><br><span class="line">b=b*b%p;</span><br><span class="line">po&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> k1,k2;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> C[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> u,r,dat[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="built_in">node</span>(<span class="type">long</span> <span class="type">long</span> a=<span class="number">0</span>,<span class="type">long</span> <span class="type">long</span> b=<span class="number">0</span>):<span class="built_in">u</span>(a),<span class="built_in">r</span>(b)&#123;<span class="built_in">memset</span>(dat,<span class="number">0</span>,<span class="keyword">sizeof</span> dat);&#125;</span><br><span class="line">~<span class="built_in">node</span>()&#123;&#125;</span><br><span class="line">node <span class="keyword">operator</span>=(node io)&#123;</span><br><span class="line">u=io.u;</span><br><span class="line">r=io.r;</span><br><span class="line"><span class="built_in">memcpy</span>(dat,io.dat,<span class="keyword">sizeof</span> dat);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span>*(node io)&#123;</span><br><span class="line"><span class="function">node <span class="title">res</span><span class="params">((u+io.u)%mod,(r+io.r)%mod)</span></span>;</span><br><span class="line"><span class="built_in">memcpy</span>(res.dat,dat,<span class="keyword">sizeof</span> dat);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> uu=u%mod,rr=r%mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k1;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k2;++j)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> ii=<span class="number">0</span>,t1=<span class="number">1</span>;ii&lt;=i;++ii,t1=t1*uu%mod)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> jj=<span class="number">0</span>,t2=<span class="number">1</span>;jj&lt;=j;++jj,t2=t2*rr%mod)&#123;</span><br><span class="line">res.dat[i][j]=(res.dat[i][j]+(C[i][ii]*C[j][jj]*t1%mod*t2%mod*io.dat[i-ii][i-jj])%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">node <span class="title">qp</span><span class="params">(node b,<span class="type">long</span> <span class="type">long</span> po)</span></span>&#123;</span><br><span class="line">node res;</span><br><span class="line"><span class="keyword">while</span>(po&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(po&amp;<span class="number">1</span>)</span><br><span class="line">res=res*b;</span><br><span class="line">b=b*b;</span><br><span class="line">po&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">vargcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> c,<span class="type">long</span> <span class="type">long</span> n,node fu,node fr)</span></span>&#123;</span><br><span class="line">b%=c;</span><br><span class="line"><span class="keyword">if</span>(a&gt;=c)<span class="keyword">return</span> <span class="built_in">vargcd</span>(a%c,b,c,n,fu,<span class="built_in">qp</span>(fu,a/c)*fr);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> m=(a*n+b)/c;</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">qp</span>(fr,n);</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">qp</span>(fr,(c-b<span class="number">-1</span>)/a)*fu*<span class="built_in">vargcd</span>(c,c-b<span class="number">-1</span>,a,m<span class="number">-1</span>,fr,fu)*<span class="built_in">qp</span>(fr,n-(c*m-b<span class="number">-1</span>)/a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">U</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span>,<span class="title">R</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> t,a,b,c,n;</span><br><span class="line">fin&gt;&gt;t;</span><br><span class="line">C[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;++i)&#123;</span><br><span class="line">C[i][<span class="number">0</span>]=C[i][i]=C[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;i;++j)&#123;</span><br><span class="line">C[i][j]=C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;++i)&#123;</span><br><span class="line">U.dat[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">fin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;k1&gt;&gt;k2;</span><br><span class="line">node res;</span><br><span class="line">res.u=b/c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">0</span>,t=<span class="number">1</span>;i&lt;=<span class="number">10</span>;++i,t=(t*res.u)%mod)&#123;</span><br><span class="line">res.dat[i][<span class="number">0</span>]=t;</span><br><span class="line">&#125;</span><br><span class="line">fout&lt;&lt;(res*<span class="built_in">vargcd</span>(a,b,c,n,U,R)).dat[k1][k2]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;万能欧几里得推式子的时间.&lt;/p&gt;
&lt;p&gt;万能欧几里得的作用是求一些类似辗转相除的算法,需要递归求解的东西.万能欧几里得的泛用性在于主板子基本不用换,只需要稍微修改合并部分的代码.&lt;/p&gt;
&lt;p&gt;可以使用矩阵的思想.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;求&lt;br&gt;
$$&#92;sum_{i</summary>
      
    
    
    
    <category term="Math" scheme="https://narafluorine.github.io/categories/Math/"/>
    
    
    <category term="NumberTheory" scheme="https://narafluorine.github.io/tags/NumberTheory/"/>
    
  </entry>
  
  <entry>
    <title>数据结构选课学习笔记</title>
    <link href="https://narafluorine.github.io/2024/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://narafluorine.github.io/2024/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-09-09T05:01:32.000Z</published>
    <updated>2024-10-11T08:41:11.747Z</updated>
    
    <content type="html"><![CDATA[<p>这是数据结构选课的课内笔记,和 $OI$ 的高难数据结构关系不是很大,主要是记一些怕忘的定义.</p><h2 id="ADL语言">ADL语言</h2><p>算法 SM(A,n,&amp;min,&amp;max)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">max&lt;-min&lt;a[<span class="number">1</span>]</span><br><span class="line">FOR i=<span class="number">2</span> TO n DO</span><br><span class="line"><span class="keyword">if</span> A[i]&gt;max THEN max&lt;-a[i]</span><br><span class="line"><span class="keyword">if</span> A[i]&lt;min THEN min&lt;-a[i]</span><br></pre></td></tr></table></figure><p>举例<br>$$ADL:a\leftrightarrow b$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a^=b^=a^=b</span><br></pre></td></tr></table></figure><h2 id="算法的鲁棒性">算法的鲁棒性</h2><p>自动识别错误数据(并纠正)的能力.</p><h2 id="算法测试">算法测试</h2><p><strong>黑盒测试</strong>:测试点.<br><strong>白盒测试</strong>:语句覆盖,分支覆盖.</p><h2 id="时间复杂度">时间复杂度</h2><p>$O$ ,读音:big-oh;表示上界,小于等于.<br>$ο$ ,读音:small-oh;表示上界,小于.<br>$\Theta$ ,读音:theta、西塔;既是上界也是下界,称为确界,等于.<br>$\omega$ ,读音:small omega;表示下界,大于.<br>$\Omega$ ,读音:big omega、欧米伽;表示下界,大于等于.</p><p>Ο是渐进上界,Ω是渐进下界.Θ需同时满足大Ο和Ω,故称为确界.Ο极其有用,因为它表示了最差性能.</p><h2 id="时空积分">时空积分</h2><p>$$W=\int_0^tf(x)\mathrm dx$$</p><h2 id="多维数组寻址">多维数组寻址</h2><p>$$*=dat+\sum_{j=1}^{n-1}(i_j\times\prod^{n}_{p=k+1} m_p)*C$$<br>C代表<code>sizeof</code>,大乘号其实就是前缀积</p><h2 id="矩阵三元组表转置">矩阵三元组表转置</h2><p>Q:为啥PPT说的是 $O(nt)$ 的?<br>这个可以做到 $O(t\log t)$ .</p><h2 id="矩阵十字链表">矩阵十字链表</h2><p>cqcqcq</p><p>how $A\to A* …$</p><p>3.2.4十字链表</p><h2 id="字典序">字典序</h2><p>cqcqcq</p><h2 id="二叉树">二叉树</h2><p>满二叉树:顾名思义,节点全满,非常均匀.<br>完全二叉树:节点全的,末层缺失</p><h2 id="线索二叉树">线索二叉树</h2><p>节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val,l,r,   pred,succ</span><br></pre></td></tr></table></figure><p>后面这俩存根,先根或者后根, <strong>可以存前根,中根或者后根</strong> ,故又称前序,中序或者后序线索二叉树.</p><p>cqc++…</p><h2 id="树转二叉树">树转二叉树</h2><p>深度相同兄弟之间连一条线,然后删掉所有非大孩子,刚连的线.</p><h2 id="森林转二叉树">森林转二叉树</h2><p>整一个首节点,然后连线,然后串串…</p><h2 id="树转森林">树转森林</h2><p>重剖,长剖.(不至于)</p><h2 id="哈夫曼树">哈夫曼树</h2><p>扩充二叉树:二叉树所有原来有空位的加子节点.</p><p>路径长度:<br>$$w=\sum_{i=1}^nw_id_i$$<br>其中w代表权值(就是存的那个数),然后d是路径长(深度-1),这个w最小的叫最优二叉树.</p><p>哈夫曼编码:左儿子是0,右儿子是1,直接走,走到哪编码.</p><p><strong>压缩</strong>:开一个map统计出现频率,然后建立哈夫曼树,直接译码. $O(n\log n)$ .<br><strong>解码</strong>:先读哈夫曼树,然后直接译码即可.</p><h3 id="哈夫曼树构造">哈夫曼树构造</h3><p>所有节点都是一个森林,然后每次选权值最小的根组成一个新树,产生一个新节点,加入其中,直到剩一个根.</p><h2 id="表达式树">表达式树</h2><p>中缀表达式树.这个一看就明白了,也没多难写.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(a+b)*(c+d)-e</span><br><span class="line">        -</span><br><span class="line">       / \</span><br><span class="line">      *   e</span><br><span class="line">     / \</span><br><span class="line">+   -</span><br><span class="line">   / \ / \</span><br><span class="line">   a b c d</span><br></pre></td></tr></table></figure><h2 id="图">图</h2><p>连通子图:顾名思义.<br>连通分量:把所有联通块抽出来就是了.</p><h2 id="拓扑排序">拓扑排序</h2><p>每次选一个入度为0的,然后删掉边,循环.</p><p>拓扑排序是 $O(n+e)$ 的.</p><h2 id="关键路径">关键路径</h2><p>cqcqcq</p><h2 id="可及性">可及性</h2><p>cqcqcq</p><h2 id="希尔排序-Shell">希尔排序(Shell)</h2><p>直接插入排序的改进.作为最先冲破 $O(n^2)$ 的排序算法,值得借鉴.</p><p>每次把增量分成n&gt;&gt;1,然后每个区间暴力插入排序.直到最后</p><h2 id="基数分布和值分布">基数分布和值分布</h2><p>基数排序,是模按照指定位数进行排序的算法,计数排序就是俗称的桶排序.</p><p>基数排序:先开十个链表,然后取最后一位看剩下的数.按照这个顺序先排起来.<br>然后取第二位接着排,直到元素有序.</p><h1>板子</h1><p>前情提要:数据结构作业不让用 <code>stl</code> 库,这令Flu有点难办…</p><p>咋办?自己搓!于是这就是常见的数据结构封装,快说谢谢Flu.</p><h2 id="栈">栈</h2><p>一度让我觉得没有封装的必要…但是既然数据结构提了那就写一个吧…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sstack</span>&#123;</span><br><span class="line">T* dat;</span><br><span class="line"><span class="type">int</span> ttop;</span><br><span class="line"><span class="built_in">sstack</span>(<span class="type">int</span> n=<span class="number">100010</span>)&#123;dat=<span class="keyword">new</span> T[n];ttop=<span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T val)</span></span>&#123;dat[++ttop]=val;&#125;</span><br><span class="line"><span class="function">T <span class="title">top</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop&gt;<span class="number">0</span>)<span class="keyword">return</span> dat[ttop];<span class="keyword">return</span> <span class="number">-114514</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ttop;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-114514</span>;ttop--;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ttop&lt;=<span class="number">0</span>;&#125;</span><br><span class="line">&#125;;<span class="comment">//所有操作不合法会返回-114514</span></span><br></pre></td></tr></table></figure><h2 id="队列-双端队列">队列(双端队列)</h2><p>因为双端队列兼容队列,所以就不再写队列的模板了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ddeque</span>&#123;</span><br><span class="line">T* dat;</span><br><span class="line"><span class="type">int</span> ttop,l;</span><br><span class="line"><span class="built_in">ddeque</span>(<span class="type">int</span> n=<span class="number">200010</span>)&#123;dat=<span class="keyword">new</span> T[n];ttop=(n&gt;&gt;<span class="number">1</span>);l=(n&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ttop-l+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function">T <span class="title">front</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop&lt;l)<span class="keyword">return</span> <span class="number">-114514</span>;<span class="keyword">return</span> dat[ttop];&#125;</span><br><span class="line"><span class="function">T <span class="title">back</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop&lt;l)<span class="keyword">return</span> <span class="number">-114514</span>;<span class="keyword">return</span> dat[l];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop_front</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop&lt;l)<span class="keyword">return</span> <span class="number">-114514</span>;ttop--;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop_back</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop&lt;l)<span class="keyword">return</span> <span class="number">-114514</span>;l++;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(T val)</span></span>&#123;dat[++ttop]=val;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T val)</span></span>&#123;dat[--l]=val;&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (ttop-l+<span class="number">1</span>)&lt;=<span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="动态数组">动态数组</h2><p>neta了vector.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">vvector</span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> base[]=&#123;<span class="number">0</span>,<span class="number">20</span>,<span class="number">110</span>,<span class="number">1010</span>,<span class="number">10010</span>,<span class="number">100010</span>,<span class="number">200010</span>,<span class="number">1000010</span>,<span class="number">2000010</span>,<span class="number">10000010</span>&#125;;</span><br><span class="line">T* dat;</span><br><span class="line"><span class="type">int</span> sz,top;<span class="comment">//当前块指向,顶端元素(Flu比较喜欢闭区间)</span></span><br><span class="line"><span class="built_in">vvector</span>(<span class="type">int</span> size=<span class="number">0</span>,T val=<span class="number">0</span>)&#123;sz=size;dat=<span class="keyword">new</span> T[base[size]];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;base[size];++i)&#123;dat[i]=val;&#125;top=<span class="number">-1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> top+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T val)</span></span>&#123;<span class="keyword">if</span>((top+<span class="number">1</span>)&gt;=base[sz])&#123;T* p=<span class="keyword">new</span> T[base[sz+<span class="number">1</span>]];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;base[sz];++i)&#123;p[i]=dat[i];&#125;p[++top]=val;sz++;<span class="keyword">delete</span>[]dat;dat=p;&#125;<span class="keyword">else</span>&#123;dat[++top]=val;&#125;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;top=<span class="number">-1</span>;&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> io)&#123;<span class="keyword">return</span> dat[io];&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="哈希表">哈希表</h2><p>低配版的umap,只支持 <code>long long</code> 的哈希…但是够用了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">uunordered_map</span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> first;</span><br><span class="line">T second;</span><br><span class="line">node *next,*nnext;</span><br><span class="line"><span class="built_in">node</span>(<span class="type">long</span> <span class="type">long</span> a,T b,node* p=<span class="literal">nullptr</span>,node* pp=<span class="literal">nullptr</span>):<span class="built_in">first</span>(a),<span class="built_in">second</span>(b),<span class="built_in">next</span>(p),<span class="built_in">nnext</span>(pp)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">node** dat;</span><br><span class="line">node* pp00;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mmod=<span class="number">1000003</span>;</span><br><span class="line"><span class="type">int</span> sz;</span><br><span class="line"><span class="built_in">uunordered_map</span>()&#123;</span><br><span class="line">sz=<span class="number">0</span>;</span><br><span class="line">pp00=<span class="literal">nullptr</span>;</span><br><span class="line">dat=<span class="keyword">new</span> node*[mmod];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;mmod;++i)&#123;</span><br><span class="line">dat[i]=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qqp</span><span class="params">(<span class="type">long</span> <span class="type">long</span> b,<span class="type">int</span> po)</span></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(po&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(po&amp;<span class="number">1</span>)</span><br><span class="line">res=res*b%mmod;</span><br><span class="line">b=b*b%mmod;</span><br><span class="line">po&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">long</span> <span class="type">long</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">qqp</span>(val,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">long</span> <span class="type">long</span>&amp; io)&#123;</span><br><span class="line"><span class="type">int</span> h=<span class="built_in">hash</span>(io);</span><br><span class="line">node* i=dat[h];</span><br><span class="line"><span class="keyword">for</span>(;i!=<span class="literal">nullptr</span>;i=i-&gt;next)&#123;</span><br><span class="line"><span class="keyword">if</span>(i-&gt;first==io)</span><br><span class="line"><span class="keyword">return</span> i-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line">sz++;</span><br><span class="line">node* j=<span class="keyword">new</span> <span class="built_in">node</span>(io,<span class="number">0</span>,dat[h],pp00);</span><br><span class="line">pp00=j;</span><br><span class="line">dat[h]=j;</span><br><span class="line"><span class="keyword">return</span> j-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">triverse</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(node* i=pp00;i!=<span class="literal">nullptr</span>;i=i-&gt;nnext)&#123;</span><br><span class="line"><span class="comment">//i-&gt;first键 i-&gt;second键值</span></span><br><span class="line"><span class="comment">//这是遍历所有元素的过程</span></span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sz&lt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="priority-queue">priority_queue</h2><p>自定义类需要写比较函数 <code>&lt;</code> ,记得输入0或者1表明建立小根堆还是大根堆,默认是0大根堆.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ppriority_queue</span>&#123;</span><br><span class="line">T* dat;</span><br><span class="line"><span class="type">int</span> sz,ff;<span class="comment">/*ff0大根堆1小根堆*/</span></span><br><span class="line"><span class="built_in">ppriority_queue</span>(<span class="type">int</span> flag=<span class="number">0</span>,<span class="type">int</span> n=<span class="number">100010</span>):<span class="built_in">sz</span>(<span class="number">0</span>),<span class="built_in">ff</span>(flag)&#123;</span><br><span class="line">dat=<span class="keyword">new</span> T[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ppriority_queue</span>(T* arr,<span class="type">int</span> num,<span class="type">int</span> flag=<span class="number">0</span>,<span class="type">int</span> n=<span class="number">100010</span>):<span class="built_in">sz</span>(num),<span class="built_in">ff</span>(flag)&#123;</span><br><span class="line">dat=<span class="keyword">new</span> T[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;++i)&#123;</span><br><span class="line">dat[i+<span class="number">1</span>]=dat[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">maintain</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T val)</span></span>&#123;</span><br><span class="line">dat[++sz]=val;</span><br><span class="line"><span class="built_in">maintaindown</span>(sz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintaindown</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> fa=num&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>((dat[fa]&lt;dat[num])^ff)&#123;</span><br><span class="line"><span class="built_in">sswap</span>(dat[fa],dat[num]);</span><br><span class="line"><span class="built_in">maintaindown</span>(fa);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sz&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-114514</span>;</span><br><span class="line">dat[<span class="number">1</span>]=dat[sz--];</span><br><span class="line"><span class="built_in">maintainup</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintainup</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ls=num&lt;&lt;<span class="number">1</span>,rs=(num&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,gg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(rs&lt;=sz)gg+=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(ls&lt;=sz)gg++;</span><br><span class="line"><span class="keyword">switch</span>(gg)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line"><span class="keyword">if</span>((dat[num]&lt;dat[ls])^ff)&#123;</span><br><span class="line"><span class="built_in">sswap</span>(dat[num],dat[ls]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line"><span class="keyword">if</span>((dat[ls]&lt;dat[rs])^ff)&#123;</span><br><span class="line"><span class="keyword">if</span>((dat[num]&lt;dat[rs])^ff)&#123;</span><br><span class="line"><span class="built_in">sswap</span>(dat[num],dat[rs]);</span><br><span class="line"><span class="built_in">maintainup</span>(rs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>((dat[num]&lt;dat[ls])^ff)&#123;</span><br><span class="line"><span class="built_in">sswap</span>(dat[num],dat[ls]);</span><br><span class="line"><span class="built_in">maintainup</span>(ls);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> dat[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sswap</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line">T _tmp=a;</span><br><span class="line">a=b;</span><br><span class="line">b=_tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;<span class="comment">/*O(n)建堆*/</span></span><br><span class="line"><span class="type">int</span> ls=num&lt;&lt;<span class="number">1</span>,rs=(num&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,gg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(ls&lt;=sz)<span class="built_in">maintain</span>(ls),gg++;</span><br><span class="line"><span class="keyword">if</span>(rs&lt;=sz)<span class="built_in">maintain</span>(rs),gg+=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">switch</span>(gg)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line"><span class="keyword">if</span>((dat[num]&lt;dat[ls])^ff)&#123;</span><br><span class="line"><span class="built_in">sswap</span>(dat[num],dat[ls]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line"><span class="keyword">if</span>((dat[ls]&lt;dat[rs])^ff)&#123;</span><br><span class="line"><span class="keyword">if</span>((dat[num]&lt;dat[rs])^ff)&#123;</span><br><span class="line"><span class="built_in">sswap</span>(dat[num],dat[rs]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>((dat[num]&lt;dat[ls])^ff)&#123;</span><br><span class="line"><span class="built_in">sswap</span>(dat[num],dat[ls]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sz&lt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="ppair">ppair</h2><p>单纯模仿用的…其实自己写一个也行…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ppair</span>&#123;</span><br><span class="line">T1 first;</span><br><span class="line">T2 second;</span><br><span class="line"><span class="built_in">ppair</span>()&#123;&#125;</span><br><span class="line"><span class="built_in">ppair</span>(T1 a,T2 b):<span class="built_in">first</span>(a),<span class="built_in">second</span>(b)&#123;&#125;</span><br><span class="line">ppair&amp; <span class="keyword">operator</span> =(<span class="type">const</span> ppair&amp; io)&#123;</span><br><span class="line">first=io.first;</span><br><span class="line">second=io.second;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> <span class="keyword">operator</span> ==(<span class="type">const</span> ppair&amp; io)<span class="type">const</span>&#123;</span><br><span class="line"><span class="built_in">return</span> (first==io.first)&amp;&amp;(second==io.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(ppair&amp; io)</span></span>&#123;</span><br><span class="line">ppair tmp=io;</span><br><span class="line">io=*<span class="keyword">this</span>;</span><br><span class="line">*<span class="keyword">this</span>=tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="list">list</h2><p>十分暴力的链表,考虑到有些时候无可避免地要用到链表,最后还是写了…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">llist</span>&#123;</span><br><span class="line"><span class="type">int</span> cnt,top;<span class="comment">/*top目前链表占用多大空间,cnt链表有多少个元素*/</span></span><br><span class="line">T* dat;</span><br><span class="line"><span class="type">int</span>* nxt;</span><br><span class="line"><span class="built_in">llist</span>(<span class="type">int</span> n=<span class="number">200010</span>):<span class="built_in">cnt</span>(<span class="number">0</span>),<span class="built_in">top</span>(<span class="number">1</span>)&#123;</span><br><span class="line">dat=<span class="keyword">new</span> T[n];</span><br><span class="line">nxt=<span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">nxt[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">llist</span>(T* ddat,<span class="type">int</span> num,<span class="type">int</span> n=<span class="number">200010</span>):<span class="built_in">cnt</span>(num),<span class="built_in">top</span>(<span class="number">1</span>+num)&#123;</span><br><span class="line">dat=<span class="keyword">new</span> T[n];</span><br><span class="line">nxt=<span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;++i)&#123;<span class="comment">/*[0,num)*/</span></span><br><span class="line">dat[i+<span class="number">2</span>]=ddat[i];</span><br><span class="line">nxt[i+<span class="number">1</span>]=i+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _add(<span class="type">int</span> pre,T val)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;;++i,j=nxt[j])&#123;</span><br><span class="line"><span class="keyword">if</span>(i==pre)&#123;</span><br><span class="line">nxt[++top]=nxt[j];</span><br><span class="line">nxt[j]=top;</span><br><span class="line">dat[top]=val;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos,T val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;<span class="number">0</span>||cnt&lt;pos)<span class="keyword">return</span> <span class="number">-114514</span>;</span><br><span class="line">_add(pos,val);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _del(<span class="type">int</span> pre)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;;++i,j=nxt[j])&#123;</span><br><span class="line"><span class="keyword">if</span>(i==pre)&#123;</span><br><span class="line">nxt[j]=nxt[nxt[j]];</span><br><span class="line">cnt--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=<span class="number">0</span>||cnt&lt;pos)<span class="keyword">return</span> <span class="number">-114514</span>;</span><br><span class="line">_del(pos<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">triverse</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=nxt[<span class="number">1</span>];j!=<span class="number">0</span>;++i,j=nxt[j])&#123;</span><br><span class="line"><span class="comment">/*i是序号,j是当前元素指针*/</span></span><br><span class="line"><span class="comment">//do something...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="高精度">高精度</h2><p>懒得写,下一个.<br>我宁可去洛谷上找一个之前写好的都不要自己修这个破玩意.</p><h2 id="ALL">ALL</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Flu&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ddeque</span>&#123;</span><br><span class="line">T* dat;</span><br><span class="line"><span class="type">int</span> ttop,l;</span><br><span class="line"><span class="built_in">ddeque</span>(<span class="type">int</span> n=<span class="number">200010</span>)&#123;dat=<span class="keyword">new</span> T[n];ttop=(n&gt;&gt;<span class="number">1</span>);l=(n&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ttop-l+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function">T <span class="title">front</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop&lt;l)<span class="keyword">return</span> <span class="number">0x0d000721</span>;<span class="keyword">return</span> dat[ttop];&#125;</span><br><span class="line"><span class="function">T <span class="title">back</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop&lt;l)<span class="keyword">return</span> <span class="number">0x0d000721</span>;<span class="keyword">return</span> dat[l];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop_front</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop&lt;l)<span class="keyword">return</span> <span class="number">0x0d000721</span>;ttop--;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop_back</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(ttop&lt;l)<span class="keyword">return</span> <span class="number">0x0d000721</span>;l++;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(T val)</span></span>&#123;dat[++ttop]=val;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T val)</span></span>&#123;dat[--l]=val;&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (ttop-l+<span class="number">1</span>)&lt;=<span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">vvector</span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> base[]=&#123;<span class="number">0</span>,<span class="number">20</span>,<span class="number">110</span>,<span class="number">1010</span>,<span class="number">10010</span>,<span class="number">100010</span>,<span class="number">200010</span>,<span class="number">1000010</span>,<span class="number">2000010</span>,<span class="number">10000010</span>&#125;;</span><br><span class="line">T* dat;</span><br><span class="line"><span class="type">int</span> sz,top;<span class="comment">//当前块指向,顶端元素(Flu比较喜欢闭区间)</span></span><br><span class="line"><span class="built_in">vvector</span>(<span class="type">int</span> size=<span class="number">0</span>,T val=<span class="number">0</span>)&#123;sz=size;dat=<span class="keyword">new</span> T[base[size]];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;base[size];++i)&#123;dat[i]=val;&#125;top=<span class="number">-1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> top+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T val)</span></span>&#123;<span class="keyword">if</span>((top+<span class="number">1</span>)&gt;=base[sz])&#123;T* p=<span class="keyword">new</span> T[base[sz+<span class="number">1</span>]];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;base[sz];++i)&#123;p[i]=dat[i];&#125;p[++top]=val;sz++;<span class="keyword">delete</span>[]dat;dat=p;&#125;<span class="keyword">else</span>&#123;dat[++top]=val;&#125;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;top=<span class="number">-1</span>;&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> io)&#123;<span class="keyword">return</span> dat[io];&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ppriority_queue</span>&#123;</span><br><span class="line">T* dat;</span><br><span class="line"><span class="type">int</span> sz,ff;<span class="comment">/*ff0大根堆1小根堆*/</span></span><br><span class="line"><span class="built_in">ppriority_queue</span>(<span class="type">int</span> flag=<span class="number">0</span>,<span class="type">int</span> n=<span class="number">100010</span>):<span class="built_in">sz</span>(<span class="number">0</span>),<span class="built_in">ff</span>(flag)&#123;dat=<span class="keyword">new</span> T[n];&#125;</span><br><span class="line"><span class="built_in">ppriority_queue</span>(T* arr,<span class="type">int</span> num,<span class="type">int</span> flag=<span class="number">0</span>,<span class="type">int</span> n=<span class="number">100010</span>):<span class="built_in">sz</span>(num),<span class="built_in">ff</span>(flag)&#123;dat=<span class="keyword">new</span> T[n];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;++i)&#123;dat[i+<span class="number">1</span>]=dat[i];&#125;<span class="built_in">maintain</span>(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T val)</span></span>&#123;dat[++sz]=val;<span class="built_in">maintaindown</span>(sz);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintaindown</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;<span class="type">int</span> fa=num&gt;&gt;<span class="number">1</span>;<span class="keyword">if</span>((dat[fa]&lt;dat[num])^ff)&#123;<span class="built_in">sswap</span>(dat[fa],dat[num]);<span class="built_in">maintaindown</span>(fa);&#125;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(sz&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0x0d000721</span>;dat[<span class="number">1</span>]=dat[sz--];<span class="built_in">maintainup</span>(<span class="number">1</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintainup</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;<span class="type">int</span> ls=num&lt;&lt;<span class="number">1</span>,rs=(num&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,gg=<span class="number">0</span>;<span class="keyword">if</span>(rs&lt;=sz)gg+=<span class="number">2</span>;<span class="keyword">if</span>(ls&lt;=sz)gg++;<span class="keyword">switch</span>(gg)&#123;<span class="keyword">case</span> <span class="number">0</span>:&#123;<span class="keyword">return</span>;&#125;<span class="keyword">case</span> <span class="number">1</span>:&#123;<span class="keyword">if</span>((dat[num]&lt;dat[ls])^ff)&#123;<span class="built_in">sswap</span>(dat[num],dat[ls]);&#125;<span class="keyword">return</span>;&#125;<span class="keyword">case</span> <span class="number">3</span>:&#123;<span class="keyword">if</span>((dat[ls]&lt;dat[rs])^ff)&#123;<span class="keyword">if</span>((dat[num]&lt;dat[rs])^ff)&#123;<span class="built_in">sswap</span>(dat[num],dat[rs]);<span class="built_in">maintainup</span>(rs);&#125;&#125;<span class="keyword">else</span>&#123;<span class="keyword">if</span>((dat[num]&lt;dat[ls])^ff)&#123;<span class="built_in">sswap</span>(dat[num],dat[ls]);<span class="built_in">maintainup</span>(ls);&#125;&#125;<span class="keyword">break</span>;&#125;&#125;&#125;</span><br><span class="line"><span class="function">T <span class="title">top</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> dat[<span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> sz;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sswap</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;T _tmp=a;a=b;b=_tmp;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;<span class="comment">/*O(n)建堆*/</span><span class="type">int</span> ls=num&lt;&lt;<span class="number">1</span>,rs=(num&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>,gg=<span class="number">0</span>;<span class="keyword">if</span>(ls&lt;=sz)<span class="built_in">maintain</span>(ls),gg++;<span class="keyword">if</span>(rs&lt;=sz)<span class="built_in">maintain</span>(rs),gg+=<span class="number">2</span>;<span class="keyword">switch</span>(gg)&#123;<span class="keyword">case</span> <span class="number">0</span>:&#123;<span class="keyword">return</span>;&#125;<span class="keyword">case</span> <span class="number">1</span>:&#123;<span class="keyword">if</span>((dat[num]&lt;dat[ls])^ff)&#123;<span class="built_in">sswap</span>(dat[num],dat[ls]);&#125;<span class="keyword">return</span>;&#125;<span class="keyword">case</span> <span class="number">3</span>:&#123;<span class="keyword">if</span>((dat[ls]&lt;dat[rs])^ff)&#123;<span class="keyword">if</span>((dat[num]&lt;dat[rs])^ff)&#123;<span class="built_in">sswap</span>(dat[num],dat[rs]);&#125;&#125;<span class="keyword">else</span>&#123;<span class="keyword">if</span>((dat[num]&lt;dat[ls])^ff)&#123;<span class="built_in">sswap</span>(dat[num],dat[ls]);&#125;&#125;<span class="keyword">break</span>;&#125;&#125;&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> sz&lt;=<span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">llist</span>&#123;</span><br><span class="line"><span class="type">int</span> cnt,top;<span class="comment">/*top目前链表占用多大空间,cnt链表有多少个元素*/</span></span><br><span class="line">T* dat;</span><br><span class="line"><span class="type">int</span>* nxt;</span><br><span class="line"><span class="built_in">llist</span>(<span class="type">int</span> n=<span class="number">200010</span>):<span class="built_in">cnt</span>(<span class="number">0</span>),<span class="built_in">top</span>(<span class="number">1</span>)&#123;dat=<span class="keyword">new</span> T[n];nxt=<span class="keyword">new</span> <span class="type">int</span>[n];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;nxt[i]=<span class="number">0</span>;&#125;&#125;</span><br><span class="line"><span class="built_in">llist</span>(T* ddat,<span class="type">int</span> num,<span class="type">int</span> n=<span class="number">200010</span>):<span class="built_in">cnt</span>(num),<span class="built_in">top</span>(<span class="number">1</span>+num)&#123;dat=<span class="keyword">new</span> T[n];nxt=<span class="keyword">new</span> <span class="type">int</span>[n];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;++i)&#123;<span class="comment">/*[0,num)*/</span>dat[i+<span class="number">2</span>]=ddat[i];nxt[i+<span class="number">1</span>]=i+<span class="number">2</span>;&#125;&#125;</span><br><span class="line"><span class="type">void</span> _add(<span class="type">int</span> pre,T val)&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;;++i,j=nxt[j])&#123;<span class="keyword">if</span>(i==pre)&#123;nxt[++top]=nxt[j];nxt[j]=top;dat[top]=val;cnt++;<span class="keyword">return</span>;&#125;&#125;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos,T val)</span></span>&#123;<span class="keyword">if</span>(pos&lt;<span class="number">0</span>||cnt&lt;pos)<span class="keyword">return</span> <span class="number">0x0d000721</span>;_add(pos,val);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="type">void</span> _del(<span class="type">int</span> pre)&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;;++i,j=nxt[j])&#123;<span class="keyword">if</span>(i==pre)&#123;nxt[j]=nxt[nxt[j]];cnt--;<span class="keyword">return</span>;&#125;&#125;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;<span class="keyword">if</span>(pos&lt;=<span class="number">0</span>||cnt&lt;pos)<span class="keyword">return</span> <span class="number">0x0d000721</span>;_del(pos<span class="number">-1</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">triverse</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=nxt[<span class="number">1</span>];j!=<span class="number">0</span>;++i,j=nxt[j])&#123;</span><br><span class="line"><span class="comment">/*i是序号,j是当前元素指针*/</span></span><br><span class="line"><span class="comment">//do something...</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">uunordered_map</span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> first;</span><br><span class="line">T second;</span><br><span class="line">node *next,*nnext;</span><br><span class="line"><span class="built_in">node</span>(<span class="type">long</span> <span class="type">long</span> a,T b,node* p=<span class="literal">nullptr</span>,node* pp=<span class="literal">nullptr</span>):<span class="built_in">first</span>(a),<span class="built_in">second</span>(b),<span class="built_in">next</span>(p),<span class="built_in">nnext</span>(pp)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">node** dat;</span><br><span class="line">node* pp00;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mmod=<span class="number">1000003</span>;</span><br><span class="line"><span class="type">int</span> sz;</span><br><span class="line"><span class="built_in">uunordered_map</span>()&#123;sz=<span class="number">0</span>;pp00=<span class="literal">nullptr</span>;dat=<span class="keyword">new</span> node*[mmod];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;mmod;++i)&#123;dat[i]=<span class="literal">nullptr</span>;&#125;&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qqp</span><span class="params">(<span class="type">long</span> <span class="type">long</span> b,<span class="type">int</span> po)</span></span>&#123;<span class="type">long</span> <span class="type">long</span> res=<span class="number">1</span>;<span class="keyword">while</span>(po&gt;<span class="number">0</span>)&#123;<span class="keyword">if</span>(po&amp;<span class="number">1</span>)res=res*b%mmod;b=b*b%mmod;po&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">long</span> <span class="type">long</span> val)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">qqp</span>(val,<span class="number">5</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> sz;&#125;</span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">long</span> <span class="type">long</span>&amp; io)&#123;<span class="type">int</span> h=<span class="built_in">hash</span>(io);node* i=dat[h];<span class="keyword">for</span>(;i!=<span class="literal">nullptr</span>;i=i-&gt;next)&#123;<span class="keyword">if</span>(i-&gt;first==io)<span class="keyword">return</span> i-&gt;second;&#125;sz++;node* j=<span class="keyword">new</span> <span class="built_in">node</span>(io,<span class="number">0</span>,dat[h],pp00);pp00=j;dat[h]=j;<span class="keyword">return</span> j-&gt;second;&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> sz&lt;=<span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">triverse</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(node* i=pp00;i!=<span class="literal">nullptr</span>;i=i-&gt;nnext)&#123;</span><br><span class="line"><span class="comment">//i-&gt;first键 i-&gt;second键值</span></span><br><span class="line"><span class="comment">//这是遍历所有元素的过程</span></span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="tmp">tmp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   /|\</span><br><span class="line">   BCD</span><br><span class="line">  /|||\</span><br><span class="line"> E FGH I</span><br><span class="line">/|\</span><br><span class="line">KLJ</span><br><span class="line">      A</span><br><span class="line">     /|\</span><br><span class="line">    B-C-D</span><br><span class="line">   /| | |\</span><br><span class="line">  E-F-G-H-I</span><br><span class="line"> /|\</span><br><span class="line">K-L-J</span><br><span class="line">      A</span><br><span class="line">     /</span><br><span class="line">    B-C-D</span><br><span class="line">   /     </span><br><span class="line">  E-F-G-H-I</span><br><span class="line"> /</span><br><span class="line">K-L-J</span><br><span class="line">      A</span><br><span class="line">     /</span><br><span class="line">    B</span><br><span class="line">   / \</span><br><span class="line">  E   C</span><br><span class="line"> / \   \</span><br><span class="line">K   F   D</span><br><span class="line"> \   \</span><br><span class="line">  L   G</span><br><span class="line">   \   \</span><br><span class="line">    J   H</span><br><span class="line">     \</span><br><span class="line">  I</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是数据结构选课的课内笔记,和 $OI$ 的高难数据结构关系不是很大,主要是记一些怕忘的定义.&lt;/p&gt;
&lt;h2 id=&quot;ADL语言&quot;&gt;ADL语言&lt;/h2&gt;
&lt;p&gt;算法 SM(A,n,&amp;amp;min,&amp;amp;max)&lt;/p&gt;
&lt;figure class=&quot;highligh</summary>
      
    
    
    
    <category term="DataStructure" scheme="https://narafluorine.github.io/categories/DataStructure/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>筛法</title>
    <link href="https://narafluorine.github.io/2024/09/03/%E7%AD%9B%E6%B3%95/"/>
    <id>https://narafluorine.github.io/2024/09/03/%E7%AD%9B%E6%B3%95/</id>
    <published>2024-09-03T07:51:05.000Z</published>
    <updated>2024-09-20T04:43:20.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区间筛">区间筛</h2><p>例题:每次给一对 $l,r$ ,求区间内的质数有多少个.<br>范围是 $l\le r\le10^{12},b-a\le10^6$.</p><p>首先要明白一个常见的道理: 区间 $[a,b]$ 内最大的质因数是 $\sqrt b$ .所以我们要先打好1e6内的表,然后利用坐标偏移再打好lr的表即可.</p><p>看到 $10^{12}$ 的数据范围要想到区间筛.因为数据范围这么大的话,一般要用到,&quot;一个数的最小质因数不会超过 $\sqrt n$ &quot;这个结论,然后先质数筛,再对每个数进行质因数分解O(logn).然后利用唯一分解定理把约数组合拼上去即可.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;区间筛&quot;&gt;区间筛&lt;/h2&gt;
&lt;p&gt;例题:每次给一对 $l,r$ ,求区间内的质数有多少个.&lt;br&gt;
范围是 $l&#92;le r&#92;le10^{12},b-a&#92;le10^6$.&lt;/p&gt;
&lt;p&gt;首先要明白一个常见的道理: 区间 $[a,b]$ 内最大的质因数是 $&#92;sqrt</summary>
      
    
    
    
    <category term="Math" scheme="https://narafluorine.github.io/categories/Math/"/>
    
    
    <category term="NumberTheory" scheme="https://narafluorine.github.io/tags/NumberTheory/"/>
    
  </entry>
  
  <entry>
    <title>推式子</title>
    <link href="https://narafluorine.github.io/2024/09/03/%E6%8E%A8%E5%BC%8F%E5%AD%90/"/>
    <id>https://narafluorine.github.io/2024/09/03/%E6%8E%A8%E5%BC%8F%E5%AD%90/</id>
    <published>2024-09-03T04:46:12.000Z</published>
    <updated>2024-10-12T13:00:23.345Z</updated>
    
    <content type="html"><![CDATA[<p>以下是推式子时间,记录一些公式的求解过程.(以及一些奇奇怪怪的公式)</p><ol><li><p>求解的个数:(1e9取模)<br>$$\frac1x+\frac1y=\frac1{n!}$$<br>首先我们发现,1/x和1/y都是小于1/n!的,所以x和y应该是大于n!的.<br>我们设 $y=n!+k,k\in N^+$ ,于是式子变成<br>$$\frac1x+\frac1{n!+k}=\frac1{n!}$$<br>化简变成<br>$$x=n!+\frac{(n!)^2}k$$<br>我们就统计一下约数个数就行了,具体地,线性筛一下,算出每个数的最小质因数,因为 $x^2$ 的每个约数都是 $x$ 的两倍,所以我们要先乘2再加1.</p></li><li><p>求<br>$$\sum_{k=1}^n\Big\lfloor\frac{(3k+6)!+1}{3k+7}-\Big\lfloor\frac{(3k+6)!}{3k+7}\Big\rfloor\Big\rfloor$$<br>我们分情况考虑,假设 $3k+7$ 是质数,则由定理知 $(3k+6)!\equiv-1\mod (3k+7)$ ,所以我们设 $(3k+6)!+1=a(3k+7)$ (同时注意,模意义下只能这么干,不要想着逆元解决),原式即为<br>$$\Big\lfloor a-\Big\lfloor a-\frac{1}{3k+7}\Big\rfloor\Big\rfloor=1$$<br>同时,假如不是质数,由于其质因子全部包含在阶乘里面,也就有了 $(3k+7)|(3k+6)!$ .这个时候还是设 $(3k+6)!=a(3k+7)$ ,式子可以化为<br>$$\Big\lfloor a+\frac{1}{3k+7}-a\Big\rfloor=0$$<br>所以,式子只是让我们统计一下有多少个 $3k+7$ 是质数.</p></li><li><p>求 $x^2+y^2=19451945$ :凑配法:对于展开数有以下式子:<br>$$(ac+bd)^2+(ad-bc)^2=(a^2+b^2)(c^2+d^2)$$<br>然后19451945就能分解为1945*10001,现在开始考虑分解1945,在3的时候能分解,问题解决了.最后的abcd分别是 $3,44,100,1$ ,答案是 $344,4397$ .</p></li></ol><h2 id="其他奇奇怪怪的公式">其他奇奇怪怪的公式</h2><ol><li>feb表示斐波那契数列第n项.<br>$$\gcd(feb_{n},feb_{m})=feb_{\gcd(n,m)}$$</li><li></li></ol><h2 id="升幂引理">升幂引理</h2><p>规定 $v_p(n)$ 表示n中有多少个p这个因子.</p><ol><li>素数p和与p互质的n.<br>若 $p|x-y$ 有<br>$$v_p(x^n-y^n)=v_p(x-y)$$<br>若 $p|x+y$ 则对 <strong>奇数</strong> n有<br>$$v_p(x^n+y^n)=v_p(x+y)$$</li><li>若p不是2(是奇质数):<br>若 $p|x-y$ 有<br>$$v_p(x^n-y^n)=v_p(x-y)+v_p(n)$$<br>若 $p|x+y$ 则对 <strong>奇数</strong> n有<br>$$v_p(x^n+y^n)=v_p(x+y)+v_p(n)$$</li><li>若p是2且 $p|x-y$ 对 <strong>偶数</strong> n有<br>$$v_p(x^n-y^n)=v_p(x-y)+v_p(x+y)+v_p(n)-1$$</li><li>对于 $4|x-y$<br>$$v_2(x+y)=1$$<br>$$v_2(x^n-y^n)=v_2(x-y)+v_2(n)$$</li></ol><h2 id="Wilson威尔逊定理">Wilson威尔逊定理</h2><p>$$(p-1)!\equiv-1\mod p$$</p><ol><li><p>特殊的阶乘(n比p大,不计所有p的因子对p取模)<br>$$\begin{aligned}&amp;(n!)\mod p\=&amp;(-1)^{\lfloor\frac{n}{p}\rfloor}\Big(\Big\lfloor\frac np\Big\rfloor!\Big)\mod p\end{aligned}$$<br>打一个阶乘表可以 $\log_pn$解决.</p></li><li><p>Lagenre(勒让德)公式<br>$$v_p(n!)=\sum_{i=1}^\infin\Big\lfloor\frac n{p^i}\Big\rfloor=\frac{n-S_p(n)}{p-1}$$<br>其中, $S_p(n)$ 表示在p进制下n每位数字和.(注意,直接除,别搞什么逆元啥的)</p></li></ol><h2 id="类欧几里得算法">类欧几里得算法</h2><ol><li>我们需要logn解决.设<br>$$\begin{aligned}f(a,b,c,n)=&amp;\sum_{i=0}^n\Big\lfloor\frac{ai+b}{c}\Big\rfloor\=&amp;\sum_{i=0}^n\Big\lfloor\frac{(\lfloor\frac ac\rfloor c+a\mod c)i+(\lfloor\frac bc\rfloor c+b\mod c)}{c}\Big\rfloor\=&amp;\frac{n(n+1)}2\Big\lfloor\frac ac\Big\rfloor+(n+1)\Big\lfloor\frac bc\Big\rfloor+\sum_{i=0}^n\Big\lfloor\frac{(a\mod c)i+(b\mod c)}c\Big\rfloor<br>\=&amp;\frac{n(n+1)}2\Big\lfloor\frac ac\Big\rfloor+(n+1)\Big\lfloor\frac bc\Big\rfloor+f(a\mod c,b\mod c,c,n)\end{aligned}$$<br>改变一下求和项目看到<br>$$\begin{aligned}f(a,b,c,n)&amp;=\sum_{k=0}^{m-1}\sum_{i=0}^n\Big[i&gt;\Big\lfloor\frac{jc+c-b-1}{a}\Big\rfloor\Big]<br>\&amp;=\sum_{j=0}^{m-1}\Big(n-\Big\lfloor\frac{jc+c-b-a}a\Big\rfloor\Big)<br>\&amp;=nm-f(c,c-b-1,a,m-1)\end{aligned}$$<br>中间有<br>$$n^2=2\frac{n(n+1)}2-n=\Big(\sum_{i=0}^ni\Big)-n$$</li></ol><h2 id="万能欧几里得算法">万能欧几里得算法</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下是推式子时间,记录一些公式的求解过程.(以及一些奇奇怪怪的公式)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;求解的个数:(1e9取模)&lt;br&gt;
$$&#92;frac1x+&#92;frac1y=&#92;frac1{n!}$$&lt;br&gt;
首先我们发现,1/x和1/y都是小于1/n!的,所以x和y应该是</summary>
      
    
    
    
    <category term="Math" scheme="https://narafluorine.github.io/categories/Math/"/>
    
    
    <category term="NumberTheory" scheme="https://narafluorine.github.io/tags/NumberTheory/"/>
    
  </entry>
  
  <entry>
    <title>CF Round970 Div3</title>
    <link href="https://narafluorine.github.io/2024/09/03/CF-Round970-Div3/"/>
    <id>https://narafluorine.github.io/2024/09/03/CF-Round970-Div3/</id>
    <published>2024-09-02T16:01:54.000Z</published>
    <updated>2024-09-03T04:43:01.996Z</updated>
    
    <content type="html"><![CDATA[<p>CF场.收获颇丰.</p><p>栈区开新数组是默认可能会很混乱的取值,可以在后面加一个大括号,然后就是0了. <code>int a[114][514]&#123;&#125;</code></p><p>首先是看大佬的码风.两个模板构造的默认是前面一个是默认分配大小,后面一个是每个元素初始值.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">114</span>,<span class="number">514</span>);</span><br></pre></td></tr></table></figure><p>然后是找最大元素.有一个很方便的函数是 <code>max_element</code> ,直接给两个指针,返回最大元素指针,多个就返回第一个指针.</p><p>相对的,肯定也有 <code>min_element</code> 了,在此不表.</p><p>然后是前缀和后缀和的巧妙应用.如果我要遍历一个数组,在每个点都会用到前缀和和后缀和,这个时候有一个优化就是,先求前缀和(一个数,不是数组),然后从末尾开始,减掉该点,同时再来一个数代表后缀和,就这样倒着边算后缀和,减掉前缀和,同时计算出答案.</p><h2 id="字符串">字符串</h2><p>奇数位的字符串在前面删掉一个元素的时候会变成偶数,也就是说直接让这个奇数位在求后缀和的时候装偶数位的就行了,没必要自己给自己设套,又是映射又是四个数组的.</p><h2 id="位运算">位运算</h2><p><code>a&amp;1^1</code> 是判定一个数是不是偶数的算法,再也不用写成 <code>(!(a&amp;1))</code> 而且为了优先级担心半天了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CF场.收获颇丰.&lt;/p&gt;
&lt;p&gt;栈区开新数组是默认可能会很混乱的取值,可以在后面加一个大括号,然后就是0了. &lt;code&gt;int a[114][514]&amp;#123;&amp;#125;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先是看大佬的码风.两个模板构造的默认是前面一个是默认分配大小,后</summary>
      
    
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/categories/OTH/"/>
    
    
    <category term="Contest" scheme="https://narafluorine.github.io/tags/Contest/"/>
    
  </entry>
  
  <entry>
    <title>Prufer序列</title>
    <link href="https://narafluorine.github.io/2024/08/29/Prufer%E5%BA%8F%E5%88%97/"/>
    <id>https://narafluorine.github.io/2024/08/29/Prufer%E5%BA%8F%E5%88%97/</id>
    <published>2024-08-29T14:12:54.000Z</published>
    <updated>2024-08-30T05:11:13.903Z</updated>
    
    <content type="html"><![CDATA[<p>Prufer序列的构造略,这里主要总结应用.</p><p>完全图 $K_n$ 有 $n^{n-2}$ 棵生成树.证明:Prufer序列值域是[1,n],有n-2个,QED.</p><h2 id="性质">性质</h2><p>在Prufer序列中出现次数为d-1的节点的度数是d.</p><p>所以,给一个序列表示每个点的度数,可以计算出来这样的无根树一共有<br>$$\prod_{i=1}^n\binom{rest}{d_i-1}$$<br>个,rest表示每次选数剩下的位置.</p><h2 id="图联通方案数">图联通方案数</h2><blockquote><p>一个n个点m条边的带标号无向图有k个连通块.我们希望添加k-1条边使得整个图连通.求方案数.</p></blockquote><p>首先是多项组合数公式:表示从<br>$$\binom{a}{b,c,d}=\frac{a!}{b!c!d!}$$<br>然后是多元二项式定理:<br>$$(x_1+…+x_m)^p=\sum_{c_i\ge0,\sum_{i=1}^{m}c_i=p}\binom{p}{c_1,…,c_m}\cdot\prod_{i=1}^{m}x_i^{c_i}$$<br>结论:<br>$$n^{k-2}\cdot\prod_{i=1}^{k}s_i$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Prufer序列的构造略,这里主要总结应用.&lt;/p&gt;
&lt;p&gt;完全图 $K_n$ 有 $n^{n-2}$ 棵生成树.证明:Prufer序列值域是[1,n],有n-2个,QED.&lt;/p&gt;
&lt;h2 id=&quot;性质&quot;&gt;性质&lt;/h2&gt;
&lt;p&gt;在Prufer序列中出现次数为d-1的节点的</summary>
      
    
    
    
    <category term="Graph&amp;Network" scheme="https://narafluorine.github.io/categories/Graph-Network/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>图论</title>
    <link href="https://narafluorine.github.io/2024/08/25/%E5%9B%BE%E8%AE%BA/"/>
    <id>https://narafluorine.github.io/2024/08/25/%E5%9B%BE%E8%AE%BA/</id>
    <published>2024-08-24T16:28:44.000Z</published>
    <updated>2024-10-06T06:47:33.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Floyd算法">Floyd算法</h2><p>通过dp的方式进行转移, <code>dp[i][j]</code> 表示从i到j的最小边权和.<br>还可以这么想,在一个没有权值的图中, <code>dp[i][j]</code> 表示i能到j.现在,假设dp是一个矩阵,则 $dp^k$ 的意思就是从i花费k步能到达j的方案总数.<br>例题:一个人在图上1节点,每步可以走向与他相连的其他节点,也可以不动,还可以自爆,自爆之后就不能动了,求经过k步之后的所有行走情况和.<br>一些特殊情况的处理:</p><ol><li>这一步不动: 自己给自己连边,形成自环即可.</li><li>自爆: 我们假想一个新节点0, 所有点和0连边,0不和任何点连边(自爆之后不能转移出去).</li></ol><p>最后,套上矩阵快速幂板子即可.</p><h2 id="dfs序-欧拉序">dfs序 欧拉序</h2><p>这俩的区别就是,前者是节点遍历到的时候只会有一次,后者是来的时候一次走的时候再来一次.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Floyd算法&quot;&gt;Floyd算法&lt;/h2&gt;
&lt;p&gt;通过dp的方式进行转移, &lt;code&gt;dp[i][j]&lt;/code&gt; 表示从i到j的最小边权和.&lt;br&gt;
还可以这么想,在一个没有权值的图中, &lt;code&gt;dp[i][j]&lt;/code&gt; 表示i能到j.现在,假设d</summary>
      
    
    
    
    <category term="Graph&amp;Network" scheme="https://narafluorine.github.io/categories/Graph-Network/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>随机数算法</title>
    <link href="https://narafluorine.github.io/2024/08/08/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%AE%97%E6%B3%95/"/>
    <id>https://narafluorine.github.io/2024/08/08/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%AE%97%E6%B3%95/</id>
    <published>2024-08-08T08:44:15.000Z</published>
    <updated>2024-08-08T09:50:36.976Z</updated>
    
    <content type="html"><![CDATA[<h1>随机数引擎</h1><p>常见的有两个,一个是<code>rand()</code>,另一个是随机数引擎<code>mt19937</code>.</p><h2 id="shuffle">shuffle</h2><p>洗牌算法,和sort一样用,开头,结尾,随机数引擎.(随机打乱)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::mt19937 <span class="title">rnd</span><span class="params">(seed)</span></span>;</span><br><span class="line"><span class="built_in">shuffle</span>(dat,dat+<span class="number">1</span>+n,rnd);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;随机数引擎&lt;/h1&gt;
&lt;p&gt;常见的有两个,一个是&lt;code&gt;rand()&lt;/code&gt;,另一个是随机数引擎&lt;code&gt;mt19937&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;shuffle&quot;&gt;shuffle&lt;/h2&gt;
&lt;p&gt;洗牌算法,和sort一样用,开头,结尾,随机数引</summary>
      
    
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/categories/OTH/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>WA问题速查</title>
    <link href="https://narafluorine.github.io/2024/08/06/WA%E9%97%AE%E9%A2%98%E9%80%9F%E6%9F%A5/"/>
    <id>https://narafluorine.github.io/2024/08/06/WA%E9%97%AE%E9%A2%98%E9%80%9F%E6%9F%A5/</id>
    <published>2024-08-06T08:12:51.000Z</published>
    <updated>2024-10-05T14:25:58.260Z</updated>
    
    <content type="html"><![CDATA[<p>在这里记录一些自己可能察觉不到的莫名WA.</p><h2 id="祖宗">祖宗</h2><p>开long long了吗?</p><h2 id="取模">取模</h2><p>有的时候要对答案进行特判,输出一个定值.但是又有的时候模数不是指定的,是要输入的,于是可能出现特判1但是模数是1正好被卡的状况…</p><h2 id="交互">交互</h2><p><code>cout&lt;&lt;&quot;!&quot;&lt;&lt;solve()&lt;&lt;endl;</code>是错的,尤其是交互库的时候千万不要这么搞,会WA,因为<code>cout</code>先执行输出然后再计算函数的值.</p><h2 id="除法">除法</h2><p>检查一下有没有除0模0的特判,不然会RE的哦.</p><h2 id="分解">分解</h2><p>什么时候能用 $O(\sqrt n)$ 的数分解(也就是<code>for(int i=2;i*i&lt;=n;++i)</code>)?当然是不影响后续的时候.假如产生影响就只能一个一个枚举了…(比如 $g(x)=\sum_{i|x}g(i)$ )</p><p>还有还有,那就是在 $f(x),f(n/x)$ 的时候记得看一下这俩数一不一样,会出大问题!!!</p><h2 id="双指针">双指针</h2><p>记得结算的时候动一下指针.</p><h2 id="DP转移">DP转移</h2><p>有的时候,状态之间会进行转换.状态之间提前到达的时候不要使用<code>dpxx=xx%m</code>,应该用<code>dpxx=(dpxx+xx)%m</code>,因为状态提前到达的时候会被<code>=</code>直接归零,就白转移了,不是<code>memset</code>的问题.</p><h2 id="树">树</h2><p>给定一棵树有n个节点,首先要判定是不是一棵树!!!(ie度数和 $\sum_{i=1}^nd_i=n-2$ )<br>一定要特判节点为1的时候有多少种情况!!!</p><ol><li>树的相同判定:给一个深度上有多少节点的数组,判断这样的树是否唯一.</li></ol><p>然而我们发现只有连着的节点大于2的才有多种,单独2后面还有链的并不算,可以看演示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> a   a   a   a</span><br><span class="line">/|\ /|\ /|\ /|\</span><br><span class="line">bcd bcd bcd bcd</span><br><span class="line">||  ||| |\|</span><br><span class="line">ee  efg efg</span><br><span class="line">这两种树本质上一样.但是这俩不一样.</span><br></pre></td></tr></table></figure><h2 id="图论">图论</h2><ol><li>给一张无向图,遍历他,染个色(只保证无自环重边).</li></ol><p>肯定是要bfs的了,但是有个hack是 <strong>给的图不一定连通</strong> ,所以要在bfs这里套一个循环保证每个点都要进队(被遍历到).(CF687A)</p><h2 id="数学">数学</h2><p>鸽巢的时候记得卡一下边界,虽然书上说最多能放 $\lceil\frac nk\rceil$ 个,但是最多能着的下 $n%k$ 种,记得统计一下.(另外,如果ceil等于直接除的话要特判,因为此时 $n%k$ 等于0)</p><h1>大坑</h1><h2 id="目力">目力</h2><p>众所周知,某些质数因为长得像而混迹998244353,而有的则是正确输出 <code>YE5</code> ,错误输出 <code>N0</code> ,就很邪恶.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">998244853</span> 是质数</span><br><span class="line"><span class="number">998244259</span> 是质数</span><br><span class="line"><span class="number">99824353</span>  是质数</span><br><span class="line"><span class="number">998242353</span> 不是质数</span><br><span class="line"><span class="number">100000007</span>(<span class="number">1e8</span>+<span class="number">7</span>) 是质数</span><br><span class="line"></span><br><span class="line"><span class="number">19491001</span> 是质数</span><br><span class="line"><span class="number">19260817</span> 是质数</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在这里记录一些自己可能察觉不到的莫名WA.&lt;/p&gt;
&lt;h2 id=&quot;祖宗&quot;&gt;祖宗&lt;/h2&gt;
&lt;p&gt;开long long了吗?&lt;/p&gt;
&lt;h2 id=&quot;取模&quot;&gt;取模&lt;/h2&gt;
&lt;p&gt;有的时候要对答案进行特判,输出一个定值.但是又有的时候模数不是指定的,是要输入的,于是可能出现</summary>
      
    
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/categories/OTH/"/>
    
    
    <category term="Contest" scheme="https://narafluorine.github.io/tags/Contest/"/>
    
  </entry>
  
  <entry>
    <title>技巧</title>
    <link href="https://narafluorine.github.io/2024/08/03/%E6%8A%80%E5%B7%A7/"/>
    <id>https://narafluorine.github.io/2024/08/03/%E6%8A%80%E5%B7%A7/</id>
    <published>2024-08-03T15:36:16.000Z</published>
    <updated>2024-08-08T07:00:14.889Z</updated>
    
    <content type="html"><![CDATA[<p>RT,这里写一些题目中总结的技巧.</p><h2 id="分段">分段</h2><ol><li><a href="https://codeforces.com/problemset/problem/1419/C">空调</a>.一个空调有一个位置和温度,向两边传送温度,<code>+1</code>递增,问所有格子有多凉快.</li></ol><p><code>std</code>把空调向左传播和向右传播分开了,然后分别维护一个<code>L</code>和<code>R</code>表示向左传播向右传播的最小值,可以做一个DP.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RT,这里写一些题目中总结的技巧.&lt;/p&gt;
&lt;h2 id=&quot;分段&quot;&gt;分段&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1419/C&quot;&gt;空调&lt;/a&gt;.一个空调有一个位置和温度,向两边传送温度</summary>
      
    
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/categories/OTH/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
</feed>
