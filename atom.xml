<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fluorine&#39;s blog</title>
  
  <subtitle>菜 Noob</subtitle>
  <link href="https://narafluorine.github.io/atom.xml" rel="self"/>
  
  <link href="https://narafluorine.github.io/"/>
  <updated>2024-09-18T07:04:37.114Z</updated>
  <id>https://narafluorine.github.io/</id>
  
  <author>
    <name>Fluorine Wengers</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>哈希</title>
    <link href="https://narafluorine.github.io/2024/09/18/%E5%93%88%E5%B8%8C/"/>
    <id>https://narafluorine.github.io/2024/09/18/%E5%93%88%E5%B8%8C/</id>
    <published>2024-09-17T16:57:48.000Z</published>
    <updated>2024-09-18T07:04:37.114Z</updated>
    
    <content type="html"><![CDATA[<p>哈希的简单陈述.</p><p>哈希是干嘛的?提供一种映射关系,能够把字符串或者树通过某种加密关系换算成一个数,从而进行比较或者直接排序.</p><p>自然,撞哈希的概率关乎哈希算法的核心.</p><h2 id="字符串哈希">字符串哈希</h2><p><s>Flu刚开始学字符串哈希的时候真的就是只学哈希来了,umap该开的还是开,字符串哈希完了装umap里,乐</s></p><p>字符串哈希,就是把一段字符串哈希变成一个数(双哈希是变成一对数),然后可以进行排序,然后直接检测有多少哈希值就行了(也就是多少种不同的字符串).</p><p>字符串哈希一般都是进制哈希.主要分为三种实现方法:<strong>自然溢出法(也就是模 $2^64$),单模哈希法(一个很大的质数),双模哈希(返回一对哈希值,据说很难卡掉)</strong>.</p><h2 id="例题">例题</h2><ol><li>矩阵哈希:给你两个矩阵,问两个矩阵中最大的重合子矩阵的大小(边长)是多少.</li></ol><p>我们发现边长是单调的,于是考虑二分.设 $k$ 是当前查验的边长.我们把两个矩阵的所有子矩阵直接哈希加到哈希表里面,然后排个序,直接比较(采用umap可以再掉一个log).时间复杂度是 $O(n^2\log^2n)$ .</p><h2 id="手写哈希表">手写哈希表</h2><p>一般而言有两种方式:拉链法和顺次法.</p><p>我们开一段连续空间,然后在空间内提供哈希算法,模上空间大小,大概就是实际的存储位置.<br><strong>拉链法</strong>:每个单点是一个链表,存储的时候如果哈希冲突就链表加一个节点,访问的时候遍历链表.<br><strong>顺次法</strong>:存储的时候如果哈希冲突,直接顺次访问(n+1),(n+2)等元素.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;哈希的简单陈述.&lt;/p&gt;
&lt;p&gt;哈希是干嘛的?提供一种映射关系,能够把字符串或者树通过某种加密关系换算成一个数,从而进行比较或者直接排序.&lt;/p&gt;
&lt;p&gt;自然,撞哈希的概率关乎哈希算法的核心.&lt;/p&gt;
&lt;h2 id=&quot;字符串哈希&quot;&gt;字符串哈希&lt;/h2&gt;
&lt;p&gt;&lt;s&gt;Flu刚</summary>
      
    
    
    
    <category term="DataStructure" scheme="https://narafluorine.github.io/categories/DataStructure/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>模拟退火</title>
    <link href="https://narafluorine.github.io/2024/09/12/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"/>
    <id>https://narafluorine.github.io/2024/09/12/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/</id>
    <published>2024-09-12T06:02:25.000Z</published>
    <updated>2024-09-12T06:09:35.583Z</updated>
    
    <content type="html"><![CDATA[<p>很简单,我们逐渐退火让答案稳定在某段区间内.</p><p>算法不讲解了,什么以多项式概率接受啥的哪都没用,主要讲怎么应用模拟退火.</p><p>个人认为比较困难的点是如何&quot;渐进地&quot;生成新的逼近的随机答案,不然模拟退火就是单纯的随机数碰答案.</p><h2 id="二元函数求最值">二元函数求最值</h2><h2 id="三分xy的情况">三分xy的情况</h2><p>我们以吊打xxx为例.加入x值定死,势能变化随y是一个单峰函数.</p><p>也就是说,我们可以三分y从而达到理想效果.</p><p>如何三分?考虑一个单峰,假如落在三分中间,那么怎么收缩都是涵盖的.<br>假如没有,我们三分的两个点会是一个明显递增或者递减的趋势,此时收紧,也就是说一次收缩大概1/3,剩下的2/3接着三分即可;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很简单,我们逐渐退火让答案稳定在某段区间内.&lt;/p&gt;
&lt;p&gt;算法不讲解了,什么以多项式概率接受啥的哪都没用,主要讲怎么应用模拟退火.&lt;/p&gt;
&lt;p&gt;个人认为比较困难的点是如何&amp;quot;渐进地&amp;quot;生成新的逼近的随机答案,不然模拟退火就是单纯的随机数碰答案.&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Math" scheme="https://narafluorine.github.io/categories/Math/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>概率与组合数学</title>
    <link href="https://narafluorine.github.io/2024/09/12/%E2%80%9C%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E2%80%9D/"/>
    <id>https://narafluorine.github.io/2024/09/12/%E2%80%9C%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E2%80%9D/</id>
    <published>2024-09-12T06:01:57.000Z</published>
    <updated>2024-09-14T12:53:47.388Z</updated>
    
    <content type="html"><![CDATA[<p>万恶之源组合数学.以及概率.</p><h2 id="插板法">插板法</h2><p>求 $a_1+…+a_k=n$ 的正整数解的个数.答案就是<br>$$\binom{n-1}{k-1}$$<br>非负整数解:借数.<br>$$\binom{n+k-1}{n}$$<br>每组至少要分到 $a_i$ 个呢?假设 $x’$ 是删完必须要加的,我们就转换为求非负解了.<br>$$\binom{n-\sum a_i+k-1}{n-\sum a_i}$$<br>不相邻排列:其实还是借数插在中间,然后组合.<br>$$\binom{n-k+1}{k}$$</p><h2 id="组合数公式">组合数公式</h2><p>$$\binom nm=\binom n{n-m}$$<br>$$\binom nk+\binom n{k+1}=\binom{n+1}k$$<br>$$\binom nk=\frac nk\binom{n-1}{k-1}$$<br>$$\binom nm=\binom n{m-1}+\binom{n-1}{m-1}$$<br>DP求杨辉三角的时候用这个.<br>$$\sum_{i=0}^n\binom ni=2^n$$<br>二项式定理取a=1,b=1的特殊情况.<br>$$\sum_{i=0}^n(-1)^i\binom ni=[n=0]$$<br>二项式定理取a=1,b=-1的特殊情况.<br>$$\sum_{i=0}^m\binom ni\binom m{n-i}=\binom{n+m}m,(n\ge m)$$<br>拆组合数的式子.某些数据结构题会遇到.<br>$$\sum_{i=0}^n\binom ni^2=\binom{2n}n$$<br>上一个式子的特殊情况(n=m).<br>$$\sum_{i=0}^ni\binom ni=n2^{n-1}$$<br>求导可证.<br>$$\sum_{i=0}^ni^2\binom ni=\frac{n(n+1)}22^{n-1}$$<br>也是多项式求导可证.<br>$$\sum_{i=0}^n\binom ik=\binom {n+1}{k+1}$$<br>子集分析可证.<br>$$\binom nr\binom rk=\binom nk\binom{n-k}{r-k}$$<br>定义证明.<br>$$\sum_{i=0}^n\binom{n-i}i=F_{n+1}$$<br>其中, $F_n$ 是斐波那契数列.</p><p><strong>多重组合数</strong> :多重集的排列数就是多重组合数.多重集的排列可以理解为有一个集合 $S={n_1a_1,n_2a_2,…,n_ka_k}$ ,有这么多种相同元素,他的全排列叫做多重组合数,公式<br>$$\binom{n}{n_1,n_2,…,n_k}=\frac{n!}{\prod_{i=1}^kn_i!}$$</p><h2 id="圆排列">圆排列</h2><p>部分圆排列公式:<br>$$Q_n^r=\frac{A_n^r}r=\frac{n!}{r\times(n-r)!}$$</p><h2 id="二项式反演">二项式反演</h2><p>设 $f_n$ 是n个元素形成特定结构的方案数, $g_n$ 是从n个元素选 $i,i\ge0$ 个元素形成结构的方案数.根据f求g有<br>$$g_n=\sum_{i=0}^n\binom nif_i$$<br>根据g求f则有<br>$$f_n=\sum_{i=0}^n\binom ni(-1)^{n-i}g_i$$<br>这个逆推的过程就叫二项式反演.</p><h2 id="容斥原理">容斥原理</h2><p>$$\left|\bigcup_{i=1}^nS_i\right|=\sum_{m=1}^n(-1)^{m-1}\sum_{a_i&lt;a_{i+1}}\left|\bigcap_{i=1}^mS_{a_i}\right|$$<br>下面是求交的容斥.<br>$$\left|\bigcap_{i=1}^nS_i\right|=|U|-\left|\bigcup_{i=1}^n\overline{S_i}\right|$$<br><strong>容斥模型</strong> :式子<br>$$\left|\bigcap_{a_i&lt;a_{i+1}}^{1\le i\le k}S_{a_i}\right|$$<br>的不定方程形式是<br>$$\sum_{i=1}^nx_i=m-\sum_{i=1}^k(b_{a_i}+1)$$</p><h2 id="容斥应用">容斥应用</h2><ol><li>硬币计数:给四种硬币的面值,n次询问每次询问给出四种硬币的数量以及s表示这么多个硬币能够拼凑出s的方案数.</li></ol><p>套模型:也就是求解<br>$$\sum_{i=1}^4C_ix_i=S-\sum_{i=1}^kC_{a_i}(D_{a_i}+1)$$<br>我们首先考虑无限金币,此时就是完全背包.假如一枚金币超过了应当的容量,就要减去对应的差值,枚举子集即可.</p><h2 id="常见误区">常见误区</h2><ol><li>误用组合数<br>概述:由于上一个选了之后会影响下一次选的概率,导致单纯组合数的结果并不是概率出来的结果.</li></ol><blockquote><p>例子:n张A票n张B票,买票的时候是抛硬币决定卖哪张票,问最后两个位置是相同票的概率,此时设想第一位选了一种的时候第二位会发生概率变换导致单纯组合数的概率并不是真正的概率.(问题出在结果判定上,假如没另一种票了就直接剩下的一样,也就是说组合数的概率不一样)<br>$$\xcancel{\frac{n-1}{2n-1}}$$<br>正解:DP,其实也能算组合数,假设最后两张票不一样,就会是前2n-2张票有n-1张A和B票.这个时候的概率就是<br>$$P=C^{n-1}_{2n-2}\Big(\frac12\Big)^{2n-2}=\frac{(2n-2)!}{4^{n-1}(n-1)!(n-1)!}$$<br>实现O(n)计算.答案是1-P.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;万恶之源组合数学.以及概率.&lt;/p&gt;
&lt;h2 id=&quot;插板法&quot;&gt;插板法&lt;/h2&gt;
&lt;p&gt;求 $a_1+…+a_k=n$ 的正整数解的个数.答案就是&lt;br&gt;
$$&#92;binom{n-1}{k-1}$$&lt;br&gt;
非负整数解:借数.&lt;br&gt;
$$&#92;binom{n+k-1}{n}$$</summary>
      
    
    
    
    <category term="Math" scheme="https://narafluorine.github.io/categories/Math/"/>
    
    
    <category term="NumberTheory" scheme="https://narafluorine.github.io/tags/NumberTheory/"/>
    
  </entry>
  
  <entry>
    <title>三角函数库</title>
    <link href="https://narafluorine.github.io/2024/09/11/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%BA%93/"/>
    <id>https://narafluorine.github.io/2024/09/11/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%BA%93/</id>
    <published>2024-09-11T05:04:16.000Z</published>
    <updated>2024-09-11T10:46:55.460Z</updated>
    
    <content type="html"><![CDATA[<p>常见的三角函数库.以及 <code>float</code> , <code>double</code> 范围.</p><h2 id="float">float</h2><p>范围大概是 <code>1e-38~1e38</code> .精度大概是7位.</p><h2 id="double">double</h2><p>范围: <code>1e-308~1e308</code> .精度大概是15-16位.</p><h2 id="三角函数">三角函数</h2><p><code>sin</code><br><code>cos</code><br><code>tan</code><br><code>asin</code><br><code>acos</code><br><code>atan</code><br><code>atan2(double y,double x)</code> :传入 $(y,x)$ ,输出与 $x$ 轴正方向角度(坐标轴下是负值).</p><p>参数: <code>sin</code> , <code>sinf</code> , <code>sinl</code> ,其实都差不多,单纯是传入参数的区别.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;常见的三角函数库.以及 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; 范围.&lt;/p&gt;
&lt;h2 id=&quot;float&quot;&gt;float&lt;/h2&gt;
&lt;p&gt;范围大概是 &lt;code&gt;1e-38~1e38&lt;/code&gt; .精度大概是7位.&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    <category term="Math" scheme="https://narafluorine.github.io/categories/Math/"/>
    
    
    <category term="C++" scheme="https://narafluorine.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>万能欧几里得</title>
    <link href="https://narafluorine.github.io/2024/09/10/%E4%B8%87%E8%83%BD%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    <id>https://narafluorine.github.io/2024/09/10/%E4%B8%87%E8%83%BD%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</id>
    <published>2024-09-10T09:54:53.000Z</published>
    <updated>2024-09-10T13:26:14.676Z</updated>
    
    <content type="html"><![CDATA[<p>万能欧几里得推式子的时间.</p><p>万能欧几里得的作用是求一些类似辗转相除的算法,需要递归求解的东西.万能欧几里得的泛用性在于主板子基本不用换,只需要稍微修改合并部分的代码.</p><p>可以使用矩阵的思想.</p><ol><li>求<br>$$\sum_{i=0}^{n}\left\lfloor\frac{ai+b}{c}\right\rfloor, \sum_{i=0}^{n}\left\lfloor\frac{ai+b}{c}\right\rfloor^{2}, \sum_{i=0}^{n}i\left\lfloor\frac{ai+b}{c}\right\rfloor $$<br>设<br>$$f(x)=\lfloor\frac{Px+R}Q\rfloor $$<br>求：<br>$$\sum_{i=1}^nf(i),\sum_{i=1}^nf^2(i),\sum_{i=1}^nif(i)$$<br>下文设$y=f(x)$,即求：<br>$$A=\sum y,B=\sum y^{2},C=\sum xy$$<br>一般万欧都需要维护$U$和$R$的数量(记为$u$和$r$).</li></ol><p>合并两段信息$I_0$与$I_{1}$,结果为$I$ ,考虑增量:<br>$$y\leftarrow y_1+u_0 \<br>x\leftarrow x_1+r_0$$<br>$$\begin{aligned}<br>A-A_0&amp;=\sum y \<br>&amp;=\sum(y_1+u_0) \<br>&amp;=\sum y_1+u_0r_1 \<br>&amp;=A_1+u_0r_1 \<br>B-B_{0} &amp;=\sum y^2 \<br>&amp;=\sum(y_1+u_0)^2 \<br>&amp;=\sum y_1^2+2u_0\sum y_1+u_0^2r_1 \<br>&amp;=B_1+2u_0A_1+u_0^2r_1 \<br>C-C_0 &amp;=\sum xy \<br>&amp;=\sum(x_1+r_0)(y_1+u_0) \<br>&amp;=\sum x_1y_1+u_0\sum x_1+r_0\sum y_1+u_0r_0r_1 \<br>&amp;=C_1+u_0\frac{r_1(r_1+1)}2+r_0A_1+u_0r_0r_1<br>\end{aligned}$$<br>也就是说 $\sum$ 里面(y)加 $u$ ,外面加 $r$ .</p><h2 id="弊端">弊端</h2><p>$$\sum\sqrt{y},\sum x^y,\sum a^{xy},\sum2^{2^y},\sum Asin(wy+\phi)$$<br>由于单维影响无法差分线性,即我们无法设计出一个好的矩阵来表达其值,所以上述式子均无法计算.</p><p>崩:loj138没调出来.<br>loj6440.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> enter fout&lt;&lt;<span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> space fout&lt;&lt;<span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dot fout&lt;&lt;<span class="string">&quot;,&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> oui fout&lt;&lt;<span class="string">&quot;Yes&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> non fout&lt;&lt;<span class="string">&quot;No&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si fout&lt;&lt;<span class="string">&quot;?&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> fastio&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> bufl=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> base1[<span class="number">16</span>]=&#123;<span class="number">1</span>,<span class="number">1e-1</span>,<span class="number">1e-2</span>,<span class="number">1e-3</span>,<span class="number">1e-4</span>,<span class="number">1e-5</span>,<span class="number">1e-6</span>,<span class="number">1e-7</span>,<span class="number">1e-8</span>,<span class="number">1e-9</span>,<span class="number">1e-10</span>,<span class="number">1e-11</span>,<span class="number">1e-12</span>,<span class="number">1e-13</span>,<span class="number">1e-14</span>,<span class="number">1e-15</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> base2[<span class="number">16</span>]=&#123;<span class="number">1</span>,<span class="number">1e1</span>,<span class="number">1e2</span>,<span class="number">1e3</span>,<span class="number">1e4</span>,<span class="number">1e5</span>,<span class="number">1e6</span>,<span class="number">1e7</span>,<span class="number">1e8</span>,<span class="number">1e9</span>,<span class="number">1e10</span>,<span class="number">1e11</span>,<span class="number">1e12</span>,<span class="number">1e13</span>,<span class="number">1e14</span>,<span class="number">1e15</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IN</span>&#123;</span><br><span class="line">FILE *IT;<span class="type">char</span> ibuf[bufl],*is=ibuf,*it=ibuf;</span><br><span class="line"><span class="built_in">IN</span>()&#123;IT=stdin;&#125;<span class="built_in">IN</span>(<span class="type">char</span> *a)&#123;IT=<span class="built_in">fopen</span>(a,<span class="string">&quot;r&quot;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getChar</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(is==it)&#123;it=(is=ibuf)+<span class="built_in">fread</span>(ibuf,<span class="number">1</span>,bufl,IT);<span class="keyword">if</span>(is==it)<span class="keyword">return</span> EOF;&#125;<span class="keyword">return</span> *is++;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getInt</span><span class="params">(Temp &amp;a)</span></span>&#123;a=<span class="number">0</span>;<span class="type">int</span> b=<span class="number">0</span>,c=<span class="built_in">getChar</span>();<span class="keyword">while</span>(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)b^=(c==<span class="number">45</span>),c=<span class="built_in">getChar</span>();<span class="keyword">while</span>(c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>)a=(a&lt;&lt;<span class="number">1</span>)+(a&lt;&lt;<span class="number">3</span>)+c<span class="number">-48</span>,c=<span class="built_in">getChar</span>();<span class="keyword">if</span>(b)a=-a;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getDouble</span><span class="params">(Temp &amp;a)</span></span>&#123;a=<span class="number">0</span>;<span class="type">int</span> b=<span class="number">0</span>,c=<span class="built_in">getChar</span>(),d=<span class="number">0</span>;__int128 e=<span class="number">0</span>,f=<span class="number">0</span>;<span class="keyword">while</span>(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)b^=(c==<span class="number">45</span>),c=<span class="built_in">getChar</span>();<span class="keyword">while</span>(c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>)e=(e&lt;&lt;<span class="number">1</span>)+(e&lt;&lt;<span class="number">3</span>)+c<span class="number">-48</span>,c=<span class="built_in">getChar</span>();<span class="keyword">if</span>(c==<span class="number">46</span>)&#123;c=<span class="built_in">getChar</span>();<span class="keyword">while</span>(c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>)d++,f=(f&lt;&lt;<span class="number">1</span>)+(f&lt;&lt;<span class="number">3</span>)+c<span class="number">-48</span>,c=<span class="built_in">getChar</span>();&#125;a=e+base1[d]*f;<span class="keyword">if</span>(b)a=-a;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">char</span> &amp;a)&#123;a=<span class="built_in">getChar</span>();<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">char</span> *a)&#123;<span class="keyword">do</span>&#123;*a=<span class="built_in">getChar</span>();&#125;<span class="keyword">while</span>(*a&lt;=<span class="number">32</span>);<span class="keyword">while</span>(*a&gt;<span class="number">32</span>)*++a=<span class="built_in">getChar</span>();*a=<span class="number">0</span>;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(string &amp;a)&#123;<span class="type">char</span> b=<span class="built_in">getChar</span>();<span class="keyword">while</span>(b&lt;=<span class="number">32</span>)b=<span class="built_in">getChar</span>();<span class="keyword">while</span>(b&gt;<span class="number">32</span>)a+=b,b=<span class="built_in">getChar</span>();<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">int</span> &amp;a)&#123;<span class="built_in">getInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">long</span> <span class="type">long</span> &amp;a)&#123;<span class="built_in">getInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(__int128 &amp;a)&#123;<span class="built_in">getInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">float</span> &amp;a)&#123;<span class="built_in">getDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">double</span> &amp;a)&#123;<span class="built_in">getDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">IN&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="type">long</span> <span class="type">double</span> &amp;a)&#123;<span class="built_in">getDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OUT</span>&#123;</span><br><span class="line">FILE *IT;<span class="type">char</span> obuf[bufl],*os=obuf,*ot=obuf+bufl;<span class="type">int</span> Eps;<span class="type">long</span> <span class="type">double</span> Acc;</span><br><span class="line"><span class="built_in">OUT</span>()&#123;IT=stdout,Eps=<span class="number">6</span>,Acc=<span class="number">0.5</span>;&#125;<span class="built_in">OUT</span>(<span class="type">char</span> *a)&#123;IT=<span class="built_in">fopen</span>(a,<span class="string">&quot;w&quot;</span>),Eps=<span class="number">6</span>,Acc=<span class="number">0.5</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ChangEps</span><span class="params">(<span class="type">int</span> x=<span class="number">6</span>)</span></span>&#123;Eps=x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">flush</span><span class="params">()</span></span>&#123;<span class="built_in">fwrite</span>(obuf,<span class="number">1</span>,os-obuf,IT);os=obuf;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putChar</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;*os++=a;<span class="keyword">if</span>(os==ot)<span class="built_in">flush</span>();&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putInt</span><span class="params">(Temp a)</span></span>&#123;<span class="keyword">if</span>(a&lt;<span class="number">0</span>)&#123;<span class="built_in">putChar</span>(<span class="number">45</span>);a=-a;&#125;<span class="keyword">if</span>(a&lt;<span class="number">10</span>)&#123;<span class="built_in">putChar</span>(a+<span class="number">48</span>);<span class="keyword">return</span>;&#125;<span class="built_in">putInt</span>(a/<span class="number">10</span>);<span class="built_in">putChar</span>(a%<span class="number">10</span>+<span class="number">48</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putLeading</span><span class="params">(Temp a,<span class="type">int</span> b)</span></span>&#123;<span class="keyword">if</span>(!b)<span class="keyword">return</span>;<span class="built_in">putLeading</span>(a/<span class="number">10</span>,b<span class="number">-1</span>);<span class="built_in">putChar</span>(a%<span class="number">10</span>+<span class="number">48</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Temp&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putDouble</span><span class="params">(Temp a)</span></span>&#123;<span class="keyword">if</span>(a&lt;<span class="number">0</span>)&#123;<span class="built_in">putChar</span>(<span class="number">45</span>);a=-a;&#125;__int128 b=a;<span class="built_in">putInt</span>(b);a-=b;a*=base2[Eps];b=a+Acc;<span class="built_in">putChar</span>(<span class="number">46</span>);<span class="built_in">putLeading</span>(b,Eps);&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">char</span> a)&#123;<span class="built_in">putChar</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> <span class="type">char</span> *a)&#123;<span class="keyword">while</span>(*a)<span class="built_in">putChar</span>(*a++);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(string a)&#123;<span class="keyword">for</span>(<span class="keyword">auto</span> c:a)<span class="built_in">putChar</span>(c);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">int</span> a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">long</span> <span class="type">long</span> a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(__int128 a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">unsigned</span> <span class="type">int</span> a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">unsigned</span> __int128 a)&#123;<span class="built_in">putInt</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">float</span> a)&#123;<span class="built_in">putDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">double</span> a)&#123;<span class="built_in">putDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">OUT&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">long</span> <span class="type">double</span> a)&#123;<span class="built_in">putDouble</span>(a);<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">~<span class="built_in">OUT</span>()&#123;<span class="built_in">flush</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">fastio::IN fin;</span><br><span class="line">fastio::OUT fout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">long</span> <span class="type">long</span> p=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">long</span> <span class="type">long</span> mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">qqp</span><span class="params">(T1 b,T2 po)</span></span>&#123;</span><br><span class="line">T1 res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(po&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(po&amp;<span class="number">1</span>)</span><br><span class="line">res=res*b%p;</span><br><span class="line">b=b*b%p;</span><br><span class="line">po&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> k1,k2;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> C[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> u,r,dat[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="built_in">node</span>(<span class="type">long</span> <span class="type">long</span> a=<span class="number">0</span>,<span class="type">long</span> <span class="type">long</span> b=<span class="number">0</span>):<span class="built_in">u</span>(a),<span class="built_in">r</span>(b)&#123;<span class="built_in">memset</span>(dat,<span class="number">0</span>,<span class="keyword">sizeof</span> dat);&#125;</span><br><span class="line">~<span class="built_in">node</span>()&#123;&#125;</span><br><span class="line">node <span class="keyword">operator</span>=(node io)&#123;</span><br><span class="line">u=io.u;</span><br><span class="line">r=io.r;</span><br><span class="line"><span class="built_in">memcpy</span>(dat,io.dat,<span class="keyword">sizeof</span> dat);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span>*(node io)&#123;</span><br><span class="line"><span class="function">node <span class="title">res</span><span class="params">((u+io.u)%mod,(r+io.r)%mod)</span></span>;</span><br><span class="line"><span class="built_in">memcpy</span>(res.dat,dat,<span class="keyword">sizeof</span> dat);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> uu=u%mod,rr=r%mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k1;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k2;++j)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> ii=<span class="number">0</span>,t1=<span class="number">1</span>;ii&lt;=i;++ii,t1=t1*uu%mod)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> jj=<span class="number">0</span>,t2=<span class="number">1</span>;jj&lt;=j;++jj,t2=t2*rr%mod)&#123;</span><br><span class="line">res.dat[i][j]=(res.dat[i][j]+(C[i][ii]*C[j][jj]*t1%mod*t2%mod*io.dat[i-ii][i-jj])%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">node <span class="title">qp</span><span class="params">(node b,<span class="type">long</span> <span class="type">long</span> po)</span></span>&#123;</span><br><span class="line">node res;</span><br><span class="line"><span class="keyword">while</span>(po&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(po&amp;<span class="number">1</span>)</span><br><span class="line">res=res*b;</span><br><span class="line">b=b*b;</span><br><span class="line">po&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">vargcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> c,<span class="type">long</span> <span class="type">long</span> n,node fu,node fr)</span></span>&#123;</span><br><span class="line">b%=c;</span><br><span class="line"><span class="keyword">if</span>(a&gt;=c)<span class="keyword">return</span> <span class="built_in">vargcd</span>(a%c,b,c,n,fu,<span class="built_in">qp</span>(fu,a/c)*fr);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> m=(a*n+b)/c;</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">qp</span>(fr,n);</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">qp</span>(fr,(c-b<span class="number">-1</span>)/a)*fu*<span class="built_in">vargcd</span>(c,c-b<span class="number">-1</span>,a,m<span class="number">-1</span>,fr,fu)*<span class="built_in">qp</span>(fr,n-(c*m-b<span class="number">-1</span>)/a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">U</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span>,<span class="title">R</span><span class="params">(<span class="number">0</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> t,a,b,c,n;</span><br><span class="line">fin&gt;&gt;t;</span><br><span class="line">C[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;++i)&#123;</span><br><span class="line">C[i][<span class="number">0</span>]=C[i][i]=C[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;i;++j)&#123;</span><br><span class="line">C[i][j]=C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;++i)&#123;</span><br><span class="line">U.dat[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">fin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;k1&gt;&gt;k2;</span><br><span class="line">node res;</span><br><span class="line">res.u=b/c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">0</span>,t=<span class="number">1</span>;i&lt;=<span class="number">10</span>;++i,t=(t*res.u)%mod)&#123;</span><br><span class="line">res.dat[i][<span class="number">0</span>]=t;</span><br><span class="line">&#125;</span><br><span class="line">fout&lt;&lt;(res*<span class="built_in">vargcd</span>(a,b,c,n,U,R)).dat[k1][k2]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;万能欧几里得推式子的时间.&lt;/p&gt;
&lt;p&gt;万能欧几里得的作用是求一些类似辗转相除的算法,需要递归求解的东西.万能欧几里得的泛用性在于主板子基本不用换,只需要稍微修改合并部分的代码.&lt;/p&gt;
&lt;p&gt;可以使用矩阵的思想.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;求&lt;br&gt;
$$&#92;sum_{i</summary>
      
    
    
    
    <category term="Math" scheme="https://narafluorine.github.io/categories/Math/"/>
    
    
    <category term="NumberTheory" scheme="https://narafluorine.github.io/tags/NumberTheory/"/>
    
  </entry>
  
  <entry>
    <title>数据结构选课学习笔记</title>
    <link href="https://narafluorine.github.io/2024/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://narafluorine.github.io/2024/09/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-09-09T05:01:32.000Z</published>
    <updated>2024-09-09T15:12:30.874Z</updated>
    
    <content type="html"><![CDATA[<p>这是数据结构选课的课内笔记,和 $OI$ 的高难数据结构关系不是很大,主要是记一些怕忘的定义.</p><h2 id="ADL语言">ADL语言</h2><p>算法 SM(A,n,&amp;min,&amp;max)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">max&lt;-min&lt;a[<span class="number">1</span>]</span><br><span class="line">FOR i=<span class="number">2</span> TO n DO</span><br><span class="line"><span class="keyword">if</span> A[i]&gt;max THEN max&lt;-a[i]</span><br><span class="line"><span class="keyword">if</span> A[i]&lt;min THEN min&lt;-a[i]</span><br></pre></td></tr></table></figure><p>举例<br>$$ADL:a\leftrightarrow b$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a^=b^=a^=b</span><br></pre></td></tr></table></figure><h2 id="算法的鲁棒性">算法的鲁棒性</h2><p>自动识别错误数据(并纠正)的能力.</p><h2 id="算法测试">算法测试</h2><p><strong>黑盒测试</strong>:测试点.<br><strong>白盒测试</strong>:语句覆盖,分支覆盖.</p><h2 id="时间复杂度">时间复杂度</h2><p>$O$ ,读音:big-oh;表示上界,小于等于.<br>$ο$ ,读音:small-oh;表示上界,小于.<br>$\Theta$ ,读音:theta、西塔;既是上界也是下界,称为确界,等于.<br>$\omega$ ,读音:small omega;表示下界,大于.<br>$\Omega$ ,读音:big omega、欧米伽;表示下界,大于等于.</p><p>Ο是渐进上界,Ω是渐进下界.Θ需同时满足大Ο和Ω,故称为确界.Ο极其有用,因为它表示了最差性能.</p><h2 id="时空积分">时空积分</h2><p>$$W=\int_0^tf(x)\mathrm dx$$</p><h2 id="多维数组寻址">多维数组寻址</h2><p>$$*=dat+\sum_{j=1}^{n-1}(i_j\times\prod^{n}_{p=k+1} m_p)*C$$<br>C代表<code>sizeof</code>,大乘号其实就是前缀积</p><h2 id="矩阵三元组表转置">矩阵三元组表转置</h2><p>Q:为啥PPT说的是 $O(nt)$ 的?<br>这个可以做到 $O(t\log t)$ .</p><h2 id="矩阵十字链表">矩阵十字链表</h2><p>cqcqcq</p><p>how $A\to A* …$</p><p>3.2.4十字链表</p><h2 id="字典序">字典序</h2><p>cqcqcq</p><h2 id="二叉树">二叉树</h2><p>满二叉树:顾名思义,节点全满,非常均匀.<br>完全二叉树:节点全的,末层缺失(<s>线段树</s>)</p><h2 id="线索二叉树">线索二叉树</h2><p>节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val,l,r,   pred,succ</span><br></pre></td></tr></table></figure><p>后面这俩存根,先根或者后根, <strong>可以存前根,中根或者后根</strong> ,故又称前序,中序或者后序线索二叉树.</p><p>cqc++…</p><h2 id="树转二叉树">树转二叉树</h2><p>深度相同兄弟之间连一条线,然后删掉所有非大孩子,刚连的线.</p><h2 id="森林转二叉树">森林转二叉树</h2><p>整一个首节点,然后连线,然后串串…</p><h2 id="树转森林">树转森林</h2><p>重剖,长剖.(不至于)</p><h2 id="哈夫曼树">哈夫曼树</h2><p>扩充二叉树:二叉树所有原来有空位的加子节点.</p><p>路径长度:<br>$$w=\sum_{i=1}^nw_id_i$$<br>其中w代表权值(就是存的那个数),然后d是路径长(深度-1),这个w最小的叫最优二叉树.</p><p>哈夫曼编码:左儿子是0,右儿子是1,直接走,走到哪编码.</p><p><strong>压缩</strong>:开一个map统计出现频率,然后建立哈夫曼树,直接译码. $O(n\log n)$ .<br><strong>解码</strong>:先读哈夫曼树,然后直接译码即可.</p><h3 id="哈夫曼树构造">哈夫曼树构造</h3><p>所有节点都是一个森林,然后每次选权值最小的根组成一个新树,产生一个新节点,加入其中,直到剩一个根.</p><h2 id="表达式树">表达式树</h2><p>中缀表达式树.这个一看就明白了,也没多难写.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(a+b)*(c+d)-e</span><br><span class="line">        -</span><br><span class="line">       / \</span><br><span class="line">      *   e</span><br><span class="line">     / \</span><br><span class="line">+   -</span><br><span class="line">   / \ / \</span><br><span class="line">   a b c d</span><br></pre></td></tr></table></figure><h2 id="图">图</h2><p>连通子图:顾名思义.<br>连通分量:把所有联通块抽出来就是了.</p><h2 id="拓扑排序">拓扑排序</h2><p>每次选一个入度为0的,然后删掉边,循环.</p><p>拓扑排序是 $O(n+e)$ 的.</p><h2 id="关键路径">关键路径</h2><p>cqcqcq</p><h2 id="可及性">可及性</h2><p>cqcqcq</p><h2 id="希尔排序-Shell">希尔排序(Shell)</h2><p>直接插入排序的改进.作为最先冲破 $O(n^2)$ 的排序算法,值得借鉴.</p><p>每次把增量分成n&gt;&gt;1,然后每个区间暴力插入排序.直到最后</p><h2 id="基数分布和值分布">基数分布和值分布</h2><p>基数排序,是模按照指定位数进行排序的算法,计数排序就是俗称的桶排序.</p><p>基数排序:先开十个链表,然后取最后一位看剩下的数.按照这个顺序先排起来.<br>然后取第二位接着排,直到元素有序.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是数据结构选课的课内笔记,和 $OI$ 的高难数据结构关系不是很大,主要是记一些怕忘的定义.&lt;/p&gt;
&lt;h2 id=&quot;ADL语言&quot;&gt;ADL语言&lt;/h2&gt;
&lt;p&gt;算法 SM(A,n,&amp;amp;min,&amp;amp;max)&lt;/p&gt;
&lt;figure class=&quot;highligh</summary>
      
    
    
    
    <category term="DataStructure" scheme="https://narafluorine.github.io/categories/DataStructure/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>筛法</title>
    <link href="https://narafluorine.github.io/2024/09/03/%E7%AD%9B%E6%B3%95/"/>
    <id>https://narafluorine.github.io/2024/09/03/%E7%AD%9B%E6%B3%95/</id>
    <published>2024-09-03T07:51:05.000Z</published>
    <updated>2024-09-03T08:11:53.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区间筛">区间筛</h2><p>例题:每次给一对 $l,r$ ,求区间内的质数有多少个.<br>范围是 $l\le r\le10^{12},b-a\le10^6$.</p><p>首先要明白一个常见的道理: 区间 $[a,b]$ 内最大的质因数是 $\sqrt b$ .所以我们要先打好1e6内的表,然后利用坐标偏移再打好lr的表即可.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;区间筛&quot;&gt;区间筛&lt;/h2&gt;
&lt;p&gt;例题:每次给一对 $l,r$ ,求区间内的质数有多少个.&lt;br&gt;
范围是 $l&#92;le r&#92;le10^{12},b-a&#92;le10^6$.&lt;/p&gt;
&lt;p&gt;首先要明白一个常见的道理: 区间 $[a,b]$ 内最大的质因数是 $&#92;sqrt</summary>
      
    
    
    
    <category term="Math" scheme="https://narafluorine.github.io/categories/Math/"/>
    
    
    <category term="NumberTheory" scheme="https://narafluorine.github.io/tags/NumberTheory/"/>
    
  </entry>
  
  <entry>
    <title>推式子</title>
    <link href="https://narafluorine.github.io/2024/09/03/%E6%8E%A8%E5%BC%8F%E5%AD%90/"/>
    <id>https://narafluorine.github.io/2024/09/03/%E6%8E%A8%E5%BC%8F%E5%AD%90/</id>
    <published>2024-09-03T04:46:12.000Z</published>
    <updated>2024-09-03T14:32:37.425Z</updated>
    
    <content type="html"><![CDATA[<p>以下是推式子时间,记录一些公式的求解过程.(以及一些奇奇怪怪的公式)</p><ol><li><p>求解的个数:(1e9取模)<br>$$\frac1x+\frac1y=\frac1{n!}$$<br>首先我们发现,1/x和1/y都是小于1/n!的,所以x和y应该是大于n!的.<br>我们设 $y=n!+k,k\in N^+$ ,于是式子变成<br>$$\frac1x+\frac1{n!+k}=\frac1{n!}$$<br>化简变成<br>$$x=n!+\frac{(n!)^2}k$$<br>我们就统计一下约数个数就行了,具体地,线性筛一下,算出每个数的最小质因数,因为 $x^2$ 的每个约数都是 $x$ 的两倍,所以我们要先乘2再加1.</p></li><li><p>求<br>$$\sum_{k=1}^n\Big\lfloor\frac{(3k+6)!+1}{3k+7}-\Big\lfloor\frac{(3k+6)!}{3k+7}\Big\rfloor\Big\rfloor$$<br>我们分情况考虑,假设 $3k+7$ 是质数,则由定理知 $(3k+6)!\equiv-1\mod (3k+7)$ ,所以我们设 $(3k+6)!+1=a(3k+7)$ (同时注意,模意义下只能这么干,不要想着逆元解决),原式即为<br>$$\Big\lfloor a-\Big\lfloor a-\frac{1}{3k+7}\Big\rfloor\Big\rfloor=1$$<br>同时,假如不是质数,由于其质因子全部包含在阶乘里面,也就有了 $(3k+7)|(3k+6)!$ .这个时候还是设 $(3k+6)!=a(3k+7)$ ,式子可以化为<br>$$\Big\lfloor a+\frac{1}{3k+7}-a\Big\rfloor=0$$<br>所以,式子只是让我们统计一下有多少个 $3k+7$ 是质数.</p></li></ol><h2 id="升幂引理">升幂引理</h2><p>规定 $v_p(n)$ 表示n中有多少个p这个因子.</p><ol><li>素数p和与p互质的n.<br>若 $p|x-y$ 有<br>$$v_p(x^n-y^n)=v_p(x-y)$$<br>若 $p|x+y$ 则对 <strong>奇数</strong> n有<br>$$v_p(x^n+y^n)=v_p(x+y)$$</li><li>若p不是2(是奇质数):<br>若 $p|x-y$ 有<br>$$v_p(x^n-y^n)=v_p(x-y)+v_p(n)$$<br>若 $p|x+y$ 则对 <strong>奇数</strong> n有<br>$$v_p(x^n+y^n)=v_p(x+y)+v_p(n)$$</li><li>若p是2且 $p|x-y$ 对 <strong>偶数</strong> n有<br>$$v_p(x^n-y^n)=v_p(x-y)+v_p(x+y)+v_p(n)-1$$</li><li>对于 $4|x-y$<br>$$v_2(x+y)=1$$<br>$$v_2(x^n-y^n)=v_2(x-y)+v_2(n)$$</li></ol><h2 id="Wilson威尔逊定理">Wilson威尔逊定理</h2><p>$$(p-1)!\equiv-1\mod p$$</p><ol><li><p>特殊的阶乘(n比p大,不计所有p的因子对p取模)<br>$$\begin{aligned}&amp;(n!)\mod p\=&amp;(-1)^{\lfloor\frac{n}{p}\rfloor}\Big(\Big\lfloor\frac np\Big\rfloor!\Big)\mod p\end{aligned}$$<br>打一个阶乘表可以 $\log_pn$解决.</p></li><li><p>Lagenre(勒让德)公式<br>$$v_p(n!)=\sum_{i=1}^\infin\Big\lfloor\frac n{p^i}\Big\rfloor=\frac{n-S_p(n)}{p-1}$$<br>其中, $S_p(n)$ 表示在p进制下n每位数字和.(注意,直接除,别搞什么逆元啥的)</p></li></ol><h2 id="类欧几里得算法">类欧几里得算法</h2><ol><li>我们需要logn解决.设<br>$$\begin{aligned}f(a,b,c,n)=&amp;\sum_{i=0}^n\Big\lfloor\frac{ai+b}{c}\Big\rfloor\=&amp;\sum_{i=0}^n\Big\lfloor\frac{(\lfloor\frac ac\rfloor c+a\mod c)i+(\lfloor\frac bc\rfloor c+b\mod c)}{c}\Big\rfloor\=&amp;\frac{n(n+1)}2\Big\lfloor\frac ac\Big\rfloor+(n+1)\Big\lfloor\frac bc\Big\rfloor+\sum_{i=0}^n\Big\lfloor\frac{(a\mod c)i+(b\mod c)}c\Big\rfloor<br>\=&amp;\frac{n(n+1)}2\Big\lfloor\frac ac\Big\rfloor+(n+1)\Big\lfloor\frac bc\Big\rfloor+f(a\mod c,b\mod c,c,n)\end{aligned}$$<br>改变一下求和项目看到<br>$$\begin{aligned}f(a,b,c,n)&amp;=\sum_{k=0}^{m-1}\sum_{i=0}^n\Big[i&gt;\Big\lfloor\frac{jc+c-b-1}{a}\Big\rfloor\Big]<br>\&amp;=\sum_{j=0}^{m-1}\Big(n-\Big\lfloor\frac{jc+c-b-a}a\Big\rfloor\Big)<br>\&amp;=nm-f(c,c-b-1,a,m-1)\end{aligned}$$<br>中间有<br>$$n^2=2\frac{n(n+1)}2-n=\Big(\sum_{i=0}^ni\Big)-n$$</li></ol><h2 id="万能欧几里得算法">万能欧几里得算法</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下是推式子时间,记录一些公式的求解过程.(以及一些奇奇怪怪的公式)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;求解的个数:(1e9取模)&lt;br&gt;
$$&#92;frac1x+&#92;frac1y=&#92;frac1{n!}$$&lt;br&gt;
首先我们发现,1/x和1/y都是小于1/n!的,所以x和y应该是</summary>
      
    
    
    
    <category term="Math" scheme="https://narafluorine.github.io/categories/Math/"/>
    
    
    <category term="NumberTheory" scheme="https://narafluorine.github.io/tags/NumberTheory/"/>
    
  </entry>
  
  <entry>
    <title>CF Round970 Div3</title>
    <link href="https://narafluorine.github.io/2024/09/03/CF-Round970-Div3/"/>
    <id>https://narafluorine.github.io/2024/09/03/CF-Round970-Div3/</id>
    <published>2024-09-02T16:01:54.000Z</published>
    <updated>2024-09-03T04:43:01.996Z</updated>
    
    <content type="html"><![CDATA[<p>CF场.收获颇丰.</p><p>栈区开新数组是默认可能会很混乱的取值,可以在后面加一个大括号,然后就是0了. <code>int a[114][514]&#123;&#125;</code></p><p>首先是看大佬的码风.两个模板构造的默认是前面一个是默认分配大小,后面一个是每个元素初始值.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">114</span>,<span class="number">514</span>);</span><br></pre></td></tr></table></figure><p>然后是找最大元素.有一个很方便的函数是 <code>max_element</code> ,直接给两个指针,返回最大元素指针,多个就返回第一个指针.</p><p>相对的,肯定也有 <code>min_element</code> 了,在此不表.</p><p>然后是前缀和后缀和的巧妙应用.如果我要遍历一个数组,在每个点都会用到前缀和和后缀和,这个时候有一个优化就是,先求前缀和(一个数,不是数组),然后从末尾开始,减掉该点,同时再来一个数代表后缀和,就这样倒着边算后缀和,减掉前缀和,同时计算出答案.</p><h2 id="字符串">字符串</h2><p>奇数位的字符串在前面删掉一个元素的时候会变成偶数,也就是说直接让这个奇数位在求后缀和的时候装偶数位的就行了,没必要自己给自己设套,又是映射又是四个数组的.</p><h2 id="位运算">位运算</h2><p><code>a&amp;1^1</code> 是判定一个数是不是偶数的算法,再也不用写成 <code>(!(a&amp;1))</code> 而且为了优先级担心半天了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CF场.收获颇丰.&lt;/p&gt;
&lt;p&gt;栈区开新数组是默认可能会很混乱的取值,可以在后面加一个大括号,然后就是0了. &lt;code&gt;int a[114][514]&amp;#123;&amp;#125;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先是看大佬的码风.两个模板构造的默认是前面一个是默认分配大小,后</summary>
      
    
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/categories/OTH/"/>
    
    
    <category term="Contest" scheme="https://narafluorine.github.io/tags/Contest/"/>
    
  </entry>
  
  <entry>
    <title>Prufer序列</title>
    <link href="https://narafluorine.github.io/2024/08/29/Prufer%E5%BA%8F%E5%88%97/"/>
    <id>https://narafluorine.github.io/2024/08/29/Prufer%E5%BA%8F%E5%88%97/</id>
    <published>2024-08-29T14:12:54.000Z</published>
    <updated>2024-08-30T05:11:13.903Z</updated>
    
    <content type="html"><![CDATA[<p>Prufer序列的构造略,这里主要总结应用.</p><p>完全图 $K_n$ 有 $n^{n-2}$ 棵生成树.证明:Prufer序列值域是[1,n],有n-2个,QED.</p><h2 id="性质">性质</h2><p>在Prufer序列中出现次数为d-1的节点的度数是d.</p><p>所以,给一个序列表示每个点的度数,可以计算出来这样的无根树一共有<br>$$\prod_{i=1}^n\binom{rest}{d_i-1}$$<br>个,rest表示每次选数剩下的位置.</p><h2 id="图联通方案数">图联通方案数</h2><blockquote><p>一个n个点m条边的带标号无向图有k个连通块.我们希望添加k-1条边使得整个图连通.求方案数.</p></blockquote><p>首先是多项组合数公式:表示从<br>$$\binom{a}{b,c,d}=\frac{a!}{b!c!d!}$$<br>然后是多元二项式定理:<br>$$(x_1+…+x_m)^p=\sum_{c_i\ge0,\sum_{i=1}^{m}c_i=p}\binom{p}{c_1,…,c_m}\cdot\prod_{i=1}^{m}x_i^{c_i}$$<br>结论:<br>$$n^{k-2}\cdot\prod_{i=1}^{k}s_i$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Prufer序列的构造略,这里主要总结应用.&lt;/p&gt;
&lt;p&gt;完全图 $K_n$ 有 $n^{n-2}$ 棵生成树.证明:Prufer序列值域是[1,n],有n-2个,QED.&lt;/p&gt;
&lt;h2 id=&quot;性质&quot;&gt;性质&lt;/h2&gt;
&lt;p&gt;在Prufer序列中出现次数为d-1的节点的</summary>
      
    
    
    
    <category term="Graph&amp;Network" scheme="https://narafluorine.github.io/categories/Graph-Network/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>图论</title>
    <link href="https://narafluorine.github.io/2024/08/25/%E5%9B%BE%E8%AE%BA/"/>
    <id>https://narafluorine.github.io/2024/08/25/%E5%9B%BE%E8%AE%BA/</id>
    <published>2024-08-24T16:28:44.000Z</published>
    <updated>2024-08-24T17:27:38.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="dfs序-欧拉序">dfs序 欧拉序</h2><p>这俩的区别就是,前者是节点遍历到的时候只会有一次,后者是来的时候一次走的时候再来一次.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;dfs序-欧拉序&quot;&gt;dfs序 欧拉序&lt;/h2&gt;
&lt;p&gt;这俩的区别就是,前者是节点遍历到的时候只会有一次,后者是来的时候一次走的时候再来一次.&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Graph&amp;Network" scheme="https://narafluorine.github.io/categories/Graph-Network/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>随机数算法</title>
    <link href="https://narafluorine.github.io/2024/08/08/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%AE%97%E6%B3%95/"/>
    <id>https://narafluorine.github.io/2024/08/08/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%AE%97%E6%B3%95/</id>
    <published>2024-08-08T08:44:15.000Z</published>
    <updated>2024-08-08T09:50:36.976Z</updated>
    
    <content type="html"><![CDATA[<h1>随机数引擎</h1><p>常见的有两个,一个是<code>rand()</code>,另一个是随机数引擎<code>mt19937</code>.</p><h2 id="shuffle">shuffle</h2><p>洗牌算法,和sort一样用,开头,结尾,随机数引擎.(随机打乱)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::mt19937 <span class="title">rnd</span><span class="params">(seed)</span></span>;</span><br><span class="line"><span class="built_in">shuffle</span>(dat,dat+<span class="number">1</span>+n,rnd);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;随机数引擎&lt;/h1&gt;
&lt;p&gt;常见的有两个,一个是&lt;code&gt;rand()&lt;/code&gt;,另一个是随机数引擎&lt;code&gt;mt19937&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;shuffle&quot;&gt;shuffle&lt;/h2&gt;
&lt;p&gt;洗牌算法,和sort一样用,开头,结尾,随机数引</summary>
      
    
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/categories/OTH/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>WA问题速查</title>
    <link href="https://narafluorine.github.io/2024/08/06/WA%E9%97%AE%E9%A2%98%E9%80%9F%E6%9F%A5/"/>
    <id>https://narafluorine.github.io/2024/08/06/WA%E9%97%AE%E9%A2%98%E9%80%9F%E6%9F%A5/</id>
    <published>2024-08-06T08:12:51.000Z</published>
    <updated>2024-08-30T05:52:41.390Z</updated>
    
    <content type="html"><![CDATA[<p>在这里记录一些自己可能察觉不到的莫名WA.</p><h2 id="祖宗">祖宗</h2><p>开long long了吗?</p><h2 id="取模">取模</h2><p>有的时候要对答案进行特判,输出一个定值.但是又有的时候模数不是指定的,是要输入的,于是可能出现特判1但是模数是1正好被卡的状况…</p><h2 id="交互">交互</h2><p><code>cout&lt;&lt;&quot;!&quot;&lt;&lt;solve()&lt;&lt;endl;</code>是错的,尤其是交互库的时候千万不要这么搞,会WA,因为<code>cout</code>先执行输出然后再计算函数的值.</p><h2 id="除法">除法</h2><p>检查一下有没有除0模0的特判,不然会RE的哦.</p><h2 id="分解">分解</h2><p>什么时候能用 $O(\sqrt n)$ 的数分解(也就是<code>for(int i=2;i*i&lt;=n;++i)</code>)?当然是不影响后续的时候.假如产生影响就只能一个一个枚举了…(比如 $g(x)=\sum_{i|x}g(i)$ )</p><p>还有还有,那就是在 $f(x),f(n/x)$ 的时候记得看一下这俩数一不一样,会出大问题!!!</p><h2 id="双指针">双指针</h2><p>记得结算的时候动一下指针.</p><h2 id="DP转移">DP转移</h2><p>有的时候,状态之间会进行转换.状态之间提前到达的时候不要使用<code>dpxx=xx%m</code>,应该用<code>dpxx=(dpxx+xx)%m</code>,因为状态提前到达的时候会被<code>=</code>直接归零,就白转移了,不是<code>memset</code>的问题.</p><h2 id="树">树</h2><p>给定一棵树有n个节点,首先要判定是不是一棵树!!!(ie度数和 $\sum_{i=1}^nd_i=n-2$ )<br>一定要特判节点为1的时候有多少种情况!!!</p><ol><li>树的相同判定:给一个深度上有多少节点的数组,判断这样的树是否唯一.</li></ol><p>然而我们发现只有连着的节点大于2的才有多种,单独2后面还有链的并不算,可以看演示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> a   a   a   a</span><br><span class="line">/|\ /|\ /|\ /|\</span><br><span class="line">bcd bcd bcd bcd</span><br><span class="line">||  ||| |\|</span><br><span class="line">ee  efg efg</span><br><span class="line">这两种树本质上一样.但是这俩不一样.</span><br></pre></td></tr></table></figure><h2 id="图论">图论</h2><ol><li>给一张无向图,遍历他,染个色(只保证无自环重边).</li></ol><p>肯定是要bfs的了,但是有个hack是 <strong>给的图不一定连通</strong> ,所以要在bfs这里套一个循环保证每个点都要进队(被遍历到).(CF687A)</p><h2 id="数学">数学</h2><p>鸽巢的时候记得卡一下边界,虽然书上说最多能放 $\lceil\frac nk\rceil$ 个,但是最多能着的下 $n%k$ 种,记得统计一下.(另外,如果ceil等于直接除的话要特判,因为此时 $n%k$ 等于0)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在这里记录一些自己可能察觉不到的莫名WA.&lt;/p&gt;
&lt;h2 id=&quot;祖宗&quot;&gt;祖宗&lt;/h2&gt;
&lt;p&gt;开long long了吗?&lt;/p&gt;
&lt;h2 id=&quot;取模&quot;&gt;取模&lt;/h2&gt;
&lt;p&gt;有的时候要对答案进行特判,输出一个定值.但是又有的时候模数不是指定的,是要输入的,于是可能出现</summary>
      
    
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/categories/OTH/"/>
    
    
    <category term="Contest" scheme="https://narafluorine.github.io/tags/Contest/"/>
    
  </entry>
  
  <entry>
    <title>技巧</title>
    <link href="https://narafluorine.github.io/2024/08/03/%E6%8A%80%E5%B7%A7/"/>
    <id>https://narafluorine.github.io/2024/08/03/%E6%8A%80%E5%B7%A7/</id>
    <published>2024-08-03T15:36:16.000Z</published>
    <updated>2024-08-08T07:00:14.889Z</updated>
    
    <content type="html"><![CDATA[<p>RT,这里写一些题目中总结的技巧.</p><h2 id="分段">分段</h2><ol><li><a href="https://codeforces.com/problemset/problem/1419/C">空调</a>.一个空调有一个位置和温度,向两边传送温度,<code>+1</code>递增,问所有格子有多凉快.</li></ol><p><code>std</code>把空调向左传播和向右传播分开了,然后分别维护一个<code>L</code>和<code>R</code>表示向左传播向右传播的最小值,可以做一个DP.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RT,这里写一些题目中总结的技巧.&lt;/p&gt;
&lt;h2 id=&quot;分段&quot;&gt;分段&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1419/C&quot;&gt;空调&lt;/a&gt;.一个空调有一个位置和温度,向两边传送温度</summary>
      
    
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/categories/OTH/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Ad_Hoc</title>
    <link href="https://narafluorine.github.io/2024/08/03/Ad-Hoc/"/>
    <id>https://narafluorine.github.io/2024/08/03/Ad-Hoc/</id>
    <published>2024-08-03T03:39:21.000Z</published>
    <updated>2024-08-28T05:13:41.858Z</updated>
    
    <content type="html"><![CDATA[<p>这是迟早要开的<code>Ad_Hoc</code>专题,巧妙(<s>乱搞</s>)解法的题目会被收录在这里.</p><h2 id="CF1722G">CF1722G</h2><p>构造一个数列满足奇数项抑或和等于偶数项抑或和.(构造的数字必须在 $0-2^{31}$ 以内)</p><p>乍一看挺吓人?其实,因为值域很宽,各种各样的方法都可以通过.<br>法1:随机数,最后特判一下,如果重了就上一项抑或上某个数直到不重.<br>法2:直接排列,在1-n-3位上直接摆1-n-3,然后摆俩大数,n位上摆奇数项抑或偶数项保证相同.</p><h2 id="CF1930B">CF1930B</h2><p>构造一个序列满足不存在 $a_j|a_i,a_{j+1}|a_{i+1}$ ,样例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>因为倍数首先要满足 $a_i&gt;a_j$ ,然后这么构造也就需要满足所有偶数位大于奇数位,同时奇数位递增,偶数位递减即可.</p><h2 id="P10635">P10635</h2><p>给一个01矩阵,一次反转会翻转所有该硬币行和列的所有状态,求最少需要几次反转(方阵).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0101</span></span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="number">0010</span></span><br><span class="line"><span class="number">0101</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>我们不需要反转成全0或者全1,所以二者之间取最小值就行了.</p><p>发现,将单个元素反转的方法是,该行和该列上的全部元素全部反转一下就可以了.也就是说,给定矩阵必定有解.我们统计每行每列1的个数,然后遍历每个元素,看 <code>(s[i][j]-'0'+co[i]+ro[j])&amp;1</code> ,因为如果元素是1,我们要反转,所以要考虑原始矩阵对答案的贡献,不应该直接统计行列1的个数的那个.</p><p>Ciallo～(∠·ω&lt; )⌒★</p><p>Cyka Blyat(你好)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是迟早要开的&lt;code&gt;Ad_Hoc&lt;/code&gt;专题,巧妙(&lt;s&gt;乱搞&lt;/s&gt;)解法的题目会被收录在这里.&lt;/p&gt;
&lt;h2 id=&quot;CF1722G&quot;&gt;CF1722G&lt;/h2&gt;
&lt;p&gt;构造一个数列满足奇数项抑或和等于偶数项抑或和.(构造的数字必须在 $0-2^{31}$ </summary>
      
    
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/categories/OTH/"/>
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/tags/OTH/"/>
    
  </entry>
  
  <entry>
    <title>Markov Algorithm Online 攻略</title>
    <link href="https://narafluorine.github.io/2024/07/31/Markov-Algorithm-Online-%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/"/>
    <id>https://narafluorine.github.io/2024/07/31/Markov-Algorithm-Online-%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/</id>
    <published>2024-07-30T17:30:56.000Z</published>
    <updated>2024-08-24T05:50:12.398Z</updated>
    
    <content type="html"><![CDATA[<p>笔者接触了一种<a href="https://mao.snuke.org/">全新游戏</a>(加班.jpg),网上查了一圈发现没有做这个游戏攻略的,Flu只好以身作则,开一期专题聊这个.</p><h1>规则</h1><p>这是一种简单的语言,只有两个语句:<br><code>a:b</code>:把字符串<code>a</code>替换成<code>b</code>.<br><code>a::b</code>:把字符串<code>a</code>替换成<code>b</code>,程序结束.</p><p>(模式/替换的前导/尾随空格会被直接忽略)</p><p><strong>执行顺序</strong>:每次都是先执行前面的语句,如果第一句找到了就执行第一句,然后从头开始接着执行(中间执行了<code>::</code>会直接结束的).</p><h1>题解区</h1><p>好了,你已经学会了所有语法,去写一个程序吧(^_^)~</p><h2 id="0001">0001</h2><p>直接替换.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello,:World!</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">Hello,::World!</span><br></pre></td></tr></table></figure><h2 id="0002">0002</h2><p>删除所有的<code>s</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:</span><br></pre></td></tr></table></figure><h2 id="0003">0003</h2><p>把<code>s</code>加在头上(注意只能执行一次防止死循环)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::s</span><br></pre></td></tr></table></figure><h2 id="0004">0004</h2><p>剪刀石头布,对每种情况进行替换,注意每种只能执行一次.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R::P</span><br><span class="line">P::S</span><br><span class="line">S::R</span><br></pre></td></tr></table></figure><h2 id="0005">0005</h2><p>给一堆只有<code>i</code>的串,在每个之间插一个<code>w</code>.<br>也就是把所有<code>ii</code>换成<code>iwi</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ii:iwi</span><br></pre></td></tr></table></figure><h2 id="0006">0006</h2><p>对ABC进行排序,枚举三种将要进行的排序准则分别替换即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BA:AB</span><br><span class="line">CB:BC</span><br><span class="line">BA:AC</span><br></pre></td></tr></table></figure><h2 id="0007">0007</h2><p>给一段<code>o</code>判断有奇数个还是偶数个.<br>发现两个<code>o</code>没有贡献,直接消掉,最后判断即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oo:</span><br><span class="line">o::odd</span><br><span class="line">::even</span><br></pre></td></tr></table></figure><p>(注意先判有的odd,因为even是兜底的)</p><h2 id="0008">0008</h2><p>(感觉开始上强度了)给一段只有<code>b</code>的串,加一个<code>s</code>在末尾.<br>首先,是个人都应该清楚,因为字符串检测是从头开始的,我们要在<code>bb</code>这样的里面加东西.</p><p>加啥?Flu设想的是先把<code>bb</code>变成<code>bsb</code>,然后掉转顺序变成<code>bbs</code>,最后删掉所有的<code>bsb</code>.写出来长这样:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bb:bsb</span><br><span class="line">sb:bs</span><br><span class="line">bsb:bb</span><br></pre></td></tr></table></figure><p>跑起来死循环啊…考虑优化:<strong>顺序优化</strong>.每次查子串是从第一句开始查,也就是说符合条件的语句编号越小越优先执行,调整一下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sb:bs</span><br><span class="line">bb:bsb</span><br><span class="line">bsb:bb</span><br></pre></td></tr></table></figure><p>这个时候我们发现,他变成了一直往尾部加<code>s</code>,一个,两个…<br>到这应该明白了吧,我们让<code>b</code>变成<code>bs</code>,然后把<code>sb:bs</code>的交换优先级调整的比添加高,就可以顺到最后了,然后<code>ss::s</code>结束,完美.(<code>bb:bsb</code>会WA,只有一个<code>b</code>的情况)AC代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ss::s</span><br><span class="line">sb:bs</span><br><span class="line">b:bs</span><br></pre></td></tr></table></figure><h2 id="0009">0009</h2><p>给一个二进制串,按位反转.<br>首先想到,交换嘛,肯定有个tmp的防止反转再反转,于是<code>0</code>先换成<code>2</code>,再换成<code>1</code>,<code>1</code>也一样,调一下优先级.</p><p>发现,死循环了.我们注意到,即使是结果也是可以当输入的,我们要手动结束程序,于是考虑扫描,从左插一个<code>a</code>,每次枚举<code>a</code>左边的进行反转,<code>a</code>到头结束.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a0:<span class="number">1</span>a</span><br><span class="line">a1:<span class="number">0</span>a</span><br><span class="line">a::</span><br><span class="line">:a</span><br></pre></td></tr></table></figure><h2 id="0010">0010</h2><p>写一个加法器.<br>首先我们需要插一个东西在末尾.我们如何判定他插到末尾了?<br><strong>答:</strong> 插两个的时候.<br>然后程序向前遍历就很好写了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>ss::<span class="number">1</span></span><br><span class="line"><span class="number">1</span>ss:ss0</span><br><span class="line">ss::<span class="number">1</span></span><br><span class="line">s0:<span class="number">0</span>s</span><br><span class="line">s1:<span class="number">1</span>s</span><br><span class="line">:s</span><br></pre></td></tr></table></figure><h2 id="0011">0011</h2><p>计数.<br>首先,每一个o都是看成1,进位的时候直接放到左边即可.<br>数之间不允许直接加,否则会乱位,于是调整一下<code>o</code>变成<code>1</code>的优先级即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>o:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>o:<span class="number">2</span></span><br><span class="line"><span class="number">2</span>o:<span class="number">3</span></span><br><span class="line"><span class="number">3</span>o:<span class="number">4</span></span><br><span class="line"><span class="number">4</span>o:<span class="number">5</span></span><br><span class="line"><span class="number">5</span>o:<span class="number">6</span></span><br><span class="line"><span class="number">6</span>o:<span class="number">7</span></span><br><span class="line"><span class="number">7</span>o:<span class="number">8</span></span><br><span class="line"><span class="number">8</span>o:<span class="number">9</span></span><br><span class="line"><span class="number">9</span>o:o0</span><br><span class="line">o:<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="0012">0012</h2><p>会11的话12就很简单了.反向搞就行,注意0作为进位标志最后再摘.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:<span class="number">0</span>o</span><br><span class="line"><span class="number">2</span>:<span class="number">0</span>oo</span><br><span class="line"><span class="number">3</span>:<span class="number">0</span>ooo</span><br><span class="line"><span class="number">4</span>:<span class="number">0</span>oooo</span><br><span class="line"><span class="number">5</span>:<span class="number">0</span>ooooo</span><br><span class="line"><span class="number">6</span>:<span class="number">0</span>oooooo</span><br><span class="line"><span class="number">7</span>:<span class="number">0</span>ooooooo</span><br><span class="line"><span class="number">8</span>:<span class="number">0</span>oooooooo</span><br><span class="line"><span class="number">9</span>:<span class="number">0</span>ooooooooo</span><br><span class="line">o0:<span class="number">0</span>oooooooooo</span><br><span class="line"><span class="number">0</span>:</span><br></pre></td></tr></table></figure><h2 id="0013">0013</h2><h2 id="0014">0014</h2><h2 id="0015">0015</h2><h2 id="0016">0016</h2><p>显然,比5长的直接迭代缩减即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oooooo:ooooo</span><br></pre></td></tr></table></figure><h2 id="0017">0017</h2><p>显然,比5短的直接迭代增加即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ooooo::ooooo</span><br><span class="line">:o</span><br></pre></td></tr></table></figure><h2 id="0018">0018</h2><p>(最后还是看题解改成6行的屑)判断<code>ox</code>序列哪个多,输出<code>win,lose,draw</code>.<br>难点在于6行内完成.题解借用很长一段<code>x</code>保证<code>xo</code>一定能消掉<code>o</code>,从而完成消掉另一方,然后再归还<code>x</code>,多就是输,默认赢,不变就是平手.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xo:</span><br><span class="line">win+xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx:lose+</span><br><span class="line">win+xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx:draw+</span><br><span class="line">+x:+</span><br><span class="line">+::</span><br><span class="line">:win+xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure><h2 id="0019">0019</h2><p>发现排好序一定是<code>12345</code>,考虑如何把12345搞掉:好像没啥别的办法.不讲武德.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:</span><br><span class="line"><span class="number">2</span>:</span><br><span class="line"><span class="number">3</span>:</span><br><span class="line"><span class="number">4</span>:</span><br><span class="line"><span class="number">5</span>::<span class="number">12345</span></span><br></pre></td></tr></table></figure><h2 id="0020">0020</h2><p>给一个数字串,在每两个数字间加点.<br>显然,直接扫描即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a0:<span class="number">0.</span>a</span><br><span class="line">a1:<span class="number">1.</span>a</span><br><span class="line">a2:<span class="number">2.</span>a</span><br><span class="line">a3:<span class="number">3.</span>a</span><br><span class="line">a4:<span class="number">4.</span>a</span><br><span class="line">a5:<span class="number">5.</span>a</span><br><span class="line">a6:<span class="number">6.</span>a</span><br><span class="line">a7:<span class="number">7.</span>a</span><br><span class="line">a8:<span class="number">8.</span>a</span><br><span class="line">a9:<span class="number">9.</span>a</span><br><span class="line">.a::</span><br><span class="line">:a</span><br></pre></td></tr></table></figure><h2 id="0023">0023</h2><p>给一个数列(只有<code>012</code>),求他们的和模3.<br>显然暴力是会超行的,我们考虑替换,把0替换成111,2换成11就可以很简单的消除了.但是注意一个小坑是<code>111:</code>错<code>1111:1</code>对,因为假如最后没数字了就寄了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">111</span></span><br><span class="line"><span class="number">2</span>:<span class="number">11</span></span><br><span class="line"><span class="number">1111</span>:<span class="number">1</span></span><br><span class="line"><span class="number">111</span>::<span class="number">0</span></span><br><span class="line"><span class="number">11</span>::<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="0032">0032</h2><p>发现值域很窄,直接枚举.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xo:x</span><br><span class="line">oooooooooooooooooooooooooooooooo:<span class="number">5</span>x</span><br><span class="line">oooooooooooooooo:<span class="number">4</span>x</span><br><span class="line">oooooooo:<span class="number">3</span>x</span><br><span class="line">oooo:<span class="number">2</span>x</span><br><span class="line">oo:<span class="number">1</span>x</span><br><span class="line">o:<span class="number">0</span>x</span><br><span class="line">x::</span><br></pre></td></tr></table></figure><h2 id="0035">0035</h2><p>把第三个字符替换成<code>x</code>,送分.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ooo::oox</span><br></pre></td></tr></table></figure><h2 id="0036">0036</h2><p>把倒数第三个字符替换成<code>x</code>,插一个a,扫到末尾,结束,还是送分.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ao:oa</span><br><span class="line">oooa::xoo</span><br><span class="line">:a</span><br></pre></td></tr></table></figure><h2 id="0037">0037</h2><p>直接替换,注意第一个问号的优先级是最低的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m?:ma</span><br><span class="line">a?:ar</span><br><span class="line">r?:rk</span><br><span class="line">k?:ko</span><br><span class="line">o?:ov</span><br><span class="line">?:m</span><br></pre></td></tr></table></figure><h2 id="0038">0038</h2><p>发现转移的时候多余的o会没,但是最终状态的o也会跟着没,考虑扫描.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xbob:oxb</span><br><span class="line">xb:x</span><br><span class="line">xo:x</span><br><span class="line">x::</span><br><span class="line">:x</span><br></pre></td></tr></table></figure><h2 id="0045">0045</h2><p>直接删掉<code>-</code>即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-:</span><br></pre></td></tr></table></figure><h2 id="0048">0048</h2><p>找最大公因数即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ooo:oof</span><br><span class="line">oofoofoofoofoof:oofobfoofbofooz</span><br><span class="line">oofoofoofo:oofobfoofb</span><br><span class="line">oofoo:oofob</span><br></pre></td></tr></table></figure><h2 id="0049">0049</h2><p>直接替换.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bb:ba</span><br></pre></td></tr></table></figure><h2 id="0050">0050</h2><p>替换小心头部重复替换.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aa:ba</span><br><span class="line">bbb:bab</span><br></pre></td></tr></table></figure><h2 id="0051">0051</h2><p>扫描一遍即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zab:baz</span><br><span class="line">z::</span><br><span class="line">:z</span><br></pre></td></tr></table></figure><h2 id="0052">0052</h2><p>来一个被减数,左右对消即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ozo:z</span><br><span class="line">z::</span><br><span class="line">:ooooooooooz</span><br></pre></td></tr></table></figure><h2 id="0053">0053</h2><p>这里开始是几道闪电题,意思是尽快做出来而不是压行做出来,题目也非常傻逼(难).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xoo:ox</span><br><span class="line">x::</span><br><span class="line">:x</span><br></pre></td></tr></table></figure><h2 id="0054">0054</h2><h2 id="0061">0061</h2><p>冒号不能动,右边减一个左边加一个即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(:</span><br><span class="line">::(</span><br></pre></td></tr></table></figure><h2 id="0062">0062</h2><p>考虑整体转变,<code>00</code>先变成<code>01</code>再一个变成<code>00</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>:<span class="number">01</span></span><br><span class="line"><span class="number">01</span>::<span class="number">00</span></span><br></pre></td></tr></table></figure><h2 id="0063">0063</h2><p>打印空格.由于前导/尾随空格都会没,我们要构造两面包夹的形态.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">114514</span>:</span><br><span class="line"><span class="number">1919810</span>::</span><br><span class="line">:<span class="number">114514</span> <span class="number">1919810</span></span><br></pre></td></tr></table></figure><h2 id="0064">0064</h2><p>我们要去掉中间的空格,显然扫描线做.<br>注意到我们开头要插入一个没空格的,这里是没法转移的.我们考虑插一个形如<code>x y</code>的结构,然后再把y去掉,就可以成功转移了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x a:ax</span><br><span class="line">x b:bx</span><br><span class="line">x c:cx</span><br><span class="line">y:</span><br><span class="line">x::</span><br><span class="line">:x y</span><br></pre></td></tr></table></figure><h2 id="0069">0069</h2><p>注意到数据是4个<code>t</code>起手,考虑做一个头然后沿伸.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testtt:testtest</span><br><span class="line">tttt:testtest</span><br></pre></td></tr></table></figure><h2 id="0078">0078</h2><p>直接查找.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iwi::[iwi]</span><br></pre></td></tr></table></figure><h2 id="0079">0079</h2><p>发现最优解只有四行,而且由于结果可以作为输入,只好使用扫描线.但是扫描头添加(2),转移(2),检测(1),超了,要魔改.</p><p>咋改呢?有个好方法:鉴于只有<code>iw</code>,我们可以构造:很多<code>iiiiii</code>,然后不用转移<code>ii</code>,转移<code>iw</code>,就结束了.正好四行.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iiiiiiiiiiiiiiiiiiiiiiwi:[iwi]iiiiiiiiiiiiiiiiiiiii</span><br><span class="line">iiiiiiiiiiiiiiiiiiiiiw:wiiiiiiiiiiiiiiiiiiiii</span><br><span class="line">iiiiiiiiiiiiiiiiiiiii::</span><br><span class="line">:iiiiiiiiiiiiiiiiiiiii</span><br></pre></td></tr></table></figure><h2 id="0080">0080</h2><p>发现拆括号的过程就是放到外面然后乘二即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o]:]oo</span><br><span class="line">[]:</span><br></pre></td></tr></table></figure><h2 id="0085">0085</h2><p>我们考虑同质化,把他们变成0+啥,然后由于最后一个数字也肯定是<code>0+</code>,所以考虑<code>+0:0</code>,然后最后转化回去就可以了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>:<span class="number">0</span>++</span><br><span class="line"><span class="number">1</span>:<span class="number">0</span>+</span><br><span class="line">+<span class="number">0</span>:<span class="number">0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0</span></span><br><span class="line"><span class="number">0</span>++::<span class="number">2</span></span><br><span class="line"><span class="number">0</span>+::<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;笔者接触了一种&lt;a href=&quot;https://mao.snuke.org/&quot;&gt;全新游戏&lt;/a&gt;(加班.jpg),网上查了一圈发现没有做这个游戏攻略的,Flu只好以身作则,开一期专题聊这个.&lt;/p&gt;
&lt;h1&gt;规则&lt;/h1&gt;
&lt;p&gt;这是一种简单的语言,只有两个语句:&lt;br&gt;
</summary>
      
    
    
    
    <category term="Math" scheme="https://narafluorine.github.io/categories/Math/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>C++语法</title>
    <link href="https://narafluorine.github.io/2024/07/30/C-%E8%AF%AD%E6%B3%95/"/>
    <id>https://narafluorine.github.io/2024/07/30/C-%E8%AF%AD%E6%B3%95/</id>
    <published>2024-07-30T06:13:44.000Z</published>
    <updated>2024-09-14T16:27:22.683Z</updated>
    
    <content type="html"><![CDATA[<p>这里包含部分C++的语法以及调试技巧啥的,比较杂.</p><h1>基础库</h1><h2 id="杂项">杂项</h2><p>多表达式叠写返回值是后面那个.例如<code>a=b,1</code>返回后面那个<code>1</code>不是前面那个<code>a</code>.</p><p><code>unordered_map</code>不可以开出来自定义类型的图,因为没法算哈希,<code>map</code>可以.</p><h2 id="namespace">namespace</h2><p>名字空间就是防止名字重复特地设置的命名机制,形象理解就是套层壳,使用必须先叫名字空间::成员函数.对于不重的情况确实没啥用.<br>然后<code>using namespace xx</code>就是把封装好的函数直接用就行了(去壳).比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> IO&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; num)</span></span>&#123;xxx&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用:IO::read(xxx);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;<span class="comment">//去掉壳子</span></span><br><span class="line"><span class="comment">//调用:read(xxx);</span></span><br></pre></td></tr></table></figure><h2 id="typedef">typedef</h2><p>直观的就是给一个变量取一个小名,大名小名都能用.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> i32;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">float</span><span class="params">(*Func)</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> num)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aaa</span><span class="params">(Func f1,Func f2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aaa</span><span class="params">(<span class="type">float</span> f1(<span class="type">int</span> arr[],<span class="type">int</span> num),<span class="type">float</span> f2(<span class="type">int</span> arr[],<span class="type">int</span> num))</span></span>;</span><br></pre></td></tr></table></figure><p>可以直接置换函数,体会一下.</p><h2 id="math-h">math.h</h2><p><strong>cbrt</strong>:算立方根的函数.<br><strong>log</strong>:其实是求ln.<br><strong>log10</strong>:其实是求lg.<br><strong>ceil</strong>:向上取整.<br><strong>floor</strong>:向下取整.</p><h2 id="windows-h">windows.h</h2><p>系统相关的库文件,盲目交到OJ上会吃CE(一般OJ都是Linux).但是制作课设会用到(交互嘛).<br><strong>Sleep</strong>:睡觉函数,单位毫秒.<br><strong>system(“”)</strong>:著名的弹计算器函数.(真的能给我电脑直接干关机了,他能干啥不可想象,写病毒轻轻松松)</p><h2 id="IO">IO</h2><p>有的时候数据点多少个不告诉你,就需要用这个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对拍">对拍</h2><p>先写一个数据生成器再说…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;data.exe &gt; sstd.in&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;sstd.exe &lt; sstd.in &gt; sstd.out&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;your.exe &lt; sstd.in &gt; your.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">system</span>(<span class="string">&quot;rc sstd.txt your.txt&quot;</span>))<span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sstd可以是暴力,data是生成器.</p><h1>STL</h1><p>这里讲一些常用函数,免得忘了.</p><h2 id="vector">vector</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">push_back</span>(x)<span class="comment">//末尾插一个</span></span><br><span class="line">.<span class="built_in">pop_back</span>()<span class="comment">//末尾删一个</span></span><br><span class="line">[x]<span class="comment">//当成数组使用</span></span><br><span class="line">.<span class="built_in">empty</span>()<span class="comment">//是否为空</span></span><br><span class="line">.<span class="built_in">size</span>()<span class="comment">//大小</span></span><br><span class="line">.<span class="built_in">front</span>(),.<span class="built_in">back</span>()<span class="comment">//首尾元素</span></span><br><span class="line">::iterator<span class="comment">//指针</span></span><br><span class="line">.<span class="built_in">begin</span>(),.<span class="built_in">end</span>()<span class="comment">//首尾迭代器</span></span><br></pre></td></tr></table></figure><h2 id="stack">stack</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">top</span>()</span><br><span class="line">.<span class="built_in">push</span>()</span><br><span class="line">.<span class="built_in">size</span>()</span><br><span class="line">.<span class="built_in">pop</span>()</span><br><span class="line">.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><h2 id="queue">queue</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">push</span>()</span><br><span class="line">.<span class="built_in">pop</span>()</span><br><span class="line">.<span class="built_in">empty</span>()</span><br><span class="line">.<span class="built_in">front</span>(),.<span class="built_in">back</span>()</span><br><span class="line">.<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><h2 id="deque">deque</h2><p>双端队列,都差不多.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">push_back</span>(x);</span><br><span class="line">.<span class="built_in">push_front</span>(x);</span><br><span class="line">.<span class="built_in">front</span>();</span><br><span class="line">.<span class="built_in">back</span>();</span><br><span class="line">.<span class="built_in">pop_back</span>();</span><br><span class="line">.<span class="built_in">pop_front</span>();</span><br></pre></td></tr></table></figure><h2 id="priority-queue">priority_queue</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">top</span>()</span><br><span class="line">.<span class="built_in">push</span>()</span><br><span class="line">.<span class="built_in">size</span>()</span><br><span class="line">.<span class="built_in">pop</span>()</span><br><span class="line">.<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><h2 id="map">map</h2><p>红黑树,logn插入logn查询,支持自定义结构.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[x]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:mp)&#123;</span><br><span class="line">i.first,i.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unordered-map">unordered_map</h2><p>哈希表但是常数比较大,不支持自定义哈希.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[x]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:mp)&#123;</span><br><span class="line">i.first,i.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为人家是哈希表,有的东西开不了,能不能开和前一个键有关.前面一个键只能是常见类型,<code>char</code>,<code>short</code>,<code>int</code>,<code>long</code>,<code>long long</code>都是能开的,但是所有自定义类型都不可以,包括<code>pair</code>.</p><h2 id="set">set</h2><h2 id="bitset">bitset</h2><p>没用.常数听说比较大,而且省不了多少空间.</p><h2 id="multiset">multiset</h2><h2 id="multimap">multimap</h2><h2 id="stringUUU">stringUUU</h2><p>Flu不太会用.</p><h2 id="tuple">tuple</h2><h2 id="tie">tie</h2><p>UUU</p><h2 id="list">list</h2><p>封装的双向链表.废物,不支持随机化访问,真就单纯的一个链表是吧.</p><h1>PB_DS</h1><p>UUU</p><h1>OTH</h1><h2 id="lambda表达式">lambda表达式</h2><p>这玩意不是必须学的,能用它实现的功能用普通C++也可以实现,在这里偷个懒略了.</p><h2 id="对拍-2">对拍</h2><p>先写一个数据生成器再说…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;data.exe &gt; sstd.in&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;sstd.exe &lt; sstd.in &gt; sstd.out&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;your.exe &lt; sstd.in &gt; your.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">system</span>(<span class="string">&quot;rc sstd.txt your.txt&quot;</span>))<span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sstd可以是暴力,data是生成器.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里包含部分C++的语法以及调试技巧啥的,比较杂.&lt;/p&gt;
&lt;h1&gt;基础库&lt;/h1&gt;
&lt;h2 id=&quot;杂项&quot;&gt;杂项&lt;/h2&gt;
&lt;p&gt;多表达式叠写返回值是后面那个.例如&lt;code&gt;a=b,1&lt;/code&gt;返回后面那个&lt;code&gt;1&lt;/code&gt;不是前面那个&lt;code&gt;a&lt;/c</summary>
      
    
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/categories/OTH/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
    <category term="C++" scheme="https://narafluorine.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>DP</title>
    <link href="https://narafluorine.github.io/2024/07/29/DP/"/>
    <id>https://narafluorine.github.io/2024/07/29/DP/</id>
    <published>2024-07-29T13:53:29.000Z</published>
    <updated>2024-07-30T06:16:11.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="矩阵优化">矩阵优化</h2><p>指通过广义矩阵乘法让dp的方式优化,支持数据结构维护的操作.</p><p>定义广义矩阵乘法的操作是:<br>$$C_{i,j}=\bigoplus_{k=1}^m(A_{ik}\otimes B_{kj})$$<br>(其实就是重载+和*俩运算符)满足以下条件时乘法有 <strong>结合律</strong>:</p><ol><li>$\oplus$ 有交换律</li><li>$\otimes$ 有结合律和交换律</li><li>$\times$ 对 $\oplus$ 有分配律,也就是满足 $(a\oplus b)\otimes c=(a\otimes c)\oplus(b\otimes c)$ .</li></ol><p>常见的广义矩阵重载是(原来是 $(\times,+)$ ) $(\pm,\min),(\pm,\max),(\land,\lor)$</p><p>如此,矩阵可以使用快速幂优化,同时可以使用数据结构提前维护区间矩阵乘积,便于快速计算.</p><h2 id="例题">例题</h2><ol><li>GSS3单点修改,维护区间的最大子段和.<br>我们设 $f_i$ 表示以i结尾的最大子段和, $g_i$ 表示区间上的最大子段和.转移方程:<br>$$f_i=\max(f_{i-1}+a_i,a_i),g_i=\max(g_{i-1},f_{i-1}+a_i,a_i)$$<br>构造矩阵:<br>$$\begin{bmatrix}f_{i-1}&amp;g_{i-1}&amp;0\end{bmatrix}\begin{bmatrix}a_i&amp;a_i&amp;-\infin\-\infin&amp;0&amp;-\infin\a_i&amp;a_i&amp;0\end{bmatrix}=\begin{bmatrix}f_i&amp;g_i&amp;0\end{bmatrix}$$<br>然后使用线段树提前维护区间矩阵乘积即可.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;矩阵优化&quot;&gt;矩阵优化&lt;/h2&gt;
&lt;p&gt;指通过广义矩阵乘法让dp的方式优化,支持数据结构维护的操作.&lt;/p&gt;
&lt;p&gt;定义广义矩阵乘法的操作是:&lt;br&gt;
$$C_{i,j}=&#92;bigoplus_{k=1}^m(A_{ik}&#92;otimes B_{kj})$$&lt;br&gt;
(</summary>
      
    
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/categories/OTH/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Python语法</title>
    <link href="https://narafluorine.github.io/2024/07/28/Python%E8%AF%AD%E6%B3%95/"/>
    <id>https://narafluorine.github.io/2024/07/28/Python%E8%AF%AD%E6%B3%95/</id>
    <published>2024-07-28T05:42:51.000Z</published>
    <updated>2024-07-30T06:15:49.931Z</updated>
    
    <content type="html"><![CDATA[<p>这里讲一些基础语法.(基本上,精通一种语言,别的语言都大差不差能看懂)</p><h2 id="初等函数">初等函数</h2><h3 id="print">print</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;字符串&quot;</span>,算式,变量)</span><br></pre></td></tr></table></figure><p>参数:sep分隔符,默认空格,可以换成别的,end结尾符,默认换行,可以换别的.</p><h3 id="eval">eval</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">7</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;3*x&#x27;</span>)</span><br></pre></td></tr></table></figure><p>eval把字符串转换成算式并给出计算结果.</p><h3 id="namespace">namespace</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">namespace=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;a+b&#x27;</span>,namespace)</span><br></pre></td></tr></table></figure><p>在指定名字空间内执行语句长这样.</p><h3 id="if-else-elif-while-for">if else elif while for</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> xxx:</span><br><span class="line">    xxx</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    xxx</span><br><span class="line"><span class="keyword">elif</span>:</span><br><span class="line">    xxx</span><br><span class="line"><span class="keyword">while</span> xxx:</span><br><span class="line">    xxx</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(xxx):</span><br><span class="line">    xxx</span><br></pre></td></tr></table></figure><h4 id="range">range</h4><p>range可以接受三个参数,分别是[l,r)和步长.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">12</span>,<span class="number">16</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 12 14</span></span><br></pre></td></tr></table></figure><h3 id="注释">注释</h3><p>注释长这样:(只有一种注释方法,就是这个,单行有效,按住Ctrl+/即可)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xxx</span></span><br></pre></td></tr></table></figure><h3 id="变量类型">变量类型</h3><p>Python内置高精(C艹党吐血倒地),变量类型可以转变,有以下几种:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> <span class="built_in">int</span> string Bool(<span class="literal">True</span> <span class="literal">False</span>) 字典 列表 元组</span><br></pre></td></tr></table></figure><p>其中元组就是const形态的列表,一般用于函数返回值.(TF这俩必须大写,不大写认不出来)</p><h3 id="运算">运算</h3><p>按优先级排序:(上面的最高)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**幂</span><br><span class="line">~按位反</span><br><span class="line">* /除法 % //整除</span><br><span class="line">+ -</span><br><span class="line">&gt;&gt; &lt;&lt;</span><br><span class="line">&amp;</span><br><span class="line">^ |</span><br><span class="line">&lt;= &lt; &gt; &gt;=</span><br><span class="line">== !=</span><br><span class="line">= %= /= //= -= += *= **=</span><br><span class="line"><span class="keyword">is</span>  <span class="keyword">is</span> <span class="keyword">not</span></span><br><span class="line"><span class="keyword">in</span>  <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">and</span>  <span class="keyword">or</span> <span class="keyword">not</span></span><br></pre></td></tr></table></figure><p>小技巧:按住Ctrl+C会立刻结束程序的,不妨试试(C++也一样)</p><h3 id="import">import</h3><p>导入包.为了避免变量名冲突,建议只用<code>import xxx</code>的格式,<code>from xxx import*</code>会闹麻的(变量名冲突)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里讲一些基础语法.(基本上,精通一种语言,别的语言都大差不差能看懂)&lt;/p&gt;
&lt;h2 id=&quot;初等函数&quot;&gt;初等函数&lt;/h2&gt;
&lt;h3 id=&quot;print&quot;&gt;print&lt;/h3&gt;
&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="MachineLearn" scheme="https://narafluorine.github.io/categories/MachineLearn/"/>
    
    
    <category term="Python" scheme="https://narafluorine.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>公式杂项</title>
    <link href="https://narafluorine.github.io/2024/07/25/%E5%85%AC%E5%BC%8F%E6%9D%82%E9%A1%B9/"/>
    <id>https://narafluorine.github.io/2024/07/25/%E5%85%AC%E5%BC%8F%E6%9D%82%E9%A1%B9/</id>
    <published>2024-07-25T09:47:24.000Z</published>
    <updated>2024-09-12T08:58:43.809Z</updated>
    
    <content type="html"><![CDATA[<p>RT,这里放一些奇奇怪怪的公式.</p><h2 id="常见质数">常见质数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">99844353</span></span><br><span class="line"><span class="number">1000000007</span> <span class="number">1e9</span>+<span class="number">7</span></span><br><span class="line"><span class="number">100000000000000003</span> <span class="number">1e17</span>+<span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="判定奇数-判定偶数">判定奇数 判定偶数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n&amp;<span class="number">1</span>   <span class="comment">//奇数</span></span><br><span class="line">n&amp;<span class="number">1</span>^<span class="number">1</span> <span class="comment">//偶数,再也不用 !(n&amp;1)</span></span><br></pre></td></tr></table></figure><h2 id="MEX">MEX</h2><p>定义是最小的没出现在数列中的非负整数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mex</span><span class="params">(<span class="type">int</span>* dat,<span class="type">int</span> n)</span></span>&#123;<span class="comment">//[1,n]</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">mp[dat[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(mp[i]!=<span class="number">1</span>)<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下是求第k大mex,也就是第k个没出现的非负整数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">mex</span><span class="params">(T* p,T n,T k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> (p[<span class="number">1</span>]&lt;k?k:k<span class="number">-1</span>);</span><br><span class="line">T gg=<span class="number">0</span>;k--;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">gg=<span class="built_in">gcd</span>(gg,p[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">p[i]=(i<span class="number">-1</span>)*gg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]&lt;=k)k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="卡特兰数">卡特兰数</h2><p>$$Catalan_n=\frac{(2n)!}{n!(n+1)!}$$<br>$$f[n]=f[0]*f[n−1]+f[1]*f[n−2]+…+f[n−1]*f<a href="n%5Cge2">0</a>$$<br>$$1,1,2,5,14,42,132,429$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">__int128 <span class="title">Catalan</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">__int128 f[n+<span class="number">1</span>]&#123;&#125;;</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">f[i]+=f[j]*f[i-j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="随机数生成">随机数生成</h2><p>使用<code>MT19937</code>作为随机数引擎.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">std::mt19937 <span class="title">r32</span><span class="params">(chrono::system_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">rand32</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> l,<span class="type">unsigned</span> <span class="type">int</span> r)</span></span>&#123;<span class="comment">//[l,r]</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">r32</span>()%(r-l+<span class="number">1</span>)+l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::mt19937_64 <span class="title">r64</span><span class="params">(chrono::system_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">rand64</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> l,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> r)</span></span>&#123;<span class="comment">//[l,r]</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">r64</span>()%(r-l+<span class="number">1</span>)+l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="斐波那契数列-广义斐波那契数列">斐波那契数列(广义斐波那契数列)</h2><p>$$a_n=pa_{n-1}+qa_{n-2}$$<br>可以转换成矩阵乘法的形式:<br>$$\begin{bmatrix}a_{n-1}&amp;a_{n-2}\end{bmatrix}\begin{bmatrix}p&amp;1\q&amp;0\end{bmatrix}=\begin{bmatrix}a_n&amp;a_{n-1}\end{bmatrix}$$<br>所以有(假设 $a_0$ 是1)<br>$$\begin{bmatrix}1&amp;1\end{bmatrix}\begin{bmatrix}1&amp;1\1&amp;0\end{bmatrix}^n=\begin{bmatrix}a_n&amp;a_{n-1}\end{bmatrix}$$<br>函数只填第几项就是传统斐波那契数列了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> num,<span class="type">long</span> <span class="type">long</span> a1=<span class="number">1</span>,<span class="type">long</span> <span class="type">long</span> a2=<span class="number">1</span>,<span class="type">int</span> p=<span class="number">1</span>,<span class="type">int</span> q=<span class="number">1</span>,<span class="type">long</span> <span class="type">long</span> mod=<span class="number">1000000007</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//第几项，第一项第二项，系数1和2，取模 </span></span><br><span class="line"><span class="comment">//an=p*an-1+qan-2</span></span><br><span class="line"><span class="keyword">if</span>(num&lt;<span class="number">3</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(num==<span class="number">1</span>)<span class="keyword">return</span> a1;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a2;</span><br><span class="line">&#125;</span><br><span class="line">num-=<span class="number">3</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> tmp[<span class="number">4</span>]=&#123;p,<span class="number">1</span>,q,<span class="number">0</span>&#125;,res[<span class="number">4</span>]=&#123;p,<span class="number">1</span>,q,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(num&amp;<span class="number">1</span>)</span><br><span class="line"><span class="built_in">tie</span>(res[<span class="number">0</span>],res[<span class="number">1</span>],res[<span class="number">2</span>],res[<span class="number">3</span>])=<span class="built_in">make_tuple</span>((res[<span class="number">0</span>]*tmp[<span class="number">0</span>]+res[<span class="number">1</span>]*tmp[<span class="number">2</span>])%mod,(res[<span class="number">0</span>]*tmp[<span class="number">1</span>]+res[<span class="number">1</span>]*tmp[<span class="number">3</span>])%mod,(res[<span class="number">2</span>]*tmp[<span class="number">0</span>]+res[<span class="number">3</span>]*tmp[<span class="number">2</span>])%mod,(res[<span class="number">2</span>]*tmp[<span class="number">1</span>]+res[<span class="number">3</span>]*tmp[<span class="number">3</span>])%mod);</span><br><span class="line"><span class="built_in">tie</span>(tmp[<span class="number">0</span>],tmp[<span class="number">1</span>],tmp[<span class="number">2</span>],tmp[<span class="number">3</span>])=<span class="built_in">make_tuple</span>((tmp[<span class="number">0</span>]*tmp[<span class="number">0</span>]+tmp[<span class="number">1</span>]*tmp[<span class="number">2</span>])%mod,(tmp[<span class="number">0</span>]*tmp[<span class="number">1</span>]+tmp[<span class="number">1</span>]*tmp[<span class="number">3</span>])%mod,(tmp[<span class="number">0</span>]*tmp[<span class="number">2</span>]+tmp[<span class="number">2</span>]*tmp[<span class="number">3</span>])%mod,(tmp[<span class="number">1</span>]*tmp[<span class="number">2</span>]+tmp[<span class="number">3</span>]*tmp[<span class="number">3</span>])%mod);</span><br><span class="line">num&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (res[<span class="number">0</span>]*a2+res[<span class="number">2</span>]*a1)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="日期计算">日期计算</h2><p>基姆拉尔森公式,输入几几年几月几日返回一个数n表示周几.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CalculateWeekDay</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> m,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">1</span>||m==<span class="number">2</span>)m+=<span class="number">12</span>,y--;</span><br><span class="line"><span class="keyword">return</span> ((<span class="number">1LL</span>*d+(m&lt;&lt;<span class="number">1</span>)+<span class="number">3</span>*(m+<span class="number">1</span>)/<span class="number">5</span>+y+y/<span class="number">4</span>-y/<span class="number">100</span>+y/<span class="number">400</span>)%<span class="number">7</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="错排-单点计算">错排(单点计算)</h2><p>解决n种元素的排列满足每一个都不在原先自己的位置上.公式:<br>$$D(n)=n!\sum_{k=0}^n\frac{(-1)^k}{k!}$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">__int128 <span class="title">Derangement</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">__int128 rres=<span class="number">0</span>,tmp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;num;++i)&#123;</span><br><span class="line">rres=(rres+(num-i)&amp;<span class="number">1</span>?tmp:-tmp)%mod;</span><br><span class="line">tmp=tmp*(num+<span class="number">1</span>-i)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rres;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="错排-预处理递推">错排(预处理递推)</h2><p>$$D_n=(n-1)(D_{n-1}+D_{n-2})$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> D[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">D[<span class="number">0</span>]=<span class="number">1</span>;D[<span class="number">1</span>]=<span class="number">0</span>,D[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;++i)&#123;</span><br><span class="line">D[i]=(i<span class="number">-1</span>)*(D[i<span class="number">-1</span>]+D[i<span class="number">-2</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="康托展开">康托展开</h2><p>解决n个元素的一种排列按顺序排列的名次.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fenwick</span>&#123;</span><br><span class="line"><span class="type">int</span> dat[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aadd</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;pos&lt;=n;pos+=<span class="built_in">lowbit</span>(pos))&#123;</span><br><span class="line">dat[pos]+=val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qquery</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;pos;pos-=<span class="built_in">lowbit</span>(pos))&#123;</span><br><span class="line">res+=dat[pos];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> fact[<span class="number">1000010</span>];</span><br><span class="line">fenwick cantor;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ffact</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">fact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;++i)&#123;</span><br><span class="line">fact[i]=fact[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">CantorExpension</span><span class="params">(<span class="type">int</span>* tar,<span class="type">int</span> num)</span></span>&#123;<span class="comment">//[1,n]</span></span><br><span class="line"><span class="built_in">ffact</span>(num);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=num;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">k=cantor.<span class="built_in">qquery</span>(tar[i]);</span><br><span class="line">cantor.<span class="built_in">aadd</span>(tar[i],<span class="number">1</span>);</span><br><span class="line">res=(res+fact[num-i]*k)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (res+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="康托逆展开UUU">康托逆展开UUU</h2><p>RT,这是给一个排名求出第几个排列的过程,逆着来的.</p><h2 id="逆序对">逆序对</h2><p>公式是<br>$$\sum_{i=1}^{n}\sum_{j=i+1}^n[a_i&gt;a_j]$$<br>该函数同时还是归并排序板子(参数是dat序列ddat辅助空数组res接受结果lr排序范围,写1-n或者0-(n-1)都可以)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ssort</span><span class="params">(<span class="type">int</span>* dat,<span class="type">int</span>* ddat,<span class="type">long</span> <span class="type">long</span>&amp; res,<span class="type">int</span> l,<span class="type">int</span> mid,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> hi=l,ho=mid+<span class="number">1</span>,top=l;</span><br><span class="line"><span class="keyword">while</span>(hi&lt;=mid&amp;&amp;ho&lt;=r)&#123;</span><br><span class="line"><span class="keyword">if</span>(dat[hi]&gt;dat[ho])&#123;</span><br><span class="line">res+=mid-hi+<span class="number">1</span>;</span><br><span class="line">ddat[top++]=dat[ho++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ddat[top++]=dat[hi++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(hi&lt;=mid)&#123;</span><br><span class="line">ddat[top++]=dat[hi++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(ho&lt;=r)&#123;</span><br><span class="line">ddat[top++]=dat[ho++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">msort</span><span class="params">(<span class="type">int</span>* dat,<span class="type">int</span>* ddat,<span class="type">long</span> <span class="type">long</span>&amp; res,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">msort</span>(dat,ddat,res,l,mid);</span><br><span class="line"><span class="built_in">msort</span>(dat,ddat,res,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">ssort</span>(dat,ddat,res,l,mid,r);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> o=l;o&lt;=r;++o)&#123;</span><br><span class="line">dat[o]=ddat[o];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="欧拉函数-单点">欧拉函数(单点)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">phi</span><span class="params">(T n)</span></span>&#123;</span><br><span class="line">T res=n;</span><br><span class="line"><span class="keyword">for</span>(T i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>)res=res/i*(i<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(n%i==<span class="number">0</span>)n/=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (n!=<span class="number">1</span>)?(res/n*(n<span class="number">-1</span>)):(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="狄利克雷卷积-Dirichlet-Convolution">狄利克雷卷积(Dirichlet Convolution)</h2><p>给定数论函数f和积性函数g,在 $O(n\log\log n)$ 时间内求出 $h=\sum_{i=1}^nf*g$ .</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dirichlet</span><span class="params">(T1* f,T2* g,<span class="type">int</span>* prime,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=primetop;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=n/prime[i];j&gt;=<span class="number">1</span>;--j)&#123;</span><br><span class="line"><span class="type">int</span> t=prime[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> k=j*prime[i];k&lt;=n;k*=prime[i])&#123;</span><br><span class="line">f[k]=f[k]+f[j]*g[t];</span><br><span class="line">t*=prime[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//计算f*g的卷积，f是结果，要求g是积性函数 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dirichlet</span><span class="params">(T* f,<span class="type">int</span>* prime,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=primetop;++i)&#123;</span><br><span class="line"><span class="type">int</span> tmp=n/prime[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tmp;++j)&#123;</span><br><span class="line">f[j*prime[i]]=(f[j*prime[i]]+f[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//计算一个积性函数前缀和（f*1） </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dirichletde</span><span class="params">(T* f,<span class="type">int</span>* prime,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=primetop;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=n/prime[i];j;--j)&#123;</span><br><span class="line">f[j]=f[j]+f[j*prime[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//计算一个积性函数自身后缀和（f*1），也就是f(n)=sum(f(kn)),(kn&lt;n) </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="D函数-数字每位和">D函数(数字每位和)</h2><p>就是字面意思,把十进制每位数都加一起.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DFunction</span><span class="params">(T num)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(num)&#123;</span><br><span class="line">res+=num%<span class="number">10</span>;</span><br><span class="line">num/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="每次可以直线加上gcd-求最小极差">每次可以直线加上gcd,求最小极差</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addgcd</span><span class="params">(T* dat,<span class="type">int</span> n,T ggcd)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">dat[i]%=ggcd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(dat+<span class="number">1</span>,dat+<span class="number">1</span>+n);</span><br><span class="line">T res=dat[n]-dat[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">res=<span class="built_in">min</span>(res,ggcd+dat[i]-dat[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="绕线">绕线</h2><p>给一堆散点和一个区间上下界,每次可以选个点进行反转(绕线),求最小极差.由于无论在哪里想进区间必定只有一种绕法,状态确定,就可以直接遍历检查.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">mirrgcd</span><span class="params">(T* dat,<span class="type">int</span> n,T a,T b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a&gt;b)<span class="built_in">swap</span>(a,b);</span><br><span class="line">T mxx=<span class="number">0</span>,mnn;</span><br><span class="line"><span class="built_in">memset</span>(&amp;mnn,<span class="number">0x7f</span>,<span class="built_in">sizeof</span>(mnn));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">T tmp=((dat[i]/a)&amp;<span class="number">1</span>)?(dat[i]%b):(b-(dat[i]%b));</span><br><span class="line">mxx=<span class="built_in">max</span>(mxx,tmp);</span><br><span class="line">mnn=<span class="built_in">min</span>(mnn,tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mxx-mnn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="镜面对称-上翻下翻">镜面对称(上翻下翻)</h2><p>形象理解为一个点绕着一条线坐标变换的过程.公式是 $2a-i$ .</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">mmirror</span><span class="params">(T i,T a)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>*a-i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="阶乘取模-不算模数的取模">阶乘取模,不算模数的取模</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">facmod</span><span class="params">(<span class="type">int</span>* table,<span class="type">int</span> n,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=p)<span class="keyword">return</span> table[n];</span><br><span class="line"><span class="type">int</span> res=((n/p)&amp;<span class="number">1</span>^<span class="number">1</span>)?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">res=(res*<span class="built_in">facmod</span>(table,n/p,p))%p;</span><br><span class="line">res=(res*<span class="built_in">facmod</span>(table,n%p,p))%p;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="阶乘中有多少个因数">阶乘中有多少个因数</h2><p>$$v_p(n!)$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">faccnt</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">n/=p;</span><br><span class="line">res+=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RT,这里放一些奇奇怪怪的公式.&lt;/p&gt;
&lt;h2 id=&quot;常见质数&quot;&gt;常见质数&lt;/h2&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;</summary>
      
    
    
    
    <category term="Math" scheme="https://narafluorine.github.io/categories/Math/"/>
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/tags/OTH/"/>
    
  </entry>
  
</feed>
