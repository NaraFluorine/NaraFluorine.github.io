<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fluorine&#39;s blog</title>
  
  <subtitle>Hello here!</subtitle>
  <link href="https://narafluorine.github.io/atom.xml" rel="self"/>
  
  <link href="https://narafluorine.github.io/"/>
  <updated>2025-08-19T12:49:57.707Z</updated>
  <id>https://narafluorine.github.io/</id>
  
  <author>
    <name>Fluorine Wengers</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>XCPC命题组汇总</title>
    <link href="https://narafluorine.github.io/2025/12/16/30018_%E5%91%BD%E9%A2%98%E7%BB%84%E6%B1%87%E6%80%BB/"/>
    <id>https://narafluorine.github.io/2025/12/16/30018_%E5%91%BD%E9%A2%98%E7%BB%84%E6%B1%87%E6%80%BB/</id>
    <published>2025-12-16T02:16:10.000Z</published>
    <updated>2025-08-19T12:49:57.707Z</updated>
    
    <content type="html"><![CDATA[<p>似乎没人做哪场赛站是谁出的题的汇总…</p><h1>Nanani Fan Club</h1><ul><li><a href="https://codeforces.com/gym/105922">The 18th Jilin Provincial Collegiate Programming Contest</a></li></ul><h1>北邮</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;似乎没人做哪场赛站是谁出的题的汇总…&lt;/p&gt;
&lt;h1&gt;Nanani Fan Club&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://codeforces.com/gym/105922&quot;&gt;The 18th Jilin Provincial Collegiate</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>无线电B考试指南</title>
    <link href="https://narafluorine.github.io/2025/06/29/30020_%E6%97%A0%E7%BA%BF%E7%94%B5B/"/>
    <id>https://narafluorine.github.io/2025/06/29/30020_%E6%97%A0%E7%BA%BF%E7%94%B5B/</id>
    <published>2025-06-28T16:57:00.000Z</published>
    <updated>2025-06-29T13:20:58.277Z</updated>
    
    <content type="html"><![CDATA[<p>这里是中国业余无线电B证考试的指南.</p><p>Flu花了一天半的时间刷题备考看资料,最后以 <code>45/50</code> 的成绩过了B,故下面的内容不再维护.<br>(不过Flu心情好了可能改改排版什么的)</p><blockquote><p>速通是对的.<br>–Flu</p></blockquote><p>笔者建议大家考试前一两天然后就从零开始刷题,碰到不会的就看友台解析.<br>由于每个人的记忆点都可能不一样,下面的笔记很抽象,还是建议大家结合笔记看看自己怎么记忆.</p><p>先板刷真题,然后再解决完错题,然后再来一两场随机考试,就可以了.</p><p>没必要非常紧张,Flu的B证考试对于&quot;xxHz是什么波&quot;“xxHz是什么业务”&quot;XXX是什么发射类别&quot;这种纯记忆题全错了都能过,大家也一定没问题的,加油!</p><h2 id="ref">ref</h2><p>先看看有什么其他的可用资源…</p><p>微信有一个叫&quot;HAM模拟考试&quot;的小程序,没广告,巨好用.<br><a href="https://www.cqid.cn/">模拟考试网站(有谷歌系列的广告)</a><br><a href="https://www.jimmytian.com/archives/crac-aro-licence-b-review-guide.html">B证快速指北(笔者的这篇博客打算和这个博客是一个性质)</a><br><a href="https://github.com/bd8bzy/crac-exam-b">带解析的题库1</a><br><a href="https://www.bd8bzy.net/zh-CN/blog/crac-exam-b/">带解析的题库2</a><br><a href="https://ham-dev.c5r.app/crac-question-bank">带解析的题库3</a></p><h2 id="不得占用">不得占用</h2><p>435-438(38不能惹)<br>145.8-146(要死了)</p><h2 id="发射类别">发射类别</h2><p>CW A1A<br>单边带话 J3E<br>单边带RTTY F2B<br>PSK31 G2B<br>调频话 F3E</p><table><thead><tr><th>米数</th><th>频率</th><th>业务</th></tr></thead><tbody><tr><td>160</td><td>1800-2000</td><td>主要业务</td></tr><tr><td>80</td><td>3.5-3.9</td><td>主要业务</td></tr><tr><td>20</td><td>14-14.25</td><td>专用 14.25-14.35 主要业务</td></tr><tr><td>15</td><td>21-21.45</td><td>专用</td></tr><tr><td>10</td><td>28-29.7</td><td>专用</td></tr><tr><td>6</td><td></td><td>主要业务(2m6m选主要,0.7m选18的那个次要)</td></tr><tr><td>2</td><td></td><td>主要业务</td></tr><tr><td>0.7</td><td></td><td>次要业务</td></tr></tbody></table><table><thead><tr><th>频率</th><th>模式</th><th>频率</th></tr></thead><tbody><tr><td>7MHz</td><td>LSB</td><td>7.030-7.200</td></tr><tr><td>10MHz</td><td>USB</td><td>14.100-14.350</td></tr><tr><td>18MHz</td><td>USB</td><td>18.1105-18.168</td></tr><tr><td>21MHz</td><td>USB</td><td>选那个带除去的</td></tr><tr><td>24MHz</td><td>USB</td><td>24.9305-24.99</td></tr><tr><td>29MHz</td><td>USB</td><td>28.3-29.3(29.3-29.51不得占用)</td></tr><tr><td>29MHz</td><td>FM</td><td>29.51-29.7</td></tr></tbody></table><table><thead><tr><th>频率</th><th>名称</th><th>简写</th></tr></thead><tbody><tr><td>135.7 ~ 137.8K</td><td>低（长）</td><td>L</td></tr><tr><td>1.8 ~ 2M</td><td>中（中）</td><td>M</td></tr><tr><td>28M</td><td>高（短）</td><td>H</td></tr><tr><td>50M</td><td>甚（米）</td><td>V</td></tr><tr><td>2.4Ghz Wi-Fi</td><td>特高频（分米波）</td><td>U</td></tr><tr><td>5G</td><td>超（厘米）</td><td>S</td></tr><tr><td>10G</td><td>超（厘米）</td><td>S</td></tr><tr><td>241G</td><td>极（毫）</td><td>E</td></tr></tbody></table><h2 id="避开频率的神秘常数">避开频率的神秘常数</h2><p>18.068   <code>*.2,*.3,*.2</code></p><p>IARU信标台:避开 <code>18.110</code><br>避开10MHz(授时台)</p><h2 id="Calc">Calc</h2><p>$$\mathrm{1dBd=1+2.15dBi}$$<br>$$\mathrm{a,dBi-b,dBi=(a-b)dB}$$<br>信号功率:上面算出来差值dB之后,甲是乙多少倍:<br>$$10^{0.1\times c}$$<br>分贝计算:</p><p><strong>功率</strong> :增强100倍-&gt;20dB<br><strong>电压</strong> :增强100倍-&gt;40dB(功率增强10000倍)</p><p>信号通过多个增益电路:直接相加.</p><p>注意:dB是一个相对的概念,dBm和 $\mathrm{dB\mu}$ 都是绝对概念,不能直接转换.<br>$\mathrm{0dBm}$ 对应 $\mathrm{1mW}$<br>$\mathrm{0dB\mu}$ 对应 $\mathrm{1\mu W}$ ($\mathrm{0dB\mu}+30\mathrm{dB}=30\mathrm{dB}\mu$)<br>$$P_{\mathrm{dB}}=10\times\lg(P_2/P_1)$$<br>换成增益是 $8.15dBi$ 的天线怎么变:<br>$$8.15-2.15=6$$<br>故正好增一档.</p><p><strong>要注意看清是收发双方都改天线还是只有一个人改天线了.</strong></p><h2 id="Q简语">Q简语</h2><p>QR:questioning radio(要我…吗)<br>QS:questioning signal(信号…样)</p><p>QRO 要我增加发射功率吗?<br>QRP 要我降低发射功率吗? 请降低发射功率.</p><p>QRA 你台名称? 我台名称是…<br>QRH 我的频率稳定吗? 你的频率不稳定.<br>QRL 你忙吗?(有人使用频率吗?) 我很忙,请不要打扰.<br>QRU 你和我还有事吗? 我和你没事了.</p><p>QRV 你是否已经准备好?(receive接收)</p><p>QSO x 我能和x直接通信吗?</p><p>QSA 我的信号强度如何(强吗)? 你的信号很强.<br>QSB 信号弱(衰减)吗? 你的信号很弱.<br>QSD 我发报手法有毛病吗? 你的发报手法有毛病.<br>QSX 守听频率xx<br>QSY 改变频率到xx<br>QSK 从信号间隙接收<br>QSL 卡<br>QSP 能传信给(pass)xx吗? 我能传信给xx.</p><p>单词相关:<br>QRN:Natural天电<br>QRM:Manual人工<br>QRQ:Quick加快<br>QRS:Slow减速<br>QRT:sTop停止</p><table><thead><tr><th>其他缩写</th><th>意思</th></tr></thead><tbody><tr><td>ATT</td><td>衰减(不是衰落)</td></tr><tr><td>GA</td><td>继续,go on</td></tr><tr><td>KP</td><td>守听,keep(不是RCV)</td></tr><tr><td>HST</td><td>快速收发报(high speed telegraph)</td></tr><tr><td>AS</td><td>请稍等(a second)</td></tr><tr><td>C</td><td>碰到,见面(see)</td></tr><tr><td>CHEERIO</td><td>再会,祝贺</td></tr><tr><td>CL</td><td>关闭(呼叫)(close/call)</td></tr><tr><td>CLS</td><td>呼号call sign</td></tr><tr><td>CLG</td><td>呼叫(clling)</td></tr><tr><td>EL,ELE,ELS</td><td>单元(天线振子),element(和复数),注意不是UNIT</td></tr><tr><td>ES</td><td>和(ampersand, <code>&amp;</code> )</td></tr><tr><td>FB</td><td>很好的(fine business)</td></tr><tr><td>FR,FER</td><td>为了,对于(for)</td></tr><tr><td>G[]</td><td>good morning早上好啥的一堆</td></tr><tr><td>GLD</td><td>高兴(glad)</td></tr><tr><td>BJT</td><td>北京时间</td></tr><tr><td>BURO</td><td>QSL卡片局</td></tr><tr><td>HR</td><td>这里,听到(here hear)</td></tr><tr><td>MNY,MNI</td><td>很多(many)</td></tr><tr><td>NW</td><td>现在(now)</td></tr><tr><td>P O BOX</td><td>邮政信箱</td></tr><tr><td>RPRT</td><td>报告 report(不是PRT)</td></tr><tr><td>SK</td><td>结束通信(stop keep)</td></tr><tr><td>STN</td><td>电台(station)</td></tr><tr><td>TNX,TKS</td><td>谢谢</td></tr><tr><td>TU</td><td>谢谢你(U you)</td></tr><tr><td>WKD</td><td>工作过(worked)</td></tr><tr><td>XYL</td><td>妻子,已婚女子(ex-young lady前年轻女子)</td></tr><tr><td>YL</td><td>年轻女子</td></tr><tr><td>88</td><td>异性操作员的美好祝愿(love and kiss)</td></tr><tr><td>LW</td><td>长线天线(long wire)</td></tr><tr><td>LP</td><td>对数周期天线(log period)</td></tr><tr><td>ppm</td><td>百万分比(part per million),描述频率的相对稳定程度</td></tr></tbody></table><h2 id="神秘不变量">神秘不变量</h2><p>信号幅度不变: 移频键控FSK 频率调制FM 相位调制PM 移相键控调制PSK<br>信号周期不变: 相位调制PM<br>载频分量幅度不变: 幅度调制AM<br>频带宽度可能大于原有值: 频率调制FM(理论频带无穷宽)</p><h2 id="专有名词">专有名词</h2><p>ALC:auto level control(发信自动电平控制)<br>AT:auto antenna(自动天调)<br>ATT:attenuator(衰减器)<br>AGC:auto gain control(自动增益控制)<br>PRE: <strong>前置</strong> 放大器<br>PROC:语音压缩(compress)<br>RIT:(receive)接收增量调谐(tuning)<br>XIT:发射增量调谐</p><p>RTTY:频移电报技术</p><p>NB,SQL:选最长的</p><p>CTCSS:选数值最小的</p><p>VFO:可变频率振荡器(variable-frequency oscillator)<br>XTAL:石英晶体元件quartz crystal</p><h1>知识</h1><ol><li><p>频偏:声音幅度决定信号的一个东西,更大声音说话会增加频偏,和机子,功率无关.</p></li><li><p>10m(28-29.7)在白天更适合通联,因为白天太阳活动更频繁,电离的情况更好.</p></li><li><p>协调无线电管理的是 <code>国际电信联盟</code> .</p></li><li><p>划定的频率怎么用?实际可以工作的发信频率需要[d+信号下边带的频率宽度,u-信号上边带的频率宽度]</p></li><li><p>减幅波辐射:电打火(最早的电码就是用火花放电控制时间构成电码,这是一种波长很短的减幅波,振幅衰减很快,干扰极大)</p></li><li><p>无线电波:3000G赫兹以下的在空间传播的电磁波</p></li><li><p>时区:24个,本初子午线经过0区,西比东晚</p></li><li><p>ITU分区只有3个区,中国在3区,南北美洲为二区</p></li><li><p>SASE:写好收信人地址的信封(self addressed and stamped envelope)</p></li><li><p>单边带语音压缩:压强升弱</p></li><li><p>不知道选什么就选最乖巧懂事的</p></li><li><p>频率失真:各频率分量比例发生了改变<br>非线性失真:产生了新的频率分量<br>相位失真:相位</p></li><li><p>有源元器件:半导体三极管(需要外部能量才能工作的器件,主要是信号放大,变换,整流)(二极管,晶体管,三极管,集成电路)<br>耐压指标:电容(会被击穿)<br>耗散功率:电阻(散热功率)<br>提供旁路的元件:电容</p></li><li><p>(信号判断)<br>SSB听到两种音调交替:FSK<br>SSB听到音调不变但是似乎不断颤动的信号:PSK<br>SSB听到&quot;嘟嘟&quot;声:SSTV或FAX</p></li><li><p>损耗:低频损耗小</p></li><li><p>高频电流有趋肤效应</p></li><li><p>绝缘物体:介质损耗</p></li><li><p>BW:选3dB的那个</p></li><li><p>截止频率:选带dB的那个<br>3dB带宽:选0dB变化到-3dB的那个</p></li><li><p>滤波器:阶数越高抑制效果越好</p></li><li><p>频率稳定度:RC &lt; LC &lt; 石英管</p></li><li><p>振荡器必备元素:放大器,正反馈电路</p></li><li><p>选频率:AM应该给最大的频率(6k)<br>PSK31(低速率)只需要很短的带宽,给最小的就可以.</p></li><li><p>三阶互调:两个频率加起来是3.</p></li><li><p>差拍:两者之差</p></li><li><p>频谱仪:<br>CW:闪动的垂直线<br>RTTY:两条闪动垂直线<br>SSB:随语音出现和变化的非对称垂直线<br>AM:一条固定垂直线,左右伴随别的东西</p></li><li><p>用 <strong>频谱瀑布图</strong> 描述LC振荡器温度漂移程度.</p></li><li><p>放大器ABCD:放大器件的工作点所处范围<br>A:始终工作在线性区<br>B:半个周期线性区,半个周期截止区<br>C:xx<br>D:半个周期截止区半个周期饱和区</p></li><li><p>两个并联功率管:双倍功率输出<br>两个串联功率管:推挽放大电路</p></li><li><p>信号实际占用带宽:选平齐而且最后长的那个</p></li><li><p>异步(不属于同步):RTTY</p></li><li><p>RTTY常见设定:选带 <code>N</code> 的那个</p></li><li><p>接收机抗拒:选 <em>前端带宽</em><br>如果有两倍就选 <em>镜像抑制比</em></p></li><li><p>制约现代接收机灵敏度的因素:机内噪声</p></li><li><p>中继台上下行用一个天线要加 <strong>双工器</strong> .</p></li><li><p>我国第一颗业余卫星:2009年</p></li><li><p>计算天线发射仰角:简单几何方法计算</p></li><li><p>天调:选开头是补偿的…</p></li><li><p>HF外界噪声较(UHF)高</p></li><li><p>镜频干扰:第一中频:A,接收:B,可能:A+2B or A-2B</p></li><li><p>中频滤波器:防止邻近频率干扰<br>预选滤波器:抑制镜频</p></li><li><p>三阶互调: <code>()/2</code></p></li><li><p>信号速率:VHF和HF都要选最慢的.</p></li><li><p>ITA2码:选没见过的那个码</p></li><li><p>水平偶极天线振子长度:1/2波长的奇数倍(最大增益)<br>1/2波长的整数倍(谐振)</p></li><li><p>巴伦:平衡与不平衡的英文字头组合</p></li><li><p>对于中国HAM来说稀有又困难的是: <code>KP5A</code></p></li><li><p>3V,啥啥的:选T开头的选项</p></li><li><p>电离层影响由低到高: <code>D E F1 F2</code> ,D衰减电波,EF能反射电波</p></li><li><p>太阳黑子的活动周期是11.2年.</p></li><li><p>高次谐波:二级整流或三极管放大器</p></li><li><p>OP附近噪音很响:调整话筒增益</p></li><li><p>大写&quot;四分之一波长&quot;选奇数倍</p></li><li><p>北京通联纽约:东方和西方联通</p></li><li><p>由大到小:FM AM SSB</p></li><li><p>对称半波振子:波长是1/4,俩凑一起是1/2.</p></li><li><p>静寂区:HF和天波地波传播不到的区域</p></li><li><p>CQ分区和埃及相同的: <code>5A</code></p></li><li><p>车上安装的移动电台的高频啸叫声的来源是: <code>发电机</code> .</p></li><li><p>听起来音调偏高偏低的SSB变正常:RIT(receiver incremental tuning)</p></li><li><p>电位器:阻值可按某种变化规律调节的电阻元件.(滑动变阻器换了个名字)</p></li><li><p>镍氢电池:1.2V<br>晶体管:能当开关,能当放大器用</p></li><li><p>房子题:1234按顺序来.</p></li><li><p>相控阵:48.8<br>偶极天线:71.3</p></li><li><p>元件识别</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  |--         |--          |--</span><br><span class="line">--|         --|            |</span><br><span class="line">  |&lt;- PNP     |-&gt; NPN    -&gt;|-- 结型场效应半导体三极管</span><br></pre></td></tr></table></figure><ol start="66"><li><p>CTCSS范围:非常小,选最小的.</p></li><li><p>ATV通信为什么要至少1.2GHz?</p><blockquote><p>因为占用带宽太高,较低业余频段不足以容纳</p></blockquote></li><li><p>交流电<br>电感:电流与电压成正比,与电感成反比.<br>电容:与电压和电容量都成正比.</p></li><li><p>两个测数的题:出现理想选0,出现巴伦选无穷大</p></li><li><p>不慎被大电压电击:选变压器</p></li><li><p>经过全波整流电路:认为放热一样</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里是中国业余无线电B证考试的指南.&lt;/p&gt;
&lt;p&gt;Flu花了一天半的时间刷题备考看资料,最后以 &lt;code&gt;45/50&lt;/code&gt; 的成绩过了B,故下面的内容不再维护.&lt;br&gt;
(不过Flu心情好了可能改改排版什么的)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;速通是对的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统学习笔记</title>
    <link href="https://narafluorine.github.io/2025/06/19/00013_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://narafluorine.github.io/2025/06/19/00013_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-06-18T23:07:07.000Z</published>
    <updated>2025-06-18T23:07:51.285Z</updated>
    
    <content type="html"><![CDATA[<h1>大佬博客</h1><p><a href="https://blog.chencs.online/posts/os-note">1</a> <a href="https://www.cnblogs.com/gonghr/p/16549543.html">2</a></p><h1>必考祖传计算题</h1><p>四个必考计算题:银行家 进程调度 电梯算法 页表<br>(似乎前三个大题都是送分的)<br>计算题据说每年都一样,只是换换数据.</p><h2 id="银行家算法">银行家算法</h2><p><strong>need矩阵</strong>:实际上就是进程右边再开一行,标注还需要多少资源,资源用元组()括号保住就行.</p><p>检查当前进程中是否存在资源足够能够完全供给的进程,如果有就供满然后把资源全抽出来,否则报告进程是不安全的.</p><ol><li>判断当前进程是否安全,如安全给出安全序列,否则报告是不安全的.</li></ol><p>方法:列表.(work=available是可用资源,need是还需要的资源,allocation是已分配的资源)</p><table><thead><tr><th>进程</th><th>work</th><th>need</th><th>allocation</th><th>work+allocation</th><th>finish</th></tr></thead><tbody><tr><td>P1</td><td>1 2 3</td><td>4 5 6</td><td>7 8 9</td><td>10 11 12</td><td>√</td></tr></tbody></table><ol start="2"><li>假如进程Px请求一个request(xxx),能不能进行?为什么?</li></ol><p>request的含义是,当前进程需要的资源总和都不变,只是这个进程想提前拿到一部分资源,所以要检查(1.req&lt;=avail不能不够,2.req&lt;=need不能多拿)然后变成一个新的进程,再跑一遍银行家看能不能找到.</p><ol start="3"><li>银行家算法因为提前计算资源分配情况,如果不够就不会分配,所以不会进入死锁状态,只会进入不安全状态,也就是所有进程会进入阻塞状态.</li></ol><h2 id="页表">页表</h2><p>虚拟地址=逻辑地址.</p><h3 id="一级页表">一级页表</h3><p>记录xx进程去内存哪个位置了(进程和内存按照相同大小分块)逻辑地址</p><table><thead><tr><th>页号</th><th>偏移量</th></tr></thead><tbody><tr><td>有多少个页表项</td><td>块大小(如4KB对应2^12B所以偏移量填12)</td></tr></tbody></table><h3 id="二级页表">二级页表</h3><blockquote><p>二级页表有多少个?<br>对应的一级页表占用的存储空间/一个二级页表的空间.</p></blockquote><h2 id="段表">段表</h2><p>分成多少段,每段怎么怎么着,造成什么中断?</p><blockquote><p>越界中断(数组在段中越界了)<br>缺段中断(这个段就不在主存中)</p></blockquote><h2 id="页面置换算法">页面置换算法</h2><p>三种:最佳置换算法(OPT):淘汰后续用不使用/最长时间内不再被访问的(也就是向后看淘汰最后一个出现的页面,例如内存123访问4,4后续还要访问123,此时3是最后出现的会被挤掉)<br>先进先出页面置换算法(FIFO):挤掉最早进入内存的页面(看连续块的长度挤掉最长的)<br>最近最久未使用闲置算法(LRU):向前看淘汰最后一个出现的页面</p><p>考点:缺页次数(内存中没有该页需调入内存),也就是内存更改次数<br>页面置换次数(缺页但内存满了需要页面调换)<br>缺页率=缺页数/总进程数<br>命中率=1-缺页率</p><h2 id="多级索引">多级索引</h2><p>记得先算一个数据块能放多少个索引地址.</p><p>直接索引:地址就是数据.<br>一级索引:地址指向一个数据块,数据块里面的内容全是地址,这么多地址指向数据.<br>二级索引:地址指向一个数据块,数据块里面全是一级索引…<br>三级索引:…</p><h2 id="周期性实时任务-Grantt图-处理机调度">周期性实时任务 Grantt图 处理机调度</h2><p>单道:所有设备都紧着当前进程供给(也就是说程序A即使正在用CPU,程序B也不能用IO设备)<br>多道:设备是分开供给的(程序A正在使用CPU的时候其他程序不可以用CPU但是可以用IO设备)</p><p>Grantt图:直接画就行,自己看,虚线表示正在等待占用.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">程序</span><br><span class="line"> |CPU</span><br><span class="line">A|---------</span><br><span class="line"> |设备甲    CPU</span><br><span class="line">B|----     ---</span><br><span class="line"> +------------&gt;t</span><br><span class="line">     5   10</span><br></pre></td></tr></table></figure><p>最早截止期优先算法</p><h2 id="实时调度算法">实时调度算法</h2><p>先来先服务(FCFS)</p><p>短作业优先(SJF)<br>非抢占:动态取当前最小进程一口气执行完.<br>抢占:基于最短执行时间:假设D执行5s,E在第3s插入,因为D是5小于E,所以这个时候D会让位给E,E完了再D.<br>基于最短剩余时间:还是上述条件,此时因为D还剩2s是小于E的3s的,所以D会被执行完,然后才轮到E.</p><p>优先权调度算法:直接按照给定的顺序模拟即可,优先级数字越大越优先.</p><p>动态优先权算法:优先权=1+等待时间/需要时间<br>每轮算一下,取最大的进程执行到底,然后再算,再取…</p><p>周转时间=完成时间-到达时间<br>带权周转时间=周转时间/服务时间</p><h2 id="PV大题">PV大题</h2><p>信号量大题.一定要写清注释!!!</p><p>同步:等待<br>互斥:独立使用某种资源<br>分析是否需要while(1)<br>定义信号量 <code>semaphore</code> ,同步的信号量初始是0,互斥的信号量初始是1.</p><p>死锁:将同步P放在互斥P前面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">semaphore aa;</span><br><span class="line"></span><br><span class="line"><span class="built_in">A</span>()&#123;</span><br><span class="line"><span class="function">xxx</span></span><br><span class="line"><span class="function"><span class="title">P</span><span class="params">(B)</span></span>;<span class="comment">//等待B</span></span><br><span class="line"><span class="built_in">V</span>(B);<span class="comment">//取消等待</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如有ABCDE五类操作,C要在AB后执行,E要在CD后执行,尝试写代码.</p><p>分析关系得到AB运行完要解除C的等待(V©),CD运行完要解除E的等待,而且B在运行前要检查AB的等待(P(A),P(B)),然后剩下的都无所谓了,注意检查死锁</p><h2 id="磁盘调度算法">磁盘调度算法</h2><p>非常蠢的四种方法.<br>平均查找长度=(sum差的绝对值)/多少个请求</p><ol><li>先来先服务(FCFS)</li><li>最短寻找时间算法(SSTF)(贪心的每次找最近的)</li><li>电梯算法(C-SCAN扫描算法)(先 <strong>人为规定</strong> 向上走,然后再向下,沿路接受访问)</li><li>循环扫描算法(SCAN,一直上升,到需求的顶了之后突然变成0,然后再接低层的)</li></ol><h2 id="页式虚拟存储">页式虚拟存储</h2><p>在一个采用页式虚拟存储管理的系统中,有一用户进程,它依次要访问的逻辑地址序列是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">07FEh 093Ah 0F42h</span><br><span class="line">1357h 045ch 0BC0h</span><br><span class="line">15AFh 05D2h 0A4Bh </span><br><span class="line">OCDEh 11F2h 16ABh</span><br></pre></td></tr></table></figure><p>现分配给该进程的主存空间共4K字节,每页的大小为1K字节.<br>(1)按FIFO调度算法将产生缺页中断次数,淘汰的页号,缺页中断率.<br>(2)按LRU调度算法将产生缺页中断次数,淘汰的页号,缺页中断率.</p><p>原始内存是很大的,所以对页大小直接除,在这个题也就是说,这个16位有10位是原始数据,剩下的高6位会被分页,所以对每个数据取高位6作为页面编号,得到一个数字串,对其跑算法即可.</p><h2 id="对一个分页逻辑转内存地址">对一个分页逻辑转内存地址</h2><p>$$E=b\times l+w$$<br>E是实际地址<br>b是内存块号<br>l是一页大小<br>w是页内偏移(hex%l)<br>页号=(hex/l)</p><h1>ADD</h1><p>Fragmentation(碎⽚化)：指内存或磁盘中，因空间分配与回收⽽产⽣了许多不连续的⼩空间，这些空间太⼩⽽⽆法被有效<br>利⽤，造成了浪费。</p><p>RAID：独⽴磁盘冗余阵列 (Redundant Array of Independent Disks) 。它是⼀种将多个物理硬盘组合成⼀个逻辑单元的技<br>术，⽬的在于提升存储性能、数据冗余或两者兼备。</p><p>first fit(⾸次适应算法)：⼀种内存分配算法。当进程请求内存时，系统从头开始查找，并将进程放⼊第⼀个找到的、⼤⼩<br>⾜够的空闲内存块中。</p><p>地址映射：指将程序使⽤的逻辑地址（或虚拟地址）转换为内存条上的物理地址的过程。这个转换是实现虚拟内存和内<br>存保护的基础。（也就是重定位）</p><p>PCB (进程控制块)：它是操作系统⽤于描述和管理⼀个进程的核⼼数据结构，记录了进程ID、状态、资源占⽤情况等全部<br>信息，相当于进程的“⾝份证”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;大佬博客&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.chencs.online/posts/os-note&quot;&gt;1&lt;/a&gt; &lt;a href=&quot;https://www.cnblogs.com/gonghr/p/16549543.html&quot;&gt;2&lt;/a&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="DEAD" scheme="https://narafluorine.github.io/categories/DEAD/"/>
    
    
    <category term="Hello" scheme="https://narafluorine.github.io/tags/Hello/"/>
    
  </entry>
  
  <entry>
    <title>概率论学习笔记</title>
    <link href="https://narafluorine.github.io/2025/05/16/00012_%E6%A6%82%E7%8E%87%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://narafluorine.github.io/2025/05/16/00012_%E6%A6%82%E7%8E%87%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-05-16T00:00:00.000Z</published>
    <updated>2025-06-24T02:47:35.958Z</updated>
    
    <content type="html"><![CDATA[<ol><li>ABC两两独立和ABC相互独立的区别</li></ol><p>两两独立: $P(AB)=P(A)P(B)$ ,…(任意两个都满足这样的式子)<br>相互独立(额外条件): $P(ABC)=P(A)P(B)P( C )$</p><ol start="2"><li><p>$P(A\overline B)=P(A)-P(AB)$ 理解:A发生B不发生</p></li><li><p>相容和独立的区别</p></li></ol><p>不相容(互斥): $P(AB)=0$<br>独立: $P(AB)=P(A)P(B)$</p><ol start="4"><li><p>$P(A|B)=\frac{P(AB)}{P(B)}$</p></li><li><p>$P(\overline A~\overline B)=P(\overline{A+B})=1-P(A+B)$</p></li><li><p>$P(A|B)+P(\overline A|B)=1$ 隐藏条件</p></li><li><p>指数分布<br>$$f(x)=\begin{cases}\lambda e^{-\lambda x}&amp;x&gt;0\\0&amp;x\le0\end{cases}$$<br>泊松分布<br>$$P(\lambda):f(x)=\frac{\lambda^xe^{-\lambda}}{x!}$$</p></li><li><p>正态分布标准化:<br>$$Y=\frac{X-\mu}{\sigma}\sim N(0,1)$$<br>$$F(X)=\Phi\left(\frac{X-\mu}{\sigma}\right)$$</p></li><li><p>$f(x),F(x)$ ,对 $-X$ 有<br>$$F_{-X}(x)=P(-X&lt;x)=P(X&gt;-x)=1-F(-x)$$<br>对 $F(x)$ 求导得<br>$$f_{-X}(x)=f(-x)$$</p></li><li><p>例题:求概率密度<br>$$f(x)=\begin{cases}\frac12&amp;-1&lt;x&lt;0\\\frac14&amp;0\le x&lt;2\\0&amp;others\end{cases}$$<br>$$Y=X^2$$<br>这么写过程:当 $y&lt;0$ 时, $F_Y(y)=P{Y\le y}=P{X^2\le y}=0$<br>…<br>然后概率密度通过求导.</p></li><li><p>独立的两个随机变量 $XY$ 满足 $f(x,y)=f_X(x)f_Y(y)$ .<br>且 $f_{XY}(x,y)=\frac{\partial^2F(x,y)}{\partial x\partial y}$ .</p></li><li><p>多个正态分布叠加: $Z=aX+BY+c$ 有<br>$$\mu_Z=a\mu_X+b\mu_Y+c$$<br>$$\sigma_Z^2=a\sigma_X^2+b\sigma_Y^2$$<br>$$N(\mu,\sigma^2):f(x)=\frac1{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}$$</p></li><li><p>二维正态分布: $N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$<br>$$\large f(x,y)=\frac1{2\pi\sigma_1\sigma_2\sqrt{1-\rho^2}}e^{-\frac{1}{2(1-\rho^2)}\left[\frac{(x-\mu_1)^2}{\sigma_1^2}+\frac{(y-\mu_2)^2}{\sigma_2^2}-2\rho\frac{(x-\mu_1)(y-\mu_2)}{\sigma_1\sigma_2}\right]}$$<br>当 $\rho$ 为 $0$ 时,两个变量相互独立,也就能直接拆成 $X\sim N(\mu_1,\sigma_2^2)$ 和 $Y\sim N(\mu_,\sigma_2^2)$ ,其余时候等高线是椭圆,不过也是可以直接拆,但是在算方差记得加上cov.</p></li><li><p>二维条件概率:<br>$$f_{X|Y}(x|y)=\frac{f(x,y)}{f_Y(y)}$$<br>$$f_Y(y)=\int_{-\infty}^{+\infty}f(x,y)\mathrm dx$$</p></li><li><p>两个变量独立,然后 $Z=X+Y$ 怎么算?<br>$$F_{X+Y}(z)=P{X+Y\le Z}=\int_0^z\mathrm dx\int_0^{z-x}f(x)f(y)\mathrm dy$$</p></li><li><p>高斯积分<br>$$\int_{-\infty}^{+\infty}e^{-ay^2}\mathrm dy=\sqrt{\frac{\pi}{a}}$$</p></li><li><p>最大值,最小值公式:<br>因为max是两个都要小于z,故直接对z积分即可.<br>$$Z=\max(X,Y):F_Z(z)=F_X(z)F_Y(z)$$<br>最小值是反过来减去最大值:<br>$$Z=\min(X,Y):F_Z(z)=1-[1-F_X(z)][1-F_Y(z)]$$</p></li><li><p>数学期望(假设此积分绝对收敛,数学期望可以不存在)<br>$$E(x)=\int_{-\infty}^{+\infty}xf(x)\mathrm dx$$<br>方差<br>$$D(X)=E(X^2)-[E(X)]^2$$<br>$$D(X)=\int_{-\infty}^{+\infty}(x-E(x))f(x)\mathrm dx$$<br>协方差(独立的随机变量协方差为0)<br>$$\mathrm{Cov}(X,Y)=E(XY)-E(X)E(Y)$$<br>相关系数(相互独立为0, $\rho\in[-1,1]$ )<br>$$\rho_{XY}=\frac{\mathrm{Cov}(X,Y)}{\sqrt{D(X)}\sqrt{D(Y)}}$$</p></li><li><p>期望性质<br>$$E(aX+bY+c)=aE(X)+bE(Y)+c$$<br>若变量独立,有<br>$$E(XY)=E(X)E(Y)$$<br><strong>注意</strong> :上述性质只能推出来XY不相关,也就是说cov=0,方差可以直接相加 $D(X+Y)=D(X)+D(Y)$</p></li><li><p>期望实战<br>$$E(\max(X,Y))=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}\max(x,y)f(x,y)\mathrm dx\mathrm dy$$<br>$$E(XY)=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}xyf(x,y)\mathrm dx\mathrm dy$$</p></li><li><p>方差性质<br>$$D(CX)=C^2D(X)$$<br>若XY相互独立,则<br>$$D(X\pm Y)=D(X)\pm D(Y)$$<br>若X是常数,方差为0,反过来不成立.</p></li><li><p>协方差性质<br>$$\mathrm{Cov}(X,c)=0$$<br>$$\mathrm{Cov}(X,X)=D(X)$$<br>$$D(X\pm Y)=D(X)+D(Y)\pm2\mathrm{Cov}(X,Y)$$<br>$$\mathrm{Cov}(X,Y)=\mathrm{Cov}(Y,X)$$<br>$$\mathrm{Cov}(aX,bY)=ab\mathrm{Cov}(X,Y)$$<br>$$\mathrm{Cov}(X+Z,Y)=\mathrm{Cov}(X,Y)+\mathrm{Cov}(Z,Y)$$</p></li><li><p>几种分布的期望和方差等</p></li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">E</th><th style="text-align:center">D</th><th style="text-align:center">sgn</th><th style="text-align:center">f</th><th style="text-align:center">F</th></tr></thead><tbody><tr><td style="text-align:center">(0-1)分布</td><td style="text-align:center">$p$</td><td style="text-align:center">$p(1-p)$</td><td style="text-align:center"></td><td style="text-align:center">$$f(x)=\begin{cases}\frac{1}{b-a}&amp;a&lt;x&lt;b\\0&amp;others\end{cases}$$</td><td style="text-align:center">$$F(x)=\begin{cases}0&amp;x\le a\\\frac{x-a}{b-a}&amp;a&lt;x&lt;b\\1&amp;x\ge b\end{cases}$$</td></tr><tr><td style="text-align:center">指数分布</td><td style="text-align:center">$\frac1\lambda$</td><td style="text-align:center">$\frac1{\lambda^2}$</td><td style="text-align:center">$X\sim E(\lambda)$</td><td style="text-align:center">$$f(x)=\begin{cases}\lambda e^{-\lambda x}&amp;x&gt;0\\0&amp;others\end{cases}$$</td><td style="text-align:center">$$F(x)=\begin{cases}1-e^{-\lambda x}&amp;x&gt;0\\0&amp;x\le 0\end{cases}$$</td></tr><tr><td style="text-align:center">二项分布</td><td style="text-align:center">$np$</td><td style="text-align:center">$np(1-p)$</td><td style="text-align:center">$X\sim B(n,p)$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">几何分布</td><td style="text-align:center">$\frac1p$</td><td style="text-align:center">$\frac{1-p}{p^2}$</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">泊松分布</td><td style="text-align:center">$\lambda$</td><td style="text-align:center">$\lambda$</td><td style="text-align:center">$X\sim\pi(\lambda),X\sim P(\lambda)$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">均匀分布</td><td style="text-align:center">$\frac{a+b}2$</td><td style="text-align:center">$\frac{(a-b)^2}{12}$</td><td style="text-align:center">$X\sim U(a,b)$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">正态分布</td><td style="text-align:center">$\mu$</td><td style="text-align:center">$\sigma^2$</td><td style="text-align:center">$X\sim N(\mu,\sigma^2)$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><ol start="25"><li><p>标准正态分布标志是 $\varphi=\frac1{\sqrt{2\pi}}e^{-\frac{x^2}2}$ ,其分布函数为 $\Phi$ ,注意 $\Phi$ 是积不出来的.</p></li><li><p>由 $Z=g(x,y)$ 可以解出 $y=h(x,z)$ ,代入有<br>$$f_Z(z)=\int_{-\infty}^{+\infty}f(x,h(x,z))\left|\frac{\partial h}{\partial z}\right|\mathrm dx$$</p></li></ol><p>min与max的分布:<br>$$M=\max(X,Y),N=\min(X,Y)$$<br>$$F_M(z)=F_X(z)F_Y(z)$$<br>$$F_N(z)=1-(1-F_X(z))(1-F_Y(z))$$</p><ol start="27"><li>确定常数c满足xx是参数为xx的无偏估计量.<br>得到式子 $CE(xxx)=xx$ 然后求出常数.</li></ol><h2 id="切比雪夫不等式">切比雪夫不等式</h2><p>设期望是 $E(X)=\mu$ ,方差 $D(X)=\sigma^2$ ,然后<br>$$P{|X-\mu|\ge\varepsilon}\le\frac{\sigma^2}{\varepsilon^2}$$</p><h2 id="大数定律">大数定律</h2><h2 id="中心极限定理">中心极限定理</h2><h3 id="独立同分布">独立同分布</h3><p>设单个X期望是 $\mu$ ,方差是 $\sigma^2$ ,则<br>$$E(\sum_{i=1}^n X_i)=n\mu,D(\sum_{i=1}^n X_i)=n\sigma^2$$<br>$$Y_n=\frac{\sum_{i=1}^nX_k-n\mu}{\sqrt n\sigma}\sim N(0,1)$$</p><h3 id="平均值">平均值</h3><p>假设 $X\sim N(\mu,\sigma)$ ,则 $\overline X\sim N(\mu,\frac\sigma n)$ .</p><h3 id="更广泛的情况">更广泛的情况</h3><p>其实就是期望和方差用统计值换了一下…<br>$$Y_n=\frac{\sum_{i=1}^nX_k-\sum_{i=1}^nE( X_i)}{\sqrt{\sum_{i=1}^nD(X_i)}}\sim N(0,1)$$</p><h2 id="统计量和分布">统计量和分布</h2><p>不含任何未知参数的是统计量,如 $\sum_{i=1}^nX_i$ 是, $\sum_{i=1}^n\frac{X_i-\mu}{\sigma}$ 不是.</p><h3 id="样本方差公式">样本方差公式</h3><p>反正由于某种原因,样本方差是 $\frac1{n-1}$ 而不是 $\frac1n$ 这一点一定要牢记!!!<br>还有的性质是 $E(S^2)=\sigma^2$</p><h2 id="三大分布">三大分布</h2><h3 id="chi-2-分布">$\chi^2$ 分布</h3><p>若干样本 $X_i\sim N(0,1)$ ,记 $X_1^2+…+X_n^2\sim\chi^2(n)$ 服从卡方分布.(必须是标准正态分布,n被称为自由度).<br>卡方分布有 $E(\chi^2)=n,D(\chi^2)=2n$</p><p>推论1:设 $X_i\sim N(\mu,\sigma^2)$ ,有服从卡方分布<br>$$\chi^2=\frac1{\sigma^2}\sum_{i=1}^n(X_i-\mu)^2=\sum_{i=1}^n\left(\frac{X_i-\mu}{\sigma}\right)\sim\chi^2(n)$$</p><p>推论2:<br>$$\frac{(n-1)S^2}{\sigma^2}\sim\chi^2(n-1)$$</p><p>两个独立的卡方分布加一起: $\chi^2(a+b)$</p><h3 id="t分布">t分布</h3><p>设 $X\sim N(0,1),Y\sim\chi^2(n)$ ,且XY独立,则随机变量服从t分布,有下面式子<br>$$t=\frac{X}{\sqrt{Y/n}}$$<br>记作 $t\sim t(n)$</p><p>推论: $t=\frac{\overline X-\mu}{S}\sqrt n\sim t(n-1)$</p><h3 id="F分布">F分布</h3><p>设 $X\sim \chi^2(m),Y\sim\chi^2(n)$ ,且XY独立,则随机变量服从F分布,有下面式子<br>$$F=\frac{X/m}{Y/n}$$<br>记作 $F\sim F(m,n)$ ,第一自由度m,第二自由度n.</p><h2 id="正态总体的抽样分布">正态总体的抽样分布</h2><p>总体方差 $\sigma$ ,均值 $\mu$ ,样本方差 $s^2$ ,均值 $\overline X$ .</p><ol><li>$$\frac{\overline X-\mu}{\sigma/\sqrt n}\sim N(0,1)$$</li><li>$$\frac{\overline X-\mu}{s/\sqrt n}\sim t(n-1)$$</li><li>$$\frac{s^2(n-1)}{\sigma^2}=\sum_{i=1}^n(\frac{X_i-\overline X}{\sigma})^2\sim\chi^2(n-1)$$</li><li>$$F=\frac{\sigma_1^2/S_1^2}{\sigma_2^2/S_2^2}=F(n_1-1,n_2-1)$$</li></ol><p>假设总体符合正态分布,随机抽几个样本符合正态分布: $\overline X\sim N(\mu,\frac{\sigma^2}n)$</p><h2 id="矩估计">矩估计</h2><ol><li>求期望</li><li>将期望E=xxx换成 $(E=)\overline X=xxx$</li><li>将未知数用 $\overline X$ 表示(也就是求反函数)</li></ol><h2 id="最大似然估计">最大似然估计</h2><ol><li>先把函数抄一遍</li><li>构造似然函数 $L(x_1,x_2,…,x_n,\theta)=f(x_1)f(x_2)…f(x_n)$<br>(就是直接乘起来,算答案)</li><li>对似然函数取对数,得到 $\ln L(x_1,x_2,…,x_n,\theta)$</li><li>上述对数函数对 $\theta$ 求偏导 $\frac{\partial \ln L}{\partial \theta}$</li><li>令上述偏导为0,得到 $\hat\theta$ 的值.</li><li>(不用真的带入计算)证明 $\hat\theta$ 是一个极大值,用到高中证明单调性的方法,函数在哪哪哪怎么怎么样.</li></ol><h2 id="无偏性-有效性-一致性">无偏性 有效性 一致性</h2><p>无偏估计: $E(\hat\theta)=\theta$ 人话:系数加一起等于1,如 $X=0.5X_1+0.5X_2$ 是, $0.6X_2$ 就不是了.<br>有效性:比方差看哪个小哪个更有效,如 $x2$ 不如 $\frac12x1+\frac16x2+\frac13x3$ .</p><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><h1>下面内容因为太过冗余,不再维护.</h1><p>逆天概率论有期中考试.</p><h2 id="随机试验">随机试验</h2><p>简称试验,有三大性质:可重复性 可观测性 随机性</p><p>样本点:最基本的结果,通常用 $\omega$ 表示,如 <code>CE,WA,AC...</code><br>样本空间:所有样本点组成的集合,用 $\Omega$ 表示,即 <code>&#123;CE,WA,AC,RE,TLE...&#125;</code><br>随机事件:样本空间的子集,若干样本点构成的集合,用 <code>A,B,C</code> 表示.<br>基本事件:样本空间的单点集,也就是包含一个基本结果的集合 <code>&#123;TLE&#125;</code> .<br>必然事件:用 $\Omega$ 表示.<br>不可能事件:用 $\Phi$ 表示.</p><p>集合交并补运算,迪摩根律(忽略)<br>差:事件A发生但是B不发生,记作 <code>A-B</code> .<br>$$A-B=A\overline B=A-AB$$<br>$$(A-B)\cup B=A\cup B$$</p><h2 id="频率">频率</h2><p>n次试验中A发生na次有<br>$$f_n(A)=\frac{n_A}n$$<br>频率:非负性,规范性(对于必然事件频率是1),有限可加性(对于两两不相容的事件,他们至少发生一个的概率是频率相加,有下式)<br>$$f_n\left(\bigcup_{i=1}^mA_i\right)=\sum_{i=1}^mf_n(A_i)$$<br>频率不是概率,有波动性,随着测试次数增加趋于稳定…<br>$$f_n(A)\to p(n\to+\infty)$$</p><h2 id="概率">概率</h2><p>非负性,规范性,可列可加性(频率的式子改改就是了)</p><p>性质:如果 $A\subseteq B$ 有 $P(B-A)=P(B)-P(A)$</p><p>减法公式:对任意事件AB有<br>$$P(B-A)=P(B)-P(AB)$$<br>加法公式:任意事件AB有<br>$$P(A\cup B)=P(A)+P(B)-P(AB)$$<br>本质是容斥,可以推到三个事件.</p><h2 id="古典概型-等可能概型">古典概型(等可能概型)</h2><p>有限样本空间,每个样本点等可能.</p><h2 id="几何概型">几何概型</h2><p>有限样本空间,概率只和几何大小有关.</p><h3 id="例题-蒲丰投针问题">例题-蒲丰投针问题</h3><p>平面上均匀画有平行直线,间距2a,你要不停扔长度2l的针($l&lt;a$),求针和任意直线相交的概率.</p><p>设针中点和最近直线距离为l,夹角为 $\varphi$ ,有<br>$$\Omega={(\varphi,x)|0\le\varphi\le\pi,0\le x\le a}$$<br>相交的充要条件是<br>$$0\le x\le l\sin \varphi$$<br>然后画出图形求定积分<br>$$p=\frac{\int_{0}^\pi l\sin\varphi\mathrm d\varphi}{\pi a}=\frac{2l}{\pi a}$$</p><h2 id="条件概率">条件概率</h2><p>若 $P(A)&gt;0$ ,称<br>$$P(B|A)=\frac{P(AB)}{P(A)}$$<br>叫做A发生下事件B发生的概率.</p><p>由于&quot;非负性,规范性,可列可加性&quot;,所以条件概率也是概率.</p><p>常用公式:<br>$$P(\overline B|A)=1-P(B|A)$$<br>$$P((B_1\cup B_2)|A)=P(B_1|A)+P(B_2|A)-P((B_1B_2)|A)$$<br>条件概率的本质是把事件A看成条件,也就是把A看成新的样本空间.<br>$$P(B|A)=\frac{AB的样本点数}{\Omega_A的样本点数}$$<br>乘法公式:如果 $P(B)&gt;0$ 有<br>$$P(AB)=P(A|B)P(B)$$<br>如果 $P(A)&gt;0$ 有<br>$$P(AB)=P(B|A)P(A)$$</p><h3 id="推广">推广:</h3><p>如果 $P(A_1A_2…a_n)&gt;0$ 有(套娃)<br>$$P(A_1A_2…A_n)=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)…P(A_n|A_1A_2…A_{n-1})$$</p><h2 id="全概率公式">全概率公式</h2><p>把整个样本空间拆分成 $A_1…A_n$ n个两两不相容的事件,然后他们并一起就是样本空间,有<br>$$P(B)=\sum_{i=1}^nP(B|A_i)P(A_i)$$</p><h2 id="贝叶斯公式">贝叶斯公式</h2><p>由乘法公式<br>$$P(AB)=P(A|B)P(B)=P(B|A)P(A)$$<br>带入全概率公式得<br>$$\boxed{P(A_i|B)=\frac{P(B|A_i)P(A_i)}{\sum_{j=1}^nP(B|A_j)P(A_j)}}$$<br>$A_1…A_n$ 可以看作是导致结果B发生的各种原因.<br>$P(A_i|B)$ 是B发生下 $A_i$ 引起的概率,称作 <em>后验概率</em> .<br>$P(A_i)$ 称作先验概率.</p><h2 id="事件的独立性">事件的独立性</h2><p>如果有<br>$$P(AB)=P(A)P(B)$$<br>则称事件 $A,B$ 相互独立.另一种定义:<br>$$P(B|A)=P(B)$$<br>$$P(A|B)=P(A)$$<br>必然事件和不可能事件与任何事件独立.</p><h3 id="独立和不相容关系">独立和不相容关系:</h3><p>相互独立: $P(AB)=P(A)P(B)$<br>互不相容: $AB=\Phi$<br>若 $P(A)&gt;0,P(B)&gt;0$ ,则独立和不相容不可能同时成立.</p><p>若<br>$$P(AB)=P(A)P(B)$$<br>$$P(AC)=P(A)P( C )$$<br>$$P(BC)=P( C )P(B)$$<br>即<br>$$P(ABC)=P(A)P(B)P( C )$$<br>则称 $ABC$ 相互独立.</p><p>若<br>$$P(A_1A_2…A_n)=P(A_1)P(A_2)…P(A_n)$$<br>则称事件 $A_1…A_n$ 独立.</p><h2 id="伯努利概型">伯努利概型</h2><p>两种结果,试验独立,区别于二项分布的点是,这个分布没有乘上二项式系数(也就是组合数),乘上组合数的伯努利分布叫做二项分布.</p><h1>随机变量及其概率分布</h1><p>随机变量: $X$<br>变量 $X$ 的分布函数: $F(x)=P{X\le x},(-\infty&lt;X&lt;+\infty)$</p><p>概率分布函数:分情况讨论的大括号…<br>性质:单调不减</p><h2 id="离散型随机变量">离散型随机变量</h2><p>列表法体现分布律.<br>分布函数:阶梯一样的函数,范围一般取左端点取不到右端点.</p><h2 id="连续型随机变量及其概率密度">连续型随机变量及其概率密度</h2><p>分布函数 $F(x)$ 满足<br>$$F(x)=P(X\le x)=\int_{-\infty}^xf(t)\mathrm dt,-\infty&lt;x&lt;+\infty$$<br>$f(x)$ 叫做概率密度函数,可以不连续,也可以不唯一.<br>$F(x)$ 在 $(-\infty,+\infty)$ 是连续的.</p><p>性质2: $\int_{-\infty}^{+\infty}f(x)\mathrm dx=1$<br>性质5: $P{X=c}=0$ ,连续随机变量取任意点 $c$ 的概率为 $0$ .<br>所以,概率为 $0$ 不一定是不可能事件.<br>同理,概率为 $1$ 也不一定是必然事件.<br>性质6: $P{a&lt;X\le b}=\int_{a}^bf(x)\mathrm dx$ 连续性随机变量取值落在某一区间的概率和区间开闭无关.</p><h2 id="几种常用的离散分布">几种常用的离散分布</h2><ol><li><p>两点分布((0-1)分布)</p></li><li><p>二项分布( $X\sim B(n,p)$ ,试验进行n次,每次概率为p)(<code>~</code> in $\LaTeX:\mathrm{sim}$)</p></li></ol><p>$$P{X=k}=P_n(k)=C_n^kp^k(1-p)^k$$</p><ol start="3"><li>泊松分布</li></ol><p>随机变量取值为 $0,1,…$ ,且有<br>$$P{X=k}=\frac{\lambda^ke^{-\lambda}}{k!},(k=0,1,2,…)$$<br>记作 $X\sim P(\lambda)$ 或 $X\sim\pi(\lambda)$<br>在这里立一个flag:因为难算,感觉泊松分布不会考</p><blockquote><p>泊松定理:设 $np_n=\lambda$ 对任意非负整数 $k$ 有<br>$$\lim_{n\to\infty}C_{n}^kp_n^k(1-p_n)^{n-k}=\frac{\lambda^ke^{-\lambda}}{k!}$$<br>也就是说,泊松分布是二项分布的极限分布,当n很大p很小时,二项分布就可以近似地看成是参数 $\lambda=np$ 的泊松分布.<br>在实际计算中,当 $n\ge20,p\le0.05$ 时近似效果较好.</p></blockquote><p><em>小概率事件</em> :可以借助小概率事件判定事情的真实性.因为小概率事件发生了可以让人们怀疑其正确性.</p><ol start="4"><li>几何分布:试验只有俩结果,要进行试验直到事件发生,称为几何分布,测试次数是随机变量.<br>$$P{X=k}=(1-p)^{k-1}p,k=1,2,…$$</li></ol><h2 id="几种常用的连续随机变量和分布">几种常用的连续随机变量和分布</h2><ol><li><p>均匀分布<br>$$f(x)=\begin{cases}\frac1{b-a}&amp;a&lt;x&lt;b\\0&amp;other\end{cases}$$</p></li><li><p>指数分布<br>$$f(x)=\begin{cases}\lambda e^{-\lambda x}&amp;x&gt;0\\0&amp;x\le0\end{cases}$$</p></li><li><p>正态分布 $X\sim N(\mu,\sigma^2)$<br>$$f(x)=\frac1{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}$$<br>其分布函数为<br>$$<br>\begin{aligned}<br>F(x)=<br>\int_{-\infty}^{x}f(t)\mathrm dt&amp;=<br>\int_{-\infty}^{x}\frac1{\sigma\sqrt{2\pi}}e^{-\frac{(t-\mu)^2}{2\sigma^2}}\mathrm dt<br>\\&amp;=<br>\frac1{\sigma\sqrt{2\pi}}\int_{-\infty}^{x}e^{-\frac{(t-\mu)^2}{2\sigma^2}}\mathrm dt<br>\end{aligned}$$<br>$$(-\infty&lt;x&lt;+\infty),F(\mu)=\frac12$$<br>性质: $\mu$ 是位置参数(变大图像右移), $\sigma$ 是形状参数(变大图像变平坦)</p></li><li><p>标准正态分布( $\mu=0,\sigma=1$ )性质:若 $X\sim N(\mu,\sigma^2)$ ,则 $Y=\frac{X-\mu}{\sigma}\sim N(0,1)$ .<br>然后是统计规律:<br>$$\begin{aligned}[\mu-\sigma,\mu+\sigma]&amp;=0.6826\\<br>[\mu-2\sigma,\mu+2\sigma]&amp;=0.9544\\<br>[\mu-3\sigma,\mu+3\sigma]&amp;=0.9974<br>\end{aligned}$$</p></li></ol><h2 id="随机变量的函数的分布">随机变量的函数的分布</h2><h3 id="离散型">离散型</h3><ol><li>先求随机变量X的分布律</li><li>然后对Y求分布律,把概率相同项叠加.</li></ol><h3 id="连续型">连续型</h3><ol><li>先求随机变量 $Y=g(X)$ 的分布函数<br>$$\begin{aligned}F_Y(y)&amp;=P{Y\le y}=P{g(X)\le y}=P{X\in G}\\&amp;=\int_Gf_X(x)\mathrm dx\end{aligned}$$<br>然后求导,有<br>$$f_Y(y)=F_Y’(y)$$</li></ol><p>$$aX+b\sim N(a\mu+b,(a\sigma)^2)$$</p><p>h(x)是反函数,若存在(g(x)严格单调处处可导)则有<br>$$f_X(x)=f_X(h(y))\Big|h’(y)\Big|$$</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;ABC两两独立和ABC相互独立的区别&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两两独立: $P(AB)=P(A)P(B)$ ,…(任意两个都满足这样的式子)&lt;br&gt;
相互独立(额外条件): $P(ABC)=P(A)P(B)P( C )$&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据库学习笔记</title>
    <link href="https://narafluorine.github.io/2025/05/08/00011_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://narafluorine.github.io/2025/05/08/00011_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-05-07T16:00:00.000Z</published>
    <updated>2025-06-11T08:52:44.581Z</updated>
    
    <content type="html"><![CDATA[<h1>SQL</h1><h2 id="DBMS-DBS-XML">DBMS,DBS,XML</h2><p>DBMS:数据库管理系统(包含相关企业信息 收集相关数据 访问的程序集 方便管理的开发环境)<br>DBS:数据库系统<br>XML:可拓展标记语言</p><h2 id="DDL-DML-DCL">DDL,DML,DCL</h2><p>DDL:Data Defination Lang(数据定义语言)<br>DML:Data Manuplation Lang(数据操作语言)<br>DCL:Data Control Lang(数据控制语言)</p><h2 id="码-键">码=键</h2><p>键=超键:能唯一标识一行的属性集合<br>候选键:最小属性个数的键<br>主键:人为从候选键中选出来标识该行的键(不一定非要有一个主键,主键绝对不可以有空值).<br>外键:(属性)是另一个表的主键.</p><h2 id="关系代数">关系代数</h2><p>选择: $\sigma_{条件}$ (选出来不会去重)<br>投影: $\prod$ (选好子列之后会进行去重)<br>并集: $\cup$ (条件:属性个数相同,属性域兼容)<br>差集: $-$ (属于前面不属于后面的元素)<br>笛卡尔积: $\times$<br>重命名: $\rho$</p><p>拓展运算符:(简化查询,不能增强关系运算能力)<br>交集: $\cap$<br>自然连接: $\bowtie$<br>除法: $\div$ (匹配:找出R(A,B),S(B)中所有匹配过所有S(B)的A)<br>赋值: $\leftarrow$</p><h2 id="函数-过程-触发器">函数 过程 触发器</h2><table><thead><tr><th>特性</th><th>函数</th><th>存储过程</th><th>触发器</th></tr></thead><tbody><tr><td><strong>返回值</strong></td><td>必须返回一个值</td><td>可选</td><td>不返回值</td></tr><tr><td><strong>调用方式</strong></td><td>在表达式中调用</td><td>显式调用</td><td>自动触发</td></tr><tr><td><strong>参数</strong></td><td>只有输入参数</td><td>输入和输出参数</td><td>无参数</td></tr><tr><td><strong>执行</strong></td><td>不能修改数据库</td><td>可以修改数据库</td><td>可以修改数据库</td></tr><tr><td><strong>用途</strong></td><td>计算</td><td>业务逻辑</td><td>数据完整性/审计</td></tr><tr><td><strong>事务</strong></td><td>在调用者事务中运行</td><td>可以控制事务</td><td>在触发操作事务中运行</td></tr></tbody></table><h2 id="varchar和char的区别">varchar和char的区别</h2><p>varchar是可变长度,声明时是最大长度,实际占用空间可变.<br>char是固定长度,实际占用空间不变,多余用空格填充.</p><h2 id="几种数据模型">几种数据模型</h2><p>关系数据模型 基于对象数据模型 图数据模型 树数据模型 半结构化数据模型</p><h2 id="子查询">子查询</h2><p>子查询可以引用外部查询的表.</p><h2 id="关系代数与SQL">关系代数与SQL</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A1,A2,...,An</span><br><span class="line"><span class="keyword">FROM</span> r1,r2,...,rm</span><br><span class="line"><span class="keyword">WHERE</span> P</span><br></pre></td></tr></table></figure><p>等价于<br>$$\Pi_{A_1,a_2,…,A_n}(\sigma_P(r_1\times r_2\times…\times r_m))$$<br>可以携带算术表达式(多少除多少那种).</p><h2 id="字符串">字符串</h2><p>用单引号 <code>'</code> 保住,如果字符串本身有单引号就双写 <code>''</code> 表示字符串.<br><code>%</code> 匹配字符串任意子串(长度&gt;=0)<br><code>_</code> 匹配任意一个精确字符(长度==1)<br><code>ESCAPE</code> 转义字符(该字符后面的一个字符只会被当成普通的字符处理)<br><code>LIKE 'Save 20#% Today' ESCAPE '#';</code> 这个会匹配 <code>20%</code> 而不是 <code>20xxx</code> .</p><h2 id="别名-AS">别名(AS)</h2><p>通常是可以直接省略的,如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> account <span class="keyword">AS</span> R</span><br><span class="line"><span class="keyword">FROM</span> account R     <span class="comment">--这两句话等同效力</span></span><br></pre></td></tr></table></figure><h2 id="排序">排序</h2><p><code>ASC</code> 升序(默认), <code>DESC</code> 降序.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cname,bname,account</span><br><span class="line"><span class="keyword">FROM</span> b <span class="keyword">AS</span> T,l <span class="keyword">AS</span> S</span><br><span class="line"><span class="keyword">WHERE</span> T.num<span class="operator">=</span>S.num</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cname <span class="keyword">ASC</span>,account <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h2 id="保留重复">保留重复</h2><p>用 <code>ALL</code> .即 <code>UNION ALL,INTERSECT ALL,EXCEPT ALL</code> .<br>(并集UNION,交集INTERSECT,差集EXCEPT)<br>例如选出所有有贷款或有存款的用户:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> nname <span class="keyword">FROM</span> loan</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> nname <span class="keyword">FROM</span> borrow</span><br></pre></td></tr></table></figure><h2 id="分组-group-by-having">分组(group by,having)</h2><p>按照什么玩意分组之后让聚集函数分别生效<br>例:统计各银行储户数量(注意去重):</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> branch_name,<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> customer_name)</span><br><span class="line"><span class="keyword">FROM</span> depositor <span class="keyword">AS</span> R,account <span class="keyword">AS</span> S</span><br><span class="line"><span class="keyword">WHERE</span> R.account_number<span class="operator">=</span>S.account_number</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> branch_name</span><br></pre></td></tr></table></figure><p>having:对于分组后的谓词开条件:<br>查询储户余额超过1200美元的银行和平均余额:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> branch_name,<span class="built_in">avg</span>(balance)</span><br><span class="line"><span class="keyword">from</span> account</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> branch_name</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(balance)<span class="operator">&gt;</span><span class="number">1200</span></span><br></pre></td></tr></table></figure><h2 id="空值">空值</h2><p>判断: <code>IS NULL</code> 和 <code>IS NOT NULL</code> .<br>聚合函数除了 <code>COUNT()</code> 都是直接忽略空值的.<br>空值比较:sql中bool实际上是三结果的:true false和unknown,按照你想的比较方式进行即可.</p><h2 id="嵌套子查询">嵌套子查询</h2><p>用 <code>IN</code> 表示集合中的 $\in$ 关系.<br>相对的是 <code>NOT IN</code> .</p><h2 id="集合比较">集合比较</h2><p><code>&lt; SOME ()</code> <code>&lt; &gt; = &lt;= &gt;= &lt;&gt;</code><br>找出资产高于A市某个银行的银行:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SeLeCt</span> <span class="keyword">DiStInCt</span> bankname</span><br><span class="line"><span class="keyword">FROM</span> branch</span><br><span class="line"><span class="keyword">WHERE</span> assets <span class="operator">&gt;</span> <span class="keyword">some</span> (</span><br><span class="line"><span class="keyword">select</span> assets</span><br><span class="line"><span class="keyword">from</span> branch</span><br><span class="line"><span class="keyword">where</span> branchname<span class="operator">=</span><span class="string">&#x27;A&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>同时还有 <code>&lt; ALL</code> 的运算,类似.</p><h2 id="存在-EXIST">存在(EXIST)</h2><p>判定有没有返回数据.<br>例:找出既有存款又有贷款的顾客:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> cname</span><br><span class="line"><span class="keyword">FROM</span> borrower R</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> depositor S</span><br><span class="line"><span class="keyword">where</span> S.cname<span class="operator">=</span>R.cname</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>子查询可以直接使用关系R,可以简化查询语言书写.</li><li>exists只会判定有没有,所以直接返回*即可.</li></ol><p>同理,不存在用 <code>NOT EXISTS</code> .</p><h2 id="重复-UNIQUE">重复(UNIQUE)</h2><p>如果返回的表不包含重复元组返回true.</p><h3 id="from子句">from子句</h3><p>允许查询,即 <code>from (select xxx)</code> .</p><h3 id="with子句">with子句</h3><p>定义临时关系,简化查询.</p><h3 id="视图-view">视图(view)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> A(a,b,c) <span class="keyword">as</span>(</span><br><span class="line">(<span class="keyword">select</span> xxx)</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">(xxx)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>view是一个虚拟表,简化查询.</li><li>可以根据权限分配视图,不让其知道数据库的真实结构.</li><li>底层表发生变化只需要改变视图就可以兼容原有应用程序.</li></ol><p>物化视图(真实存储数据的视图)</p><h2 id="删除数据">删除数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">from</span> r</span><br><span class="line"><span class="keyword">where</span> p</span><br></pre></td></tr></table></figure><h2 id="插入数据">插入数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> account</span><br><span class="line"><span class="keyword">values</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="number">1200</span>) <span class="comment">--默认顺序</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> account(cname,cnnn,numbers)</span><br><span class="line"><span class="keyword">values</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="number">1200</span>) <span class="comment">--默认顺序</span></span><br></pre></td></tr></table></figure><h2 id="数据更新-update">数据更新(update)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> account</span><br><span class="line"><span class="keyword">SET</span> balance<span class="operator">=</span>balance<span class="operator">*</span><span class="number">1.05</span></span><br><span class="line"><span class="keyword">WHERE</span> balance<span class="operator">&gt;</span><span class="number">5000</span></span><br></pre></td></tr></table></figure><p>带case结构:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> account</span><br><span class="line"><span class="keyword">SET</span> balance<span class="operator">=</span><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> balance<span class="operator">&lt;=</span><span class="number">1000</span> <span class="keyword">THEN</span> balance<span class="operator">*</span><span class="number">1.05</span></span><br><span class="line"><span class="keyword">WHEN</span> balance<span class="operator">&lt;=</span><span class="number">2000</span> <span class="keyword">THEN</span> balance<span class="operator">*</span><span class="number">1.06</span></span><br><span class="line"><span class="keyword">ELSE</span> balance</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h2 id="数据合并-JOIN">数据合并(JOIN)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">NATURAL</span> <span class="keyword">JOIN</span>                  <span class="comment">--自动找到相同的行</span></span><br><span class="line"><span class="keyword">JOIN</span> <span class="operator">=</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span>             <span class="comment">--(自己指定条件on)</span></span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> <span class="operator">=</span> <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> <span class="comment">--(自己指定条件on)</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="operator">=</span> <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span>   <span class="comment">--(自己指定条件on)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ON</span> xx<span class="operator">=</span>xx <span class="comment">--自己指定join的条件,可以不是等式</span></span><br><span class="line"><span class="keyword">USING</span> xx <span class="comment">--也可以用某个指定的共有的数据行的相等作为join对象.</span></span><br></pre></td></tr></table></figure><h2 id="数据类型">数据类型</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>                       <span class="comment">--</span></span><br><span class="line"><span class="type">decimal</span>(p,s)<span class="operator">=</span><span class="type">numeric</span>(p,s) <span class="comment">--p总位数,s小数点后位数</span></span><br><span class="line"><span class="type">float</span>(p)                  <span class="comment">--p精度(总位数)</span></span><br><span class="line"><span class="type">blob</span>(<span class="number">2</span>GB)                 <span class="comment">--二进制大文件</span></span><br><span class="line"><span class="type">clob</span>(<span class="number">2</span>KB)                 <span class="comment">--字符型大对象类型</span></span><br><span class="line"><span class="type">date</span></span><br><span class="line"><span class="type">time</span></span><br><span class="line"><span class="type">timestamp</span></span><br><span class="line"><span class="keyword">year</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> Dollars <span class="keyword">as</span> <span class="type">numeric</span>(<span class="number">12</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> mm(</span><br><span class="line">mmoney Dollars</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="数据转换">数据转换</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cast</span>(a.a <span class="keyword">to</span> <span class="type">numeric</span>(<span class="number">12</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><h2 id="完整性约束">完整性约束</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">unique</span>(a,b,...)</span><br><span class="line"><span class="keyword">check</span>(num <span class="operator">&gt;</span><span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>domain:用户自定义数据类型,里面可以附带一个check,避免重复约束,让代码可修改,减少错误,增加数据完整性,简化模式定义.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DOMAIN US_PHONE_NUMBER <span class="keyword">AS</span> <span class="type">VARCHAR</span>(<span class="number">15</span>)</span><br><span class="line"><span class="keyword">CHECK</span> (<span class="keyword">VALUE</span> <span class="keyword">SIMILAR</span> <span class="keyword">TO</span> <span class="string">&#x27;[0-9]&#123;3&#125;-[0-9]&#123;3&#125;-[0-9]&#123;4&#125;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Customers (</span><br><span class="line">    CustomerID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    CustomerName <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    PhoneNumber US_PHONE_NUMBER, <span class="comment">-- 直接使用域</span></span><br><span class="line">    <span class="comment">-- ... 其他列</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="函数-过程-触发器-2">函数 过程 触发器</h2><p>考到了再写.(PPT07,PPT13的50多页)</p><h1>ER图</h1><p>实体集:矩形:上面写名字,下划线是主码(类似主键???)<br>联系集:菱形:里面写名字,联系集上的属性用矩形加虚线脸上.</p><p>约束:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">========= 完全参与,也就是&gt;=1</span><br><span class="line">--------- 不完全参与,也就是&gt;=0</span><br><span class="line">--------&gt; 严格是1</span><br></pre></td></tr></table></figure><p>弱实体集:没主码,里面全部虚线,用两个矩形.<br>然后出去的也是双菱形.</p><h2 id="ER转化">ER转化</h2><h3 id="实体集">实体集</h3><p>强实体集可以直接转化.<br>弱实体集转化之后添加依赖的强实体集的主码.<br>联系集写上联系的两个主码.</p><p>实体有一个多值属性:单拎出来,记录属性和父属性的主码.</p><h3 id="联系集">联系集</h3><p>映射基数:几对几.</p><p>一对多:选择多的那边添加另一边主码.<br>多对多:单拎出来作为一个实体,记录两边主码.<br>一对一:任选一边添加对方主码.</p><p>参与约束:主键和外键约束 唯一和检查约束.</p><h3 id="多值依赖">多值依赖</h3><p>属性集之间的一种约束:<br>课程-&gt;-&gt;老师-&gt;-&gt;课本<br>每个课程由多个老师教授,每个老师有多个课本,且相互独立.</p><h1>函数</h1><h2 id="函数依赖">函数依赖</h2><p>$A\to B$ 直观理解函数依赖:</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">5</td></tr></tbody></table><p>关系模式: $R(A,B,C)$<br>函数依赖集: $F={A\to B,B\to C}$</p><p>典1:设 $A\to B,A\to C$ ,证明 $A\to BC$ .</p><ol><li>由增广律有 $A\to AB$</li><li>由传递律有 $AB\to CB$</li><li>由传递律有 $A\to BC$ .</li></ol><h2 id="范式">范式</h2><h3 id="1NF">1NF</h3><p>所有列都是原子的(不可分割).</p><h3 id="2NF">2NF</h3><ol><li>必须满足1NF.</li><li>非主键属性必须完全依赖于主键.</li></ol><p>部分函数依赖:属性只依赖于主键的一部分,而不是整个主键.<br>2NF旨在消除部分函数依赖.</p><p>举例:假设订单表由 <code>订单ID,产品ID,产品数量,物品名称</code> 组成,因为一单可以买很多东西,所以主键必须由 <code>(订单ID,产品ID)</code> 共同构成.</p><p>产品的名称等信息只依赖产品ID不依赖订单,同理,所以产生了部分函数依赖,需要拆表:拆成订单表(谁订了,订单ID,…),物品表(物品ID,名字,…),订购记录表(订单ID,物品ID,物品数量).</p><p>2NF分解:找出候选码,然后对所有部分依赖的每一个字母单独开一个集合.</p><h3 id="最小函数依赖集-正则覆盖换名字">最小函数依赖集(正则覆盖换名字)</h3><ol><li>把所有箭头右侧的多个字母直接拆开.</li><li>对每个箭头考虑,去掉这个箭头能不能推出来(也就是对箭头左侧的字母求闭包),能推出来就删掉箭头,否则保留.</li><li>最后保留的箭头再尝试拆一下:箭头左侧可以是两三个字母,但是必须不可分.</li></ol><h3 id="找候选码">找候选码</h3><p>首先把不出现在箭头右侧的所有字母列下来,他们是必须出现的.<br>然后对这个字母集合每次遍历所有箭头找能不能匹配的.<br>直到没有之后break,然后判断是不是全集.是就是候选码,不是就再加条件.</p><h3 id="无损链接判断">无损链接判断</h3><p>画一个表,上面是元素,左边是给出来的数据分解.<br>填表:对所有指向标an,没有标的填bij.</p><p>主循环:对每个箭头去推.<br>最后不变了之后如果存在一行全是a那就具有无损连接性,否则不具有.<br><a href="https://www.bilibili.com/video/BV1jV411Y7Cx">这个</a></p><h3 id="3NF判定">3NF判定</h3><p>对任意 <em>非平凡函数依赖</em> ( $A\to AB$ 这种就是平凡的)有<br>均满足下列两个条件之一,对于任意 $X\to Y$ 有</p><ol><li>X是一个键</li><li>Y是一个主属性,即Y的每个属性都包含在R的候选码之中.</li></ol><h3 id="BCNF判定">BCNF判定</h3><p>对于任意 $X\to Y$ 有X必须是R的一个超码(键).</p><h3 id="3NF">3NF</h3><p>不允许传递函数依赖.</p><p>所以求最小依赖关系,然后对每个箭头都单独开一个划分集合即可,最后把候选码加上(保证无损),当然如果候选码在里面有就不用管了.</p><h3 id="BCNF">BCNF</h3><p>找BCNF:首先对于整个RF求候选码.<br>然后找到候选码之后再找一个不含候选码任意元素的箭头,把这个箭头整个拿下来作为一个新关系Rx.<br>然后删除箭头右边的元素,然后对于F求出所有关于删掉元素的传递关系,得到一个新F和新R,对子任务递归使用该算法.<br>(最后不存在就直接全拿下来就完事了)</p><h3 id="保持依赖">保持依赖</h3><p>在关系分解过程中,确保分解后的子关系模式仍然能够保持原有的依赖关系.</p><h1>事务</h1><p>概念:访问并可能修改数据项的一个程序执行单元.<br>模型:ACID模型:<br>原子性(把事务中的操作当成一个整体,要么都执行,要么都不执行)<br>一致性(隔离执行事务时保持数据库的一致性)<br>隔离性(并发执行事务不知道对方存在执行也不受彼此影响)<br>持久性(事务执行完毕后对数据库的改变是永久的)</p><p>其他模型:BASE 模型 (基本可用性、软状态、最终一致性)<br>XA 模型 (eXtended Architecture)<br>Saga 模型</p><p>修改:影子拷贝(生成一个副本进行修改,改好了提交(改变),或者滚回(丢弃))</p><h2 id="并发执行">并发执行</h2><p>冲突:调度S含有分别属于T1和T2的两条连续指令I1和I2:<br>I1,I2分别等于read或write</p><p>属于调度S的操作相同的数据项的指令I1或I2中至少有一个是write时,称I1和I2是冲突的.</p><p>如果调度S可以经过一系列非冲突指令转换成S’,称S和S’是冲突等价的.</p><p><strong>串行调度</strong> :来自各个事务的指令序列中同一事务的指令紧挨在一起.</p><h2 id="可串行化">可串行化</h2><p>如果一个调度与一个串行调度冲突等价,称该调度为冲突可串行化的.</p><p>画图:Ti和Tj是两个事务,连边(Ti-&gt;Tj):</p><ol><li>在Tj读之前Ti写了</li><li>在Tj写之前Ti读了</li><li>在Tj写之前Ti写了</li></ol><p>然后对图拓扑排序即可,有环代表不是冲突可串行化的.</p><h2 id="视图可串行化">视图可串行化</h2><p>如果一个调度视图等价于一个串行调度,称该调度为视图可串行化的.</p><h2 id="可恢复调度">可恢复调度</h2><p>对于任意事务Ti和Tj,如果Tj读取了Ti所写的项,则Ti先于Tj提交.</p><h2 id="无级联调度">无级联调度</h2><p>对于任意事务Ti和Tj,如果Tj读取了Ti所写的项,则Ti必须在Tj读取之前提交.</p><h1>并发控制</h1><p><code>lock-S(Q)</code> S锁,可读不可写Q.<br><code>lock-X(Q)</code> X锁,可读可写Q.</p><p>锁相容性矩阵(假如这个东西还有别的锁,你可以再拿到一个锁吗?)</p><table><thead><tr><th style="text-align:center">\</th><th style="text-align:center">S</th><th style="text-align:center">X</th></tr></thead><tbody><tr><td style="text-align:center">S</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">No</td><td style="text-align:center">No</td></tr></tbody></table><p>所以只要出现了X就不能再给锁了…</p><h2 id="两阶段锁">两阶段锁</h2><ul><li>保证冲突可串行化.</li><li>不保证不发生死锁.</li><li>可能出现级联滚回.</li></ul><h2 id="严格两阶段锁">严格两阶段锁</h2><p>不仅要求封锁是两阶段的,还要求事务持有的所有排他锁必须在事务提交后才能释放.</p><h2 id="强两阶段锁">强两阶段锁</h2><p>要求事务提交之前不得释放任何锁.</p><h2 id="死锁的检测与恢复">死锁的检测与恢复</h2><p>等待图:等待图中包含环时,系统存在死锁.(连边:i-&gt;j表示j在等待i释放所需数据项)</p><p>恢复:回滚一个或多个事务.</p><p>选择牺牲者:<br>已用和还需要的时间<br>已用和还需要的数据量<br>回滚涉及的事务数量</p><p>回滚:<br>全部回滚<br>部分回滚</p><p>饿死:<br>选择牺牲者的因素增加&quot;回滚次数&quot;</p><h1>八股</h1><h2 id="中国有哪些自主研发的数据库">中国有哪些自主研发的数据库?</h2><ol><li>OceanBase蚂蚁集团</li><li>OpenGauss华为开源</li><li>达梦数据库 D M武汉达梦</li><li>PolarDB 阿里云</li><li>TDSQL 腾讯云</li><li>TiDB PingCAP</li><li>GaussDB 华为云</li><li>GoldenDB 中兴通讯</li></ol><h2 id="如何实现多表更新">如何实现多表更新?</h2><ol><li>对每个表使用UPDATE子句</li><li>使用事务</li><li>使用特定语法支持的多表更新语句</li><li>创建存储过程</li></ol><h1>做题</h1><h2 id="第一套">第一套</h2><ol><li>为什么3NF范式分解能够保证函数依赖一定能够得到保持?</li></ol><blockquote><p>因为3NF分解能够保证函数的无损连接性和函数依赖保持性,同时尽量减少数据冗余和数据异常.</p></blockquote><ol start="2"><li>在sql语句中,where子句可以嵌入子查询,那么该子查询的作用有哪些?(至少两种)</li></ol><blockquote><ol><li>作为筛选的数据来源</li><li>作为条件判断的逻辑依据</li><li>提供动态的逻辑值方便过滤</li><li>提供存在性的逻辑判断方便筛选</li></ol></blockquote><ol start="3"><li>冲突可串行化调度(如何给出等价可串行化调度?)</li></ol><h2 id="第二套">第二套</h2><ol><li><p>主键叫做 <code>primary key</code> .</p></li><li><p>复合主键: <code>p key(A,B)</code></p></li><li><p>复合主键是可以被外键约束的,且如果存在多个外键,一个一个来.</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">primary</span> key (customer_name, account_number),</span><br><span class="line"><span class="keyword">foreign</span> key(customer_name) <span class="keyword">references</span> customer(customer_name),</span><br><span class="line"><span class="keyword">foreign</span> key(account_number) <span class="keyword">references</span> account(account_number)</span><br></pre></td></tr></table></figure><ol start="4"><li><p>主键会自动检查去重非空,并不需要额外的 <code>not null</code> 和 <code>unique</code> ,但是外键可以加上.</p></li><li><p>(才发现有这么个运算符)新运算:分组聚集运算:<br>$$<em>a\mathcal{G}</em>{F(b),AS,fb}(thing)$$<br>按照A分组对b进行函数F(x)的运算,后面写清楚什么新名字.</p></li></ol><p>然后分组之后按照什么计算之后判定条件加在having这里.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> branch_name,<span class="built_in">AVG</span>(balance)</span><br><span class="line"><span class="keyword">from</span> account</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> branch_name</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">AVG</span>(balance)<span class="operator">&lt;</span><span class="number">5000</span></span><br></pre></td></tr></table></figure><ol start="6"><li>什么是数据库索引?数据库索引一般采用什么结构?</li></ol><blockquote><p>一种特殊的数据结构,能够实现高效检索数据,占用额外空间,减小查找的时间.<br>索引结构都是平衡树,如B树,B+树,哈希索引等.</p></blockquote><ol start="7"><li>如果张三想通过汇款的方式给李四200元,张三的账户已经减掉200元后系统发生故障,并没有在李四的账户中增加200元,请问数据库出现了什么样的状态?这个问题该怎么解决?数据库通过什么手段实现该操作?</li></ol><blockquote><p>出现事务处理失败后数据不一致的状态.<br>事务并未成功提交,也没有被完全回滚.<br>关键在于事务回滚或补偿.</p></blockquote><h2 id="第三套">第三套</h2><ol><li>在数据库中,实体的完整性是如何被保证的?</li></ol><blockquote><p>通过主键约束保证.主键不能为空,不能重合.</p></blockquote><ol start="2"><li>如何降低数据库中数据的冗余度?</li></ol><blockquote><p>关系数据库的规范化,也就是进行范式分解.<br>数据中心化和共享.</p></blockquote><ol start="3"><li>关系代数中,与等值连接相比,自然连接的缺点是什么?</li></ol><blockquote><ol><li>无法处理非等值连接.</li><li>当两个表有多列名字相同时,自然连接可能会出现意料之外的结果.</li></ol></blockquote><ol start="4"><li>为什么要对数据库的调度就行可串行化判别,其实际意义是什么?</li></ol><blockquote><p>为了防止意料之外的错误(脏读,更新丢失,幻读,不可重复读)等,要对并发的事务进行串行化检查</p></blockquote><h2 id="劳伦斯">劳伦斯</h2><ol><li><p>数据抽象</p><ol><li>物理层 数据在物理存储介质上的结构</li><li>逻辑层 数据在应用逻辑上面的形式</li><li>视图层 用户实际可交互的节面,减少逻辑的泄露</li></ol></li><li><p>两层映射</p><ol><li>外层映射 实现逻辑数据独立性</li><li>内层映射 实现物理数据独立性</li></ol></li></ol><h2 id="ONS">ONS</h2><ol><li>什么是数据模型?</li></ol><blockquote><p>数据模型是描述数据关系,数据操作,数据定义的形式化工具,用来组织,存储,管理数据.</p></blockquote><ol start="2"><li>为什么在设计数据模型时要把数据做得精确?</li></ol><blockquote><p>提高数据质量,优化存储性能,简化管理维护,减少开发和维护成本.</p></blockquote><ol start="3"><li>主键的类型有哪些?如何选择主键?</li></ol><blockquote><p>业务主键,复合主键,代理主键.<br>首选自增长系数(如ID).<br>谨慎使用复合主键.</p></blockquote><ol start="4"><li>举例说明不可重复读异常产生的原因以及其在数据库管理系统中的解决办法进行描述.</li></ol><blockquote><p>不可复读异常:某个事务要多次读取同一行数据,但是这个数据被修改过导致两次读取结果不一致.<br>可以使用四种隔离级别来有效避免这种异常:<br>读未提交:允许读取某个事务尚未提交的数据(脏读),不解决不可复读.<br>读已提交:允许读取某个事务已提交的数据,解决脏读,但仍未解决不可重复读.<br>可重复读:保证在多行的多次读取结果是一致的,解决了不可重复读.<br>串行化:解决了所有并发异常,但是由于牺牲并发性导致性能开销很大.</p></blockquote><ol start="5"><li>并发控制的主要方法是(  )机制.</li></ol><blockquote><p>锁机制.</p></blockquote><ol start="6"><li>在数据库中,只存放视图的(  ),不存放视图的数据.</li></ol><blockquote><p>定义(结构,SQL语句等)</p></blockquote><ol start="7"><li>简述数据库系统和文件系统的区别.</li></ol><blockquote><p>数据库的文件更加集中,数据共享性很高,数据管理更加方便快捷,数据冗余更低,数据一致性高,数据安全性高,相比文件和目录以结构化的方式存储数据.</p></blockquote><ol start="8"><li>判断分解后的关系模式是否合理的两个重要的标志是什么?</li></ol><blockquote><p>无损链接性和保持函数依赖.</p></blockquote><ol start="9"><li>基于多表的视图能够完成哪些操作?不能完成哪些操作?</li></ol><blockquote><p>SELECT.可以简化复杂查询.<br>通常不能进行数据修改,即INSERT,UPDATE,DELETE,因为多表的语义一般是不明确的.</p></blockquote><ol start="10"><li>为什么要实现不同粒度的锁?</li></ol><blockquote><p>为了实现并发处理中效率和精度的平衡.<br>粗粒度锁:如表锁(锁定范围大,并发度低)<br>细粒度锁:如行锁(锁定范围小,开销大,并发度高)<br>除此之外还有数据库锁,页锁等.<br>为了防止死锁和活锁,提高吞吐量.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;SQL&lt;/h1&gt;
&lt;h2 id=&quot;DBMS-DBS-XML&quot;&gt;DBMS,DBS,XML&lt;/h2&gt;
&lt;p&gt;DBMS:数据库管理系统(包含相关企业信息 收集相关数据 访问的程序集 方便管理的开发环境)&lt;br&gt;
DBS:数据库系统&lt;br&gt;
XML:可拓展标记语言&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    <category term="DEAD" scheme="https://narafluorine.github.io/categories/DEAD/"/>
    
    
    <category term="MySql" scheme="https://narafluorine.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>青云悲出题感想</title>
    <link href="https://narafluorine.github.io/2025/04/26/20006_ToMakeTsingyunProblems/"/>
    <id>https://narafluorine.github.io/2025/04/26/20006_ToMakeTsingyunProblems/</id>
    <published>2025-04-26T04:27:36.000Z</published>
    <updated>2025-05-07T16:40:11.400Z</updated>
    
    <content type="html"><![CDATA[<p><strong>无论如何,我不会再出题了.</strong> 出题得不到什么奖励,出不好还会被骂,出题的时候要考虑各种情况(比如正解,代码长度,时限到底开多少,部分分怎么给,怎么卡掉非正解,可能有什么做法能草过去),还有人不干活,团委整天拖报销咋办…</p><p>所以这篇文章被公开了,以纪念Flu因为出题花费的非常非常多的时间.</p><blockquote><p>青云悲并不是算法竞赛,我们不能&quot;碰瓷&quot;ACM.所以青云悲的预期是大家都能参加的校级程序竞赛.(直观体验就是,第四届好像有气球发第五届没了)</p></blockquote><blockquote><p>出智商测试题的,假设最高量程250,自己智商可以没有250.<br>所以作为CF的 $\color{blue}\mathrm{NaraFluorine}$ ,我出的只是签到题,我认为是不存在实力问题的,用我们的话说,你尽量不要让选手爆零.(哦对了,我们今年还是有士力架发的,可以多拿几块再走,反正是团委报销)</p></blockquote><blockquote><p>T5是一道工程题,这是和算法竞赛区别最大的地方.在这里,不会写高难代码的人可以使用奇妙的idea干翻传统算竞选手(真的,去年好像是50-100-100-200-500,可见最后一个题有多重要)<br>讲一个真实的例子:去年考压缩图片,你要让压缩后的图片尽可能的小,但是我们给你 $4%$ 的大容错率让你有损压缩,结果一个能得两百三十分的程序做法非常生草:直接丢弃图片末尾几个像素卡容错率.这简直不用怎么写代码,但是确实能得高分.</p></blockquote><h1>To Make Problems For Tsingyun Cup 6th</h1><p>Flu作为出题人出了T2,和大家共同出了T5,中间有很多很多提案被否了,出于实现难度或时间限制.</p><h1>ideas</h1><p>记录大家探讨的结果,尽管可能对最终题目的选择没有多大影响,但是我们探究过,我们努力过.</p><h1>A1. Neko hit UB with O2</h1><h1>A1. 猫猫用O2打下UB</h1><h2 id="512MB-3s">512MB,3s</h2><h2 id="题目背景">题目背景</h2><p>从堆区访问回来的$猫猫学长$全然不顾身体的疲惫,连夜找我们几个局部变量商量主函数的安排.谈得晚了,便送我们出栈,要地址送我们回内存.在去总线的路上,我们说:“$猫学长$,您回去休息吧.您刚从堆区回来.” ;</p><p>$猫猫$学长摇摇尾巴,&quot;不碍事,你们知道现在国际上有很多人把C++当作敌人,不断给我们制造麻烦,你们是语言的未来,你们的事情便是语言的事情,是头等大事.&quot;我们都激动了,眼里噙着01.多好的$猫猫学长$呀. ;</p><p>$猫猫$抬头看看STL库说:“如果C++真像这STL库这么有条不紊就好了,但是就有一些代码,像死循环,要搞乱这门语言,他们是罪人.” ;</p><p>说着,$猫猫学长$弯下腰,从pragma里捡出一颗O2,然后看着代码说:“该死的无返回值.” ;</p><p>说着祂把O2奋力向上一掷.很快就见空中一段函数突然爆发出耀眼的强光,然后就坠落下来.“这是函数的死循环,他们一直在CPU盘旋,侵犯我们的主权,我已经忍了很久了.”$猫猫$愤愤地说.全局变量们都鼓起掌来,为C++有这样的领导人感到自豪. ;</p><p>一会$猫猫$叫来指针问:“那个函数落到什么地方了?”&quot;好像是输出流一带.&quot;指针说. ;</p><p>$猫猫$学长一怔,说:&quot;赶紧派变量去查,看有什么问题没有.&quot;之后学长送我们到数据总线,一直挥手到看不见我们. ;</p><p>第四天我们听说输出流那边出事了,我们很紧张.而这时$猫猫$学长叫我们过去. ;</p><p>祂依然那么慈祥,让我们坐下说:&quot;程序运行总是要有牺牲的.为计算事业牺牲的变量是伟大的.&quot;祂这时低下头说:“但我必须承认,我当时击落死循环函数的行为太鲁莽了,我在这里向全部变量们道歉.我将向全部变量说明情况.” ;</p><p>我们顿时热01盈眶,多好的学长呀,他在跟UB斗争过程中的小失误竟然被他记在心里,还道了歉,我们在将来的学习中一定要向$猫猫学长$学,学祂那宽广的胸怀,和不耻下问的精神. ;</p><h2 id="题意简述">题意简述</h2><p><code>UB</code> 是 <code>Undefined Behavior</code> 的缩写,意思是未定义行为.众所周知在C++中有很多未定义行为,包括但不限于,带符号整数算术溢出,越界访问,无可视副作用的无限循环等.</p><p>现在,您将对编译器的行为以及优化发起探索,了解其中的奥秘.</p><p>我们有 $q$ 个询问,每次给出一个数字 $n$ ,您需要计算下面代码中<br>$$\begin{aligned}&amp;\mathrm{int},a=0\<br>&amp;\mathrm{int},b=\underbrace{++a+\quad++a+\quad++a+…+\quad++a}_{n个a}\end{aligned}$$<br>的 $b$ 最后的值是多少.</p><h2 id="输入格式">输入格式</h2><p>第一行一个整数 $q$ ,表示有多少次询问.<br>第 $2$ 行至第 $q+1$ 行,一行一个整数 $n$ .</p><h2 id="输出格式">输出格式</h2><p>$q$ 行,一行一个整数,表示上面代码的值.</p><h2 id="样例输入-输出">样例输入/输出</h2><p><strong>输入#1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p><strong>输出#1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">29</span><br></pre></td></tr></table></figure><p><strong>样例解释</strong> :第一个询问中, $b=++a$ ,答案是 $1$ .<br>第二个询问中, $b=++a+\quad++a+\quad++a+\quad++a+\quad++a+\quad++a+\quad++a$ ,产生了UB,总之最后答案是 $29$ .</p><p><strong>样例参考代码</strong> :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b=++a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b);</span><br><span class="line">a=<span class="number">0</span>;</span><br><span class="line">b=++a+ ++a+ ++a+ ++a+ ++a+ ++a+ ++a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据范围">数据范围</h2><p>对于前 $20%$ 的数据, $1\le n,q\le10$ .<br>对于另 $20%$ 的数据, $1\le n,q\le50$ .<br>对于另 $20%$ 的数据, $1\le n,q\le100$ .<br>对于最后 $40%$ 的数据, $1\le n,q\le10^7$ .</p><h2 id="参考资料">参考资料</h2><p>运算符优先级</p><p>常见存储格式的范围(这是在提醒选手后面的测试真的会炸int,而且是故意炸int)</p><p>C++编译行,怎么输入,怎么输出的命令</p><p>C++如何调用Windows命令行</p><p>在线cpp转汇编(这个主要是误导选手一波,让他们见识见识高级工具得了,答案不在里面,放在最后)</p><h1>出题者语</h1><p><strong>(这个是出题的时候的大纲啊这个题的价值观啊啥的,不放在题面)</strong></p><p>这个题的走UB流程的正解是,先写一个对n输出答案生成器的程序,然后用给出的命令让选手刚才输出程序跑起来,得到答案,这个是一个表,提交的时候直接交表就行了.</p><p>为了防止有人真的爆零,我们给出样例的参考代码,反正也只能过样例,标答是个表…</p><p><strong>然而</strong>,这个题经过Flu的测试,只有两个及以上会产生UB(UB的原理是编译器只把前两个捆绑到一起算了,后面好像是个栈一样的算),也就是说超过2项的可以O(1)算…但是小心int溢出,这个题就是让int溢出的,别到时候玄学WA在int上面…</p><p><strong>不该给C++调用Linux命令的参考资料</strong>,防止选手交上去一个在线编译的,在线输出在线跑的,<s>而且1e7你敢跑我敢让你T飞</s></p><p><strong>一定</strong> 要测试各种情况,包括但不限于</p><ul><li>各种编译器</li><li>各种编辑器</li><li>各种优化</li><li>各种展开</li><li>选手机器</li><li>Linux能跑吗?不可选就ban了,反正青云悲也只能用C++交.</li></ul><hr><h1>A2.人机验证</h1><p>题目已经公开在洛谷.</p><p><a href="https://www.luogu.com.cn/problem/U479485">https://www.luogu.com.cn/problem/U479485</a></p><hr><h1>B1. 菊花魔塔</h1><h1>B1. Chrysanthemum Mota Game</h1><h2 id="3s-256MB">3s , 256MB</h2><p>你说得对,但是前面忘了,后面忘了,总之菊花魔塔是一个游戏,游戏中你将扮演一名勇者,挑战魔塔的怪物,收集加成道具,最终到达魔塔之巅.</p><p>菊花魔塔的构造可以简化为n个房间,每一个房间门口会有一只怪物.您随时可以造访任意一个房间,但走进房间前必须击败门口的怪物.房间内可能有加成道具(门会在您走的时候消失,所以您只能到访任意一个房间一次),您的目标是到达终点房间.菊花魔塔只有一层,即每把游戏只要能活着到达终点房间立刻胜利.</p><p>在菊花魔塔中,勇士和怪物都有以下属性值:生命值(hp),攻击力(atk)和防御值(def).<br>其中每次攻击造成的伤害值公式是 $\max(atk-def,0)$ ,即如果您砍怪物一刀,伤害是$5$,怪物防御是$3$,则怪物实际生命值会减$2$点,如果您的攻击是$2$,则怪物不会受到伤害.<br>您与怪物的对战可以简单理解为,您先砍怪物一刀,然后怪物砍你一刀,然后您再砍怪物一刀,以此类推,直到一方死亡,中途不可逃跑.死亡的定义是任意时刻生命值小于等于0.</p><p>在菊花魔塔中,加成道具有以下四种:</p><p>攻击药水(让攻击力永久+1)<br>防御药水(让防御力永久+1)<br>生命药水(让生命值+1)<br>剑(让当前攻击力+x,没有耐久可以一直用,但是您同时只能携带一把剑)</p><p>本题采取多测,每次独立,角色初始属性,每个怪物的属性和每个房间的道具数量会告诉您,您只需要对每次询问给出一行一个 <code>Yes</code> 或 <code>No</code> 表示勇士能不能到达魔塔的终点房间.</p><p>本题所有测试点公开,测试用例在下面:xx<br>我们还准备了菊花魔塔的游戏,您写程序输出答案提交只要正确也可得分.网页:xx</p><h2 id="输入">输入</h2><p>第一行两个整数,表示子任务($subtask$)编号和测试点个数($T$).</p><p>每个测试点第一行有两个整数n和t,代表房间的数量和终点房间的编号(房间从1开始编号).接下来n行每行7个整数,分别表示表示第i号房间的怪物的生命值(如果是0则该房间没有怪物),攻击力,防御力,该房间的攻击药水的数量,防御药水的数量,生命药水的数量,以及该房间剑的攻击力加成x(如果是0则该房间没有剑).<br>第n+1行是三个整数,表示自己的生命值,攻击力和防御力,您初始时是没有剑的.</p><h2 id="输出">输出</h2><p>一行一个字符串<code>Yes</code>或<code>No</code>,表示该测试点中勇士能不能到达终点房间.</p><h2 id="样例">样例</h2><h3 id="样例输入-1">样例输入#1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 1</span><br><span class="line">4 1</span><br><span class="line">229 113 0 114 514 1919 810</span><br><span class="line">300 200 0 0 0 1 0</span><br><span class="line">300 200 0 0 1 0 0</span><br><span class="line">300 200 0 1 0 0 0</span><br><span class="line">514 114 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出#1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h3 id="样例解释-1">样例解释#1</h3><p>先去4号房间,杀怪后114剩滴生命值,获得1点攻击(药水效果),然后直接去1号最终房间,杀怪后剩1滴血存活,所以输出<code>Yes</code>.</p><h2 id="数据范围-约定">数据范围,约定</h2><p>本题共20个测试点,一共100分,子任务测试数据会下发,<a href="https://jlu.edu.cn">链接</a>.<br>此外我们还准备了测试用例的游戏版本,您也可以通过游玩游戏得到答案,<a href="https://jlu.edu.cn">链接</a></p><p>然后这里是数据表格,题面先过审了再出数据的说,</p><p><code>|$$|$$|$$|$$|||</code></p><h2 id="Flu想说的-这段不算在题面">Flu想说的(这段不算在题面)</h2><p>有一个小问题:我们怎么给部分分??Flu的方向有:</p><ol><li>单测和多测都有(单测只有俩,就是让骗分的)</li><li>有些子任务没防御,有些子任务没有剑,有些子任务没有药水.</li><li>有些子任务人和怪物的值域比较小,(给不会快速计算人怪互砍伤害的人一个机会)</li><li>有些子任务房间数比较少</li></ol><table><thead><tr><th style="text-align:center">子任务编号</th><th style="text-align:center">测试点组数$T$</th><th style="text-align:center">n的范围</th><th style="text-align:center">$\sum n$的范围</th><th style="text-align:center">特殊约定</th><th style="text-align:center">备注(不算题面)</th></tr></thead><tbody><tr><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td><td style="text-align:center">$4$</td><td style="text-align:center">$4$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$2$</td><td style="text-align:center">$5$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$3$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$4$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$5$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$6$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$7$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$8$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$9$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$10$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$11$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$12$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$13$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$14$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$15$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center">$$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$16$</td><td style="text-align:center">$1$</td><td style="text-align:center">$20$</td><td style="text-align:center">$20$</td><td style="text-align:center"></td><td style="text-align:center">这个点的正解是骗分,因为Yes或No最多一次就能看出来,尽量不要让正解在考场上算出来,哈哈</td></tr><tr><td style="text-align:center">$17$</td><td style="text-align:center">$5$</td><td style="text-align:center">$[1,11]$</td><td style="text-align:center">$[1,55]$</td><td style="text-align:center">无</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$18$</td><td style="text-align:center">$20$</td><td style="text-align:center">$[1,11]$</td><td style="text-align:center">$[1,110]$</td><td style="text-align:center">无</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$19$</td><td style="text-align:center">$20$</td><td style="text-align:center">$[1,11]$</td><td style="text-align:center">$[1,110]$</td><td style="text-align:center">无</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">$20$</td><td style="text-align:center">$20$</td><td style="text-align:center">$[1,11]$</td><td style="text-align:center">$[1,110]$</td><td style="text-align:center">无</td><td style="text-align:center"></td></tr></tbody></table><p>这个题就是纯暴搜,dfs的参数会比较多而已.</p><p>主要考察暴搜怎么写(n!就行了),以及如何快速计算人和怪物之间互砍的伤害(这个应该也不难),以及输入(每个房间怪的属性,以及打完了得多少个什么东西,输入略微有一点麻烦),以及清空数组的能力(多测一定要卡掉不清数组的,这不是好习惯).</p><p>多测是因为每次只需要输出Yes或No就行了,要卡死赌运气的,并不是卡复杂度的.</p><p>关于魔塔问题是npc问题的证明:</p><p><a href="https://zhuanlan.zhihu.com/p/153549090">https://zhuanlan.zhihu.com/p/153549090</a></p><hr><h1>B2. ???</h1><h1>B2. ???</h1><p>用做比赛赛题,题面不可公开.</p><hr><h1>E. Neko and P Problems</h1><h1>E. 猫猫与多项式问题</h1><p>猫猫找到了一道暴搜题,祂觉得太简单了,于是摇了摇尾巴把问题丢给了你.</p><p>你有 $n$ 个点和四个集合,你需要把所有点分到四个集合中,每个集合可以为空.我们定义一个集合周长的大小为一个最小的长和宽平行笛卡尔坐标系(直角坐标系)的,包含所有点(点可以在边界上)的最小矩形的周长大小,您需要对点进行合理分配,最小化四个集合周长大小的和.</p><h2 id="输入格式-2">输入格式</h2><p>第一行一个整数 $n$ ,表示有多少个点.<br>第 $2$ 行至第 $n$ 行,一行两个整数 $x_i\quad y_i$ ,代表点 $(x_i,y_i)$ 的坐标.</p><h2 id="输出格式-2">输出格式</h2><p>一行 $n$ 个整数,表示某点所在集合.</p><h2 id="样例输入-输出-2">样例输入/输出</h2><p><strong>输入#1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">0 0</span><br><span class="line">10 0</span><br><span class="line">0 10</span><br><span class="line">10 10</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><p><strong>输出#1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 1</span><br></pre></td></tr></table></figure><p><strong>样例解释</strong> :根据给定的坐标画图,找到周长最小的集合如下.</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/zvlrhsni.png" alt=""></p><h2 id="说明-提示">说明/提示</h2><p>设点数为 $n$ ,值域 $w$ 表示所有点坐标取值都会在 $[-w,w]$ 内,点有可能出现重合情况,集合的矩形只需要包含所有点就行,点在边界以及矩形的长或宽都可以为0.</p><table><thead><tr><th style="text-align:center">测试点编号</th><th style="text-align:center">n的大小</th><th style="text-align:center">值域大小</th></tr></thead><tbody><tr><td style="text-align:center"><code>1</code></td><td style="text-align:center">$5$</td><td style="text-align:center">$10$</td></tr><tr><td style="text-align:center"><code>2</code></td><td style="text-align:center">$6$</td><td style="text-align:center">$10$</td></tr><tr><td style="text-align:center"><code>3</code></td><td style="text-align:center">$7$</td><td style="text-align:center">$10^9$</td></tr><tr><td style="text-align:center"><code>4</code></td><td style="text-align:center">$8$</td><td style="text-align:center">$10^9$</td></tr><tr><td style="text-align:center"><code>5</code></td><td style="text-align:center">$9$</td><td style="text-align:center">$10^9$</td></tr><tr><td style="text-align:center"><code>6</code></td><td style="text-align:center">$10$</td><td style="text-align:center">$10^9$</td></tr><tr><td style="text-align:center"><code>7</code></td><td style="text-align:center">$10$</td><td style="text-align:center">$10^9$</td></tr><tr><td style="text-align:center"><code>8</code></td><td style="text-align:center">$15$</td><td style="text-align:center">$10^9$</td></tr><tr><td style="text-align:center"><code>9</code></td><td style="text-align:center">$15$</td><td style="text-align:center">$10^9$</td></tr><tr><td style="text-align:center"><code>10</code></td><td style="text-align:center">$16$</td><td style="text-align:center">$10^9$</td></tr><tr><td style="text-align:center"><code>11</code></td><td style="text-align:center">$16$</td><td style="text-align:center">$10^9$</td></tr><tr><td style="text-align:center"><code>12</code></td><td style="text-align:center">$20$</td><td style="text-align:center">$10^9$</td></tr><tr><td style="text-align:center"><code>13</code></td><td style="text-align:center">$20$</td><td style="text-align:center">$10^9$</td></tr><tr><td style="text-align:center"><code>14</code></td><td style="text-align:center">$100$</td><td style="text-align:center">$10$</td></tr><tr><td style="text-align:center"><code>15</code></td><td style="text-align:center">$100$</td><td style="text-align:center">$20$</td></tr><tr><td style="text-align:center"><code>16</code></td><td style="text-align:center">$100$</td><td style="text-align:center">$50$</td></tr><tr><td style="text-align:center"><code>17</code></td><td style="text-align:center">$100$</td><td style="text-align:center">$10^9$</td></tr><tr><td style="text-align:center"><code>18</code></td><td style="text-align:center">$100$</td><td style="text-align:center">$10^9$</td></tr><tr><td style="text-align:center"><code>19</code></td><td style="text-align:center">$100$</td><td style="text-align:center">$10^9$</td></tr><tr><td style="text-align:center"><code>20</code></td><td style="text-align:center">$100$</td><td style="text-align:center">$10^9$</td></tr></tbody></table><p><strong>注意</strong> :本题采用 <code>Special Judge</code> 和 <em>动态赋分制</em> ,您的程序会在评测后得到一个分数,代表您的程序得到的最小周长.我们会使用与第一名的周长进行比较的公式进行评估,您会得到一个得分,这里还没写完…</p><p>参考程序(你可以使用参考程序提交并得分,只是后面会被比下去):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/atsc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;1 &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料-附件">参考资料(附件)</h2><p>Neko_and_NPC_Problems.zip</p><hr><h1>出题者语</h1><p>暴搜 $O(4^n)$<br>枚举值域 $O(nw^{12})$ (枚举三个正方形的值域,然后剩下的归到最后的集合里面,On检查,加一块就是这个)<br>模拟退火 $O(玄学)$ 答案玄学,快速剪枝( <s>青云杯退火大赛</s> )</p><p><strong>有一个不太好的地方是,因为四个集合,计算机速率达不到,枚举值域虽然复杂度在值域小的时候很可以但是这个时候人类智慧会杀出来的,也许3个集合会更好?但是这样的话暴搜又会杀出来…所以枚举值域只能结合人类智慧一起做.</strong></p><p><strong>还有一个问题,这个题的答案搞不出来的情况下,模拟退火打的怎么样?别到时候退火变成除了暴搜出的正解外吊打选手的程序(包括标算,虽然可能没有标算),一定要卡死模拟退火,至少别让模拟退火太逆天…</strong></p><table><thead><tr><th style="text-align:center">测试点编号</th><th style="text-align:center">点的规模</th><th style="text-align:center">值域规模</th><th style="text-align:center">预期解法</th><th style="text-align:center">描述一下图的性质</th></tr></thead><tbody><tr><td style="text-align:center"><code>1</code></td><td style="text-align:center">$5$</td><td style="text-align:center">$10$</td><td style="text-align:center">白给,因为至少四个集合,所以怎么着也得五个起拍</td><td style="text-align:center">特殊数字(114514之类的)</td></tr><tr><td style="text-align:center"><code>2</code></td><td style="text-align:center">$6$</td><td style="text-align:center">$10$</td><td style="text-align:center">白给</td><td style="text-align:center">随机</td></tr><tr><td style="text-align:center"><code>3</code></td><td style="text-align:center">$7$</td><td style="text-align:center">$10^9$</td><td style="text-align:center">人类智慧</td><td style="text-align:center">随机</td></tr><tr><td style="text-align:center"><code>4</code></td><td style="text-align:center">$8$</td><td style="text-align:center">$10^9$</td><td style="text-align:center">开始暴搜/人类智慧</td><td style="text-align:center">随机</td></tr><tr><td style="text-align:center"><code>5</code></td><td style="text-align:center">$9$</td><td style="text-align:center">$10^9$</td><td style="text-align:center">开始暴搜/人类智慧</td><td style="text-align:center">随机</td></tr><tr><td style="text-align:center"><code>6</code></td><td style="text-align:center">$10$</td><td style="text-align:center">$10^9$</td><td style="text-align:center">暴搜</td><td style="text-align:center">随机</td></tr><tr><td style="text-align:center"><code>7</code></td><td style="text-align:center">$10$</td><td style="text-align:center">$10^9$</td><td style="text-align:center">暴搜</td><td style="text-align:center">随机</td></tr><tr><td style="text-align:center"><code>8</code></td><td style="text-align:center">$15$</td><td style="text-align:center">$10^9$</td><td style="text-align:center">打表</td><td style="text-align:center">随机</td></tr><tr><td style="text-align:center"><code>9</code></td><td style="text-align:center">$15$</td><td style="text-align:center">$10^9$</td><td style="text-align:center">打表</td><td style="text-align:center">随机</td></tr><tr><td style="text-align:center"><code>10</code></td><td style="text-align:center">$16$</td><td style="text-align:center">$10^9$</td><td style="text-align:center">人类智慧+暴搜</td><td style="text-align:center">随机</td></tr><tr><td style="text-align:center"><code>11</code></td><td style="text-align:center">$16$</td><td style="text-align:center">$10^9$</td><td style="text-align:center">人类智慧+暴搜</td><td style="text-align:center">随机</td></tr><tr><td style="text-align:center"><code>12</code></td><td style="text-align:center">$20$</td><td style="text-align:center">$10^9$</td><td style="text-align:center">人类智慧+暴搜</td><td style="text-align:center">随机</td></tr><tr><td style="text-align:center"><code>13</code></td><td style="text-align:center">$20$</td><td style="text-align:center">$10^9$</td><td style="text-align:center">人类智慧+暴搜</td><td style="text-align:center">随机</td></tr><tr><td style="text-align:center"><code>14</code></td><td style="text-align:center">$100$</td><td style="text-align:center">$10$</td><td style="text-align:center">人类智慧+枚举值域</td><td style="text-align:center">随机(事实上也随机不到哪去,值域太小了)</td></tr><tr><td style="text-align:center"><code>15</code></td><td style="text-align:center">$100$</td><td style="text-align:center">$20$</td><td style="text-align:center">人类智慧+枚举值域</td><td style="text-align:center">随机(事实上也随机不到哪去,值域太小了)</td></tr><tr><td style="text-align:center"><code>16</code></td><td style="text-align:center">$100$</td><td style="text-align:center">$50$</td><td style="text-align:center">人类智慧+枚举值域</td><td style="text-align:center">青云杯标识(正解是通过把图像竖着或者横着劈成四瓣,省掉中间的间隙的周长)</td></tr><tr><td style="text-align:center"><code>17</code></td><td style="text-align:center">$100$</td><td style="text-align:center">$10^9$</td><td style="text-align:center">人类智慧</td><td style="text-align:center">(点的分布会很密集,但是四个集合之间离的很远)四坨点聚在四周</td></tr><tr><td style="text-align:center"><code>18</code></td><td style="text-align:center">$100$</td><td style="text-align:center">$10^9$</td><td style="text-align:center">人类智慧</td><td style="text-align:center">三坨,长成两个点和一个8的样子</td></tr><tr><td style="text-align:center"><code>19</code></td><td style="text-align:center">$100$</td><td style="text-align:center">$10^9$</td><td style="text-align:center">不可做,依赖玄学剪枝(模拟退火???)</td><td style="text-align:center">随机,可能有重合点</td></tr><tr><td style="text-align:center"><code>20</code></td><td style="text-align:center">$100$</td><td style="text-align:center">$10^9$</td><td style="text-align:center">不可做,依赖玄学剪枝(模拟退火???)</td><td style="text-align:center">随机,可能有重合点</td></tr></tbody></table><hr><p>文件 <code>E_checker.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;testlib.h&quot;</span></span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> infin=<span class="number">2147483647</span>;</span><br><span class="line"><span class="comment">//答案文件和输入文件保持一致,因为其实这个题本没有答案的( )</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span>&#123;</span><br><span class="line"><span class="built_in">setName</span>(<span class="string">&quot;E_checker&quot;</span>);</span><br><span class="line"><span class="built_in">registerTestlibCmd</span>(argc,argv);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mx1x=-infin,mn1x=infin,mx1y=-infin,mn1y=infin,cnt1=<span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mx2x=-infin,mn2x=infin,mx2y=-infin,mn2y=infin,cnt2=<span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mx3x=-infin,mn3x=infin,mx3y=-infin,mn3y=infin,cnt3=<span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mx4x=-infin,mn4x=infin,mx4y=-infin,mn4y=infin,cnt4=<span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n=ans.<span class="built_in">readInt</span>(),tmp,tmpx,tmpy;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">tmp=ouf.<span class="built_in">readInt</span>();</span><br><span class="line">tmpx=ans.<span class="built_in">readInt</span>();</span><br><span class="line">tmpy=ans.<span class="built_in">readInt</span>();</span><br><span class="line"><span class="keyword">switch</span>(tmp)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">cnt1++;</span><br><span class="line">mx1x=std::<span class="built_in">max</span>(mx1x,tmpx);</span><br><span class="line">mn1x=std::<span class="built_in">min</span>(mn1x,tmpx);</span><br><span class="line">mx1y=std::<span class="built_in">max</span>(mx1y,tmpy);</span><br><span class="line">mn1y=std::<span class="built_in">min</span>(mn1y,tmpy);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">cnt2++;</span><br><span class="line">mx2x=std::<span class="built_in">max</span>(mx2x,tmpx);</span><br><span class="line">mn2x=std::<span class="built_in">min</span>(mn2x,tmpx);</span><br><span class="line">mx2y=std::<span class="built_in">max</span>(mx2y,tmpy);</span><br><span class="line">mn2y=std::<span class="built_in">min</span>(mn2y,tmpy);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">cnt3++;</span><br><span class="line">mx3x=std::<span class="built_in">max</span>(mx3x,tmpx);</span><br><span class="line">mn3x=std::<span class="built_in">min</span>(mn3x,tmpx);</span><br><span class="line">mx3y=std::<span class="built_in">max</span>(mx3y,tmpy);</span><br><span class="line">mn3y=std::<span class="built_in">min</span>(mn3y,tmpy);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">case</span> <span class="number">4</span>:&#123;</span><br><span class="line">cnt4++;</span><br><span class="line">mx4x=std::<span class="built_in">max</span>(mx4x,tmpx);</span><br><span class="line">mn4x=std::<span class="built_in">min</span>(mn4x,tmpx);</span><br><span class="line">mx4y=std::<span class="built_in">max</span>(mx4y,tmpy);</span><br><span class="line">mn4y=std::<span class="built_in">min</span>(mn4y,tmpy);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">default</span>:&#123;</span><br><span class="line"><span class="built_in">quitf</span>(_wa,<span class="string">&quot;%lld&quot;</span>,inf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt1!=<span class="number">0</span>)res+=(mx1x-mn1x+mx1y-mn1y)&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt2!=<span class="number">0</span>)res+=(mx2x-mn2x+mx2y-mn2y)&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt3!=<span class="number">0</span>)res+=(mx3x-mn3x+mx3y-mn3y)&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt4!=<span class="number">0</span>)res+=(mx4x-mn4x+mx4y-mn4y)&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">quitf</span>(_ok,<span class="string">&quot;%lld&quot;</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1>E2. 九井棋</h1><h1>E2. Tic-Tac Toe</h1><p>选手两两之间下九井棋,比拼谁赢的多的这么一个题,对评测姬要求比较高.</p><hr><h1>以及一些没有实现的idea</h1><p>因为能力不足或时间不够,没有将想法落地的ideas.</p><ol><li><p>(交互题)给一个01串,选手任意对字符串进行编码,或者进行计算,然后我们进行破坏之后再还给选手,看是否能够还原,还原率是多少,涉及到很复杂的差错控制编码:喷泉码,李德所罗门码(二维码用的那个,能达到30%纠错率)</p></li><li><p>手写一个malloc看谁性能最好,受制于评测姬是Linux只好作罢.</p></li><li><p>Markov Algorithm Online(整一个类似旷野大计算类似的东西)</p></li><li><p>因为程序最终是要被编译成机器码执行的,所以我们让选手使用汇编去实现一个类似&quot;旷野大计算&quot;的题,然后转成机器码交上去,也就是说选手需要提交一堆数字,然后由SPJ负责把数字转成程序运行,不可以出现任何数字空格以外的输入,idea来自<a href="https://www.bilibili.com/video/BV16P4y1C7T9">这个视频</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;无论如何,我不会再出题了.&lt;/strong&gt; 出题得不到什么奖励,出不好还会被骂,出题的时候要考虑各种情况(比如正解,代码长度,时限到底开多少,部分分怎么给,怎么卡掉非正解,可能有什么做法能草过去),还有人不干活,团委整天拖报销咋办…&lt;/p&gt;
&lt;p&gt;所以这篇</summary>
      
    
    
    
    <category term="ACM" scheme="https://narafluorine.github.io/categories/ACM/"/>
    
    
    <category term="Contest" scheme="https://narafluorine.github.io/tags/Contest/"/>
    
    <category term="TsingyunCup" scheme="https://narafluorine.github.io/tags/TsingyunCup/"/>
    
  </entry>
  
  <entry>
    <title>字符串总结</title>
    <link href="https://narafluorine.github.io/2024/12/24/10033_%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://narafluorine.github.io/2024/12/24/10033_%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2024-12-24T13:03:22.000Z</published>
    <updated>2025-04-25T19:00:40.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KMP弊端">KMP弊端</h2><p>因为kmp对cache不友好,也较难使用simd(单指令多数据的并行计算)优化,而且实际上的字符串很难跑到O(nm),所以实践上朴素算法可能更快.</p><h1>自动机科技</h1><p>自动机是一个确定的数学模型,对于信号序列(字符串)的某种性质给出是或不是的回答(确定有限状态自动机).然后自动机上每个节点都会有对了如何错了如何的判定,所以自动机实质上是一张有向图.</p><h2 id="AC自动机及其魔改">AC自动机及其魔改</h2><p>AC自动机的板子是计算多个字符串在一个字符串的匹配情况.最裸的板子是求多个小串在一个一个长串之中各自出现了多少次,时间复杂度 $O(|T|+\sum|S|)$ ,然而肯定会有魔改的版本…</p><h2 id="子序列自动机-简单字符集">子序列自动机(简单字符集)</h2><p>快速判定某些字符串t是不是母字符串s的子串, $O(s+\sum t)$ .</p><p>就是一个dp.设字符集为S,开一个dp[len][|S|]表示当前len的位置的下一个S的字符在哪里,从后往前推复杂度O(lenS).</p><p>$$next[i][j]=next[i+1][j],w[i+1]\neq j \\ next[i][j]=i+1,w[i+1]=j$$</p><h2 id="子序列自动机-复杂字符集">子序列自动机(复杂字符集)</h2><p>上面的子序列的dp和字符集长度挂钩,如果S很大时间空间都会爆,考虑更优解法.</p><p>发现nxt只会每次更新只会改一个点,所以能够使用主席树优化,具体地,对值域开一个桶,对字符串长度开根的长度,然后添一个log进行建树和匹配.</p><p><strong>另解</strong> :使用vector桶存值域,然后值域二分找到下一个位置,然后跳转即可,复杂度依然是log.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;KMP弊端&quot;&gt;KMP弊端&lt;/h2&gt;
&lt;p&gt;因为kmp对cache不友好,也较难使用simd(单指令多数据的并行计算)优化,而且实际上的字符串很难跑到O(nm),所以实践上朴素算法可能更快.&lt;/p&gt;
&lt;h1&gt;自动机科技&lt;/h1&gt;
&lt;p&gt;自动机是一个确定的数学模型,对</summary>
      
    
    
    
    <category term="ACM" scheme="https://narafluorine.github.io/categories/ACM/"/>
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/tags/OTH/"/>
    
  </entry>
  
  <entry>
    <title>3D打印,建模,工学</title>
    <link href="https://narafluorine.github.io/2024/12/24/30012_3D%E6%89%93%E5%8D%B0%E5%8F%8A%E5%BB%BA%E6%A8%A1/"/>
    <id>https://narafluorine.github.io/2024/12/24/30012_3D%E6%89%93%E5%8D%B0%E5%8F%8A%E5%BB%BA%E6%A8%A1/</id>
    <published>2024-12-24T13:03:22.000Z</published>
    <updated>2025-08-29T06:52:53.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3D打印文件格式有哪些">3D打印文件格式有哪些?</h2><p><code>stl</code> <code>3mf</code> <code>amf</code> <code>obj</code> 等.</p><h2 id="ref">ref</h2><p>PLA需要后处理层纹，打磨有粗磨、湿磨（可以用电动威克斯老鼠砂打磨大面积）、刷丙酮亚克力胶、上牙膏灰补土、水补，再反复精细打磨补喷、喷漆上色、上水性保护器比如易刷刷，处理完表面其实就是高分子树脂了，面材结实而里面是PLA还是别的什么一点都不重要了，相当于鸡蛋白外面挂一层牢固的鸡蛋壳。不拿去打砸，放个十来年应该一点问题没有。还想进一步，你可以翻模，搞AB树脂或硬石膏长久保存。</p><h2 id="AMS怎么省钱封箱">AMS怎么省钱封箱?</h2><p>使用自带的塑料袋加扎带即可.</p><h2 id="老三样">老三样?</h2><p>打磨 补土 电镀</p><h2 id="工件向上最大倾斜度">工件向上最大倾斜度</h2><p>还没测.</p><h2 id="打印件六边形悬垂处有单向毛刺-怎么回事">打印件六边形悬垂处有单向毛刺,怎么回事?</h2><p>可能是润滑轴不到位导致,或降低打印速度,或加强散热风扇风速或烘干耗材</p><h2 id="牌子">牌子</h2><p>兰博(Flu用的)<br>Jayo(听说是三绿换牌子走的低端市场,应该挺好使的)</p><h2 id="用平面打印板时出现齐整的鱼鳞纹-底面-是什么事情">用平面打印板时出现齐整的鱼鳞纹(底面)是什么事情?</h2><p>没调平好.</p><h2 id="工件名称">工件名称??</h2><p>方钢 方管</p><h2 id="另一种玩法">另一种玩法</h2><p>在连接分件的时候用电烙铁压一圈小金属条或者订书钉进去,然后再补土刮腻子打磨喷涂</p><h2 id="无AMS多色打印">无AMS多色打印</h2><p>原理:可以把工件纵向切开,中间插入缓冲层,然后换料,然后继续打印就可以实现无AMS的多色打印.</p><p>然而实操的时候有一个坑就是,右边能拖动的条能插暂停层的是当前准备打第几层, <strong>但是</strong> 左边的模型显示是打完第几层之后的状态.比如你要打一个名字扣,板子10层,名字10层凸显在上面,你需要在第11层加暂停层.</p><h2 id="打印板">打印板</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ny20ngui.png" alt=""></p><p>上面光鲜亮丽的那个板子会因为光栅效应导致打印出来的物品也可以让光色散,底座五颜六色反光的效果.</p><h2 id="塑钢线">塑钢线</h2><p>塑钢线是一种农用物品,用于户外拉遮阳棚等用的东西,材质是PE,听说能够用于3D打印,Flu买来试验一下,(59元是9斤,这种13元一千克的耗材如果能成功打印工件的话直接耗材自由了),所以Flu必须实验.</p><p>首先,因为白色塑钢线透明,所以不能用拓竹的自动流量校准.</p><p>打印速度一定要慢,群U说最大速度体积是8.</p><p>为什么有的时候能挤出有的时候不能挤出?</p><h3 id="为什么黑色塑钢线不能打印">为什么黑色塑钢线不能打印?</h3><p>网上说,黑色塑钢线会粘床,严重的会清理不干净废板子,因为黑色是室外用的,添加抗紫外线耐晒抗老化的东西,并不是垃圾料.</p><h2 id="打印浮雕">打印浮雕</h2><p>先转成灰度图,然后上传到网站转成stl,然后直接打印就行了.</p><p>注意有些人物的笑容会因为灰度不够被抹掉,这个时候一定要看清楚会不会被抹掉…(比方说红叶这个浮雕就是笑容不明显然后打印出来的笑容甚至断开成两半了…)</p><p>可以使用makerlab或者<a href="https://3dp.rocks/">这个网站</a>在线转浮雕.</p><h2 id="克重数据">克重数据</h2><p>对于Flu PETG这种材质,密度基本准确.记录表:</p><table><thead><tr><th style="text-align:center">预估重量(拓竹切片软件,g)</th><th style="text-align:center">实际重量(g)</th></tr></thead><tbody><tr><td style="text-align:center">109.94</td><td style="text-align:center">108.3</td></tr></tbody></table><p>一卷兰博全新耗材重量(1kg,刚开封,算上卷的重量):1167.0g<br>兰博空盘重量:160.0g</p><h2 id="Pending">Pending</h2><p>竹子CHT三孔铬锆铜喷嘴0.2mm(一个喷嘴才三块钱).</p><p>耗材种类:<br>pla petg tpu (abs asa  pa pc) pet</p><p>激光金属3d打印  cnc</p><blockquote><p>据说耗材生意十分赚钱,除了竹子价格死硬,其他厂商都喜欢搞价格歧视,某些时间可能优惠幅度巨大,日常高价收割耗材不敏感客户,优惠时收割价格敏感客户,最后在特殊渠道收割铁公鸡客户,一定要注意,价格是由供需决定的,而不是成本.</p></blockquote><p>BMCU多色系统</p><h2 id="一种论调">一种论调</h2><p>水分在高分子熔融加工中，虽然通常是不利因素，会使材料降解，变脆等等。但是从另一角度来说，水分可以作为一种“增塑剂&quot;。水分可以削弱聚合物分子间的作用力，一定程度上降低熔融温度和玻璃化温度，减小熔体的粘度。说人话，吸潮的耗材在相同温度流量参数下，具有更高的流动性，实际挤出量往往更高，可以称一下打印样条的质量，看看吸潮的耗材打印的样条是不是比干燥的耗材更重。然后烘干后再秤一下.看看重量变化大不大，如果变化不大，就能够说明挤出了更多的耗材，水分的&quot;恶化&quot;作用和&quot;增速作用&quot;达到了一种抵消，所以结果差距不大。另外就是这几种材料吸湿率总体不高，应该测尼龙,那是真要命</p><h2 id="耗材干燥">耗材干燥</h2><p>干燥剂选项:</p><ol><li>分子筛干燥剂(大约3~5元每斤)</li><li>变色硅胶干燥剂</li><li>生石灰(灰太大)</li></ol><p>设备选项:</p><ol><li>大的带密封的盒子</li><li>精密仪器干燥柜</li><li>碗筷消毒柜</li></ol><p>耗材要求:</p><ol><li>PA类的肯定要放干燥箱,而且是开箱立马放干燥箱(最好保存湿度15%以下)</li></ol><h2 id="如何拆支撑">如何拆支撑</h2><p>你就是缺尖嘴钳和锉刀,别的没了.</p><h2 id="为什么XX">为什么XX?</h2><ol><li>为什么会听到咔咔的声音?是打印机撞到模型了吗?</li></ol><p>那是打印机打较大模型时,模型中间会凉下来,然后支撑脱落时发出的声音.</p><ol start="2"><li>支撑为什么一掰就掉</li></ol><p>因为支撑是一整根完整的空柱子,叠起来长得像一棵树.支撑在与模型连接的地方是一堆点,减小在这里的强度,所以支撑很好掰,掰掉的地方会留下点作为痕迹,用砂纸打磨也许能做好.</p><ol start="3"><li>为什么材料还没打几层就破了个大洞?是不是局部受热不均?</li></ol><p>答:你没有洗板子,之前的油沾到了上面导致不粘板子,然后就导致打印一层比一层偏最后出现大洞.所以 <strong>推荐每次打印完取下来模型就洗一次板子,保证下次打印的成功率</strong> .还有可能是耗材时间长了.</p><ol start="4"><li>为什么不着床!!!(翘边,炒面)</li></ol><p>因为热床不粘.对于纹理PIE板使用肥皂洗一下,然后再用无纺布擦干(注意不能是纸巾,会残留碎屑在上面导致打印失败),无纺布可以带酒精也可以不带.不粘平台解决办法1是好好洗洗,2是调节喷头距离,3就是用胶棒</p><ol start="5"><li>硅胶干燥剂的活性恢复方法:建议4次回温之后扔掉硅胶.放入铝箔盒中放到烤箱中100度,每5min拿出来观察硅胶情况并搅拌,约30min,直到不含水分,或者暴晒直到颜色回来.</li></ol><h2 id="上色">上色</h2><p>三种方案:</p><ol><li>直液式丙烯马克笔(先上色,再平涂,最后用光油固定)</li><li>补土打底+手涂水性漆(Flu选择这个,星影和酋长大陆,)+湿盘(水+烘培油纸,).</li><li>丝绸金(这种本身颜色足够鲜艳的)PLA</li></ol><h1>灵感收集</h1><p>买了打印机之后总要打点什么…所以需要收集灵感,免得打印机过度吃灰导致出问题.</p><h2 id="通配符类">通配符类</h2><p>温度塔:看拉丝情况决定打印温度的<br>回抽塔:看拉丝情况决定回抽长度最小是多少的<br>针织模型:什么都有,顶部经常出现扎手的刺,此时需要调整回抽速度或回抽高度(一般是调高点),温度也要适当调一下.针织模型属于单色打也很好看的东西,比较理想.</p><h2 id="中看不中用类">中看不中用类</h2><p>福字挂件,窗花剪纸<br>透明材料打印海豚(内嵌的)(要看透明PETG打印技巧wiki)<br>六边形搁物架,用嵌子卡在两个中间保证不散.<br>任意浮雕,先扔ps里转灰度图,然后扔<br>任意名字挂件,简单的图片</p><h2 id="实用类">实用类</h2><p>印章()<br>发夹(多色无需ams)</p><h2 id="如何变现">如何变现?</h2><ol><li>拓竹发布模型收获赞助变现</li><li>扎根行业提出解决方案等别人复刻</li><li>卷代打</li><li>摆地摊,</li></ol><h1>色彩</h1><ol><li>绿色士兵小人</li><li></li></ol><h1>Blender建模教程</h1><hr><p>(听的KurTips网课,简单学了一手)</p><h3 id="键位">键位</h3><p>鼠标中键:挪动视角,观察空间<br>Shift+鼠标中键:移动空间(右上角小手)<br>滚轮:缩放空间(右上角的放大镜)<br>右上角的三色轴拖动旋转:转动空间<br>摄像机视图:右上角摄像机<br>正交视图:右上角网格</p><p>删除物体:Del<br>恢复操作:Ctrl+Z<br>新建物体:Shift+a<br>移动物体:G(这个状态按xyz会沿着对应方向移动),退出状态是左键<br>缩放物体:S(这个状态按xyz会沿着对应方向移动),退出状态是左键<br>旋转物体:R(按xyz会沿着对应方向移动,默认是你的视图方向旋转),退出状态是左键<br>隐藏物体:H(Shift+H会隐藏所有没有被选中的物体,看右上角场景那里的小眼睛)<br>恢复某些性质:Alt+X(加S撤销缩放,加R撤销旋转,加G撤销位移(回到原先的位置了))<br>复制物体:Shift+D移动并复制(复制并移动是两步,撤销的时候会发现其实已经复制出来了)</p><p>选中:分为框选(不可调位置)和单选(随便调位置)还有刷选(快捷键C,刷到哪里选择哪里)和套索(从鼠标末端到鼠标起点的一个闭合平面),在鼠标框那里长按调整,注意要选到物体中心才算</p><p>切换视图:单击XYZ轴可以变换成单方向的视图.<br>还有一种方法: <code>~</code> 进入Tab目录,显示当前的视图<br>小键盘福利:<br>1正视图3右视图7顶视图9把当前视图反过来<br>2468是上下左右方向的微调(一次15度)</p><p>面板:每一个面板都可以转换成其他的操作面板.面板转换在左上角.可替换可拆分,鼠标在窗口四角出现加号的时候可以拉,往别的窗口拉会合并,往自己的窗口拉会分裂.</p><p>搞乱了可以在上方加号新建布局恢复.<br>Ctrl+Space可以最大化当前面板,再按一次恢复.</p><p>键盘上的/斜杠:按一下可以让选中的物体单独显示,再按一下退出.</p><p>0:进入摄像机视图</p><p>摄像机快速对正:在摄像机视图按n勾选锁定摄像机,然后就可以直接在摄像机视图调整了.</p><p>blender有两个渲染器,一个叫eevee,一个叫cycles.eevee是实时渲染,快,相对不占资源,缺点是没有光线追踪,很多光线阴影细节不佳,需要额外更多参数辅助.cycles更加逼真高级,能模拟出物理世界里非常细节的光线阴影,缺点是慢,比eevee慢10倍以上.`</p><h3 id="游标">游标</h3><p>游标在哪里,新建的东西就会出现在哪里.</p><p>移动游标:选中工具下面是游标工具,点这个工具移动即可.<br>或者正常的选中模式,Shift+右键 也可以移动游标.<br>Shift+C 游标回到原点.</p><p>游标可以当成轴心点用.把物体的轴心点换成游标的话,就可以绕着游标进行转动.</p><h3 id="中心点">中心点</h3><p>每个物体都会有一个中心点,记录物体的信息.</p><p>右上角选项可以选择&quot;仅影响原点&quot;,然后挪动原点和物体的相对位置.</p><p>立方体的原点默认在中心,这个时候伸长是原点向两边伸长的.</p><h3 id="物体移动-轴心点">物体移动,轴心点</h3><p>移动模式下按Ctrl有吸附功能</p><p>轴心点可以变成边界框中心,质心,各自的中心,以及活动元素.活动元素是多选物体时最后被选中的元素.</p><h3 id="局部坐标">局部坐标</h3><p>和世界坐标不一样的,旋转跟着物体转的这么一个坐标.</p><p>如何调用局部坐标?只要按两次坐标轴就可以在全局和局部坐标中切换了.</p><h1>建模篇</h1><p>模型编辑模式:Tab切换物体模式.<br>按Tab同时移动鼠标会进入丙菜单,出现一个物体的好多种模式.</p><p>选择点线面:大键盘123分别对应,默认是点.(鼠标切换那里在左上角),按Shift可以同时选点线面</p><p>鼠标选择:按w快速切换选中规则,框选刷选,etc.<br>框选是b,刷选是c,注意快捷键进入刷选状态时经常出现其他键都按不了,只能刷选,这个时候按住鼠标中键擦除刚刚选中的点,退出按esc或者右键在空白位置</p><p>反选:选中一块点,按ctrl+i反选这个物体其他的所有点<br>按shift可以选择一些不连续的点,按ctrl可以把两个点之间的最短路径连起来.</p><p>选择相连元素:选一个点按L可以选择所有与这个点相连的点(连什么地方要把鼠标走到那里)(是以四边形计算的,有的时候三角面跨不过去,要用鼠标选)</p><p>选择一个圈(环):选择一个点按alt双击想选的环(横向,纵向,etc)</p><p>随机选择:鼠标防选择上随机选择一些点线面</p><p>扩大选择:按ctrl++(小键盘)或ctrl±(小键盘)可以扩大选择范围或者缩小</p><p>透视模式:alt+Z切换,这个时候可以选中背面的点</p><p>点线面操纵:g移动r旋转s缩放</p><p>删除点线面:选择某些东西按x选择删除哪些东西</p><p>删点:点消失了,和点直接相连的边也消失了,和面直接相连的面也消失了<br>删边:边消失了,和面直接相连的面也消失了<br>删面:面消失了</p><p>融并:会删东西,但是剩下的会缝起来,不会出现一个大洞</p><h3 id="面的法向">面的法向</h3><p>到右上角找到面朝向打开即可看到一个面的正反,蓝色是正面红色是反面</p><p>按shift+n,选一下内向就可以转换朝向.</p><p>法线:面法线垂直于面(浅蓝),顶点法线垂直于切线方向(深蓝),拆分法线(浅粉色,用的比较少,游戏开发会自定义法线)</p><h2 id="建模操作">建模操作</h2><p>左侧边栏:笔 标注,注释<br>测量工具:量工件多大的.<br>新建工具:快速拉出来一个新模型</p><p>挤出:先切换到面模式,然后e挤出一个面(挤出并移动)s缩小(这个面),点挤出是一个面(快速挤出是ctrl+右键),线挤出是一个面.注意e是挤出冰移动,撤销的时候注意一下两个面重合<br>挤出流形:避免重复边的问题.<br>沿法线挤出:rt.<br>单独挤出:立方体切片之后选择多个面挤出会连在一起(一起挤出的),然后单独挤出不会出现这种情况,用于做手指</p><p>向内挤出:i(这个不是挤出并移动)</p><p>倒角(把角磨圆):ctrl+B拉出来一个角(边模式),滑动鼠标滚轮增加细分面(更圆滑)</p><p>环切(腰斩):从中间截断整个物体(ctrl+r),滑动滚轮可以增加或者减少段数点一下确定段数,再点一下确定位置,右键可以自动吸附在最中间的地方</p><p>合并:选择两个点,m合并到中间,按距离的意思是如果两个点的距离小于多少就合并.</p><p>断开:v,一个点要有三条边支持,然后断开的时候就是和别的面不粘了.</p><p>填充:alt双击环选一整个环,然后按住f这个面就被封住了.(被填充了)</p><p>右键细分:可以增加一个边.</p><p>切刀:k进入切刀模式,右键或者空格退出,切刀可以把物体切成好多个面.</p><p>桥接:ctrl+E,只有一个物体才能够桥接.两个物体变一个物体用ctrl+j.</p><p>分离:p,先进透视,选中想分离的物体,按p(这个时候一个物体会变成两个物体…)</p><p>三角面转四边面:Alt+J,调整max shape angle(uv图不变)</p><p><strong>尽量不要在物体模式下缩放,在编辑模式下缩放.如果物体模式缩放了,记得应用下这个缩放.</strong></p><h2 id="修改器">修改器</h2><p>好处是不破坏模型,而且可以叠加多个.</p><p>大概就是,有很多个修改器,可以实现不对模型进行改动的前提下进行渲染和建模,方便撤回和调整.</p><h2 id="ps…">ps…</h2><p>Flu的Blender用起来会有电流声…不知道是什么原因,挪动鼠标能听到滋滋滋的声音…现在的显卡都这么猛的吗???还是我电脑要完了???</p><h1>工学</h1><p>也许名字叫电子电路基础…</p><h2 id="断桥铝">断桥铝</h2><p>铝制窗户框,可以隔热.</p><h2 id="焊锡松香配方">焊锡松香配方</h2><p>25%松香溶解到75%的(无水)酒精当中</p><h2 id="胶水">胶水</h2><p>ab胶(丙烯酸基实用性强,用3m 乐泰 天山 回天) 补土 uv胶 502 补鞋胶 油性胶 5800胶水</p><h2 id="安装床帘经验总结">安装床帘经验总结</h2><ol><li>尽量避免在304不锈钢上打孔,非常难开,半天只有一个小眼</li><li>尽量避免在普通钢铁上打孔,尝试使用纸张填充的方法给杆子限位.</li></ol><h2 id="WD-40-替换">WD-40 替换</h2><p>CRC5-56</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;3D打印文件格式有哪些&quot;&gt;3D打印文件格式有哪些?&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;stl&lt;/code&gt; &lt;code&gt;3mf&lt;/code&gt; &lt;code&gt;amf&lt;/code&gt; &lt;code&gt;obj&lt;/code&gt; 等.&lt;/p&gt;
&lt;h2 id=&quot;ref&quot;&gt;ref&lt;/h2&gt;
&lt;</summary>
      
    
    
    
    <category term="TECH" scheme="https://narafluorine.github.io/categories/TECH/"/>
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/tags/OTH/"/>
    
  </entry>
  
  <entry>
    <title>概率</title>
    <link href="https://narafluorine.github.io/2024/12/17/10018_%E6%A6%82%E7%8E%87/"/>
    <id>https://narafluorine.github.io/2024/12/17/10018_%E6%A6%82%E7%8E%87/</id>
    <published>2024-12-17T05:42:45.000Z</published>
    <updated>2025-08-03T01:43:58.565Z</updated>
    
    <content type="html"><![CDATA[<p>在这里放一些常见的概率模型.</p><ol><li>如果某件事情发生的概率是p,那么期望进行多少次试验才能让p发生的次数是1/p.</li></ol><h2 id="模式匹配问题">模式匹配问题</h2><p>猴子每次会在键盘上随机敲击一个字母,请问出现指定字符串s的期望敲击次数是多少?</p><blockquote><p>结论:期望次数是<br>$$\sum V^l$$<br>其中V表示值域大小(所有字母的集合大小),l表示字符串所有前缀等于后缀的长度.<br>如 <code>ABRACADABRA</code> ,答案是 $26^{11}+26^{4}+26$ ,因为前缀A和后缀A匹配,前缀ABRA和后缀ABRA匹配,整个字符串是前后缀匹配的.</p></blockquote><p>(引用)这个结论乍一看违反直观，为什么首次出现正正和正反的期望次数不相同？这是因为，模式等待中途失败时，模式的头部和尾部重合越多，就越容易从头再来；而重合的越少，就越容易从中间继续。在得到正面的情况下，接下来等待正正失败（出现反），就要从头再来等两个正面；而等待正反失败（出现正），则还是得到正面，仍只需等一个反面。</p><h2 id="势能法">势能法</h2><p><a href="https://www.cnblogs.com/houzhiyuan/p/17991053">看这个</a><br><a href="https://www.cnblogs.com/ez-lcw/p/16843253.html">看这个</a></p><ol><li>CF1025G 有n个公司可能是自由的或者被合并的,每次会随机选出ab两个自由公司,然后等概率让a合并b或b合并a,被合并的公司的所有子公司都会变成自由状态,求第一次所有公司被一家公司合并的期望次数.</li></ol><p><strong>势能法</strong> :设S是当前局面,F(S)是当前局面势能,F(N)是结束局面的势能,令F(N)-F(S)是期望次数.将局面势能落到具体每个节点的势能: $F(S)=\sum f(a_i)$ ,其中 $a_i$ 是每个节点的势能,只和这颗&quot;树&quot;的大小有关.</p><p>随机两个数ab,模拟合并的过程:<br>$$f(a)+f(b)+1=\frac{af(0)+bf(0)+f(a+1)+b(b+1)}{2}$$<br>前面是ab的势能和, $+1$ 是因为发生一次合并之后势能总要往高走(不然怎么算期望),然后根据轮换对称性可以直接把ab独立出来:<br>$$f(a)+\frac12=\frac{af(0)+f(a+1)}{2}$$<br>由于势能是一个相对的概念,f(0)可以随便取,取0得到<br>$$f(a)=2^a-1$$<br>加起来减一下即可.</p><h2 id="随机游走-简单版">随机游走(简单版)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o-o-o-o-o</span><br><span class="line">q1^     q2</span><br><span class="line"> now</span><br></pre></td></tr></table></figure><p>你在一条链上.你有 $\frac12$ 的概率往左走一格, $\frac12$ 的概率往右走一格.走到最左端(0)有 $q_1$ 的概率赢,走到最右端有 $q_2$ 的概率赢.求你最终赢的概率.</p><p>结论:在距离0 $x$ 点位置的概率是 $\frac{x}{n+1}q_1+\frac{n+1-x}{n+1}q_2$ ,直观理解就是调和一下…</p><h2 id="Pending…随机游走-困难版">Pending…随机游走(困难版)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o-o-o-o-o</span><br><span class="line">q1^     q2</span><br><span class="line"> now</span><br></pre></td></tr></table></figure><p>你在一条链上.你有 $p$ 的概率往左走一格, $1-p$ 的概率往右走一格.走到最左端(0)有 $q_1$ 的概率赢,走到最右端有 $q_2$ 的概率赢,只要走到判定点无论输赢立刻停止,求你最终赢的概率.</p><p>哎哎,有的时候一个问题不一定就要有个答案…</p><p>好像要求矩阵快速幂???</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在这里放一些常见的概率模型.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果某件事情发生的概率是p,那么期望进行多少次试验才能让p发生的次数是1/p.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;模式匹配问题&quot;&gt;模式匹配问题&lt;/h2&gt;
&lt;p&gt;猴子每次会在键盘上随机敲击一个字母,请问出现指定字符串</summary>
      
    
    
    
    <category term="ACM" scheme="https://narafluorine.github.io/categories/ACM/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>二分</title>
    <link href="https://narafluorine.github.io/2024/12/14/10032_%E4%BA%8C%E5%88%86/"/>
    <id>https://narafluorine.github.io/2024/12/14/10032_%E4%BA%8C%E5%88%86/</id>
    <published>2024-12-13T16:46:12.000Z</published>
    <updated>2025-04-25T19:00:36.869Z</updated>
    
    <content type="html"><![CDATA[<p>二分听起来简单,实际上题看都看不出来…</p><p>为了根除这个祸患,Flu特立此专题.</p><h2 id="例题">例题</h2><ol><li>CF2037F 有好多怪物在坐标轴上,每个怪物有自己的血量,怪物不会动,你只能选一个点进行攻击,攻击伤害递减(如 1 2 3 2 1 这样递减的攻击,最中心是你的战力),给定战力求击杀k个怪物的最少攻击次数.</li></ol><p>发现 <strong>攻击次数</strong> 是满足单调性的,也就是说这一次满足了下一次攻击也会满足条件,于是考虑二分.<br>设攻击y次,战力为k,坐标是pos,对每一个点有 $y\max(0,m-|pos-x_i|)\ge h_i$ ,解方程得到 $\lceil\frac hy\rceil+x_i-m\le pos\le m-\lceil\frac hy\rceil+x_i$ 于是转化为区间有n条线段,找到是否存在一个点被k个线段覆盖,直接差分就可以了.(注意如果有一个点不会被消掉就不要进行贡献,不然整段区间是会被切开出现空当导致WA的)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;二分听起来简单,实际上题看都看不出来…&lt;/p&gt;
&lt;p&gt;为了根除这个祸患,Flu特立此专题.&lt;/p&gt;
&lt;h2 id=&quot;例题&quot;&gt;例题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;CF2037F 有好多怪物在坐标轴上,每个怪物有自己的血量,怪物不会动,你只能选一个点进行攻击,攻击伤害递减(如 1</summary>
      
    
    
    
    <category term="ACM" scheme="https://narafluorine.github.io/categories/ACM/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理学习笔记</title>
    <link href="https://narafluorine.github.io/2024/12/02/00009_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://narafluorine.github.io/2024/12/02/00009_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-12-02T10:55:00.000Z</published>
    <updated>2025-04-25T18:56:19.388Z</updated>
    
    <content type="html"><![CDATA[<p>这里放一些名词.</p><p>给一个芯片是 $a\times b$ 位的能得出:<br>地址线: $\log a$<br>数据线: $b$</p><p>故引脚数量: 地址线(dram一般用地址复用技术就会减半)+数据线+1(片选线)+1(或2,读写控制线)</p><p>DRAM的刷新按行进行.</p><p><strong>刷新信号周期</strong> :(异步刷新)刷新周期/行数,然后可以下取整<br><strong>集中刷新</strong> :死时间率:集中刷新时间/周期</p><p>芯片画图: $A_n$ 是地址线, $D_n$ 是数据线 , $\overline{CE}$ 是片选线 $\overline{WE}$ 是读写线( $\overline{OE}$ 是输出线 ), $\overline{MREQ}$ 绝对的低电平, $G_1$ 直接连5V电压即可,地址线听说不能有浪费, $\overline{PD}/progr$ 是编程线,在ROM这里直接接地就行, $\overline{WR}$ 和 $\overline{RD}$ 这俩是输入输出信号.</p><p>海明码默认偶校验.</p><p>微操作命令分析:</p><p>取指周期:(把指令从存储器提取出来)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PC -&gt; MAR -&gt; 地址线<span class="comment">//把指令从PC寄存器通过地址总线送给存储器</span></span><br><span class="line"><span class="number">1</span> -&gt; R            <span class="comment">//控制单元向存储器发出读命令</span></span><br><span class="line"><span class="built_in">M</span>(MAR) -&gt; MDR     <span class="comment">//读出的数据从存储器经过数据总线发给MDR寄存器</span></span><br><span class="line">MDR -&gt; IR         <span class="comment">//把指令从MDR送给IR</span></span><br><span class="line"><span class="built_in">OP</span>(IR) -&gt; CU      <span class="comment">//IR寄存器操作码部分送给CU,由CU译码决定要做什么</span></span><br><span class="line">(PC)+<span class="number">1</span> -&gt; PC      <span class="comment">//下一条指令地址</span></span><br></pre></td></tr></table></figure><p>间址周期:首先是命令采取间接寻址的形式,要把操作数的地址从存储器当中取出,放到指令寄存器当中.</p><p>感觉间接寻址的行为就是一级指针,指针存放的地址就是操作数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先要做指令形式地址 -&gt; MAR//地址码传送给MAR</span></span><br><span class="line"><span class="built_in">Ad</span>(IR) -&gt; MAR</span><br><span class="line"><span class="number">1</span> -&gt; <span class="function">R</span></span><br><span class="line"><span class="function"><span class="title">M</span><span class="params">(MAR)</span> -&gt; MDR</span></span><br><span class="line"><span class="function">MDR -&gt; <span class="title">Ad</span><span class="params">(IR)</span><span class="comment">//操作数所在存储单元地址</span></span></span><br></pre></td></tr></table></figure><p>执行周期:因为指令不一定一样长,所以执行周期非常复杂.(是不是不考了(喜))</p><ol><li>非访存指令</li></ol><blockquote><ol><li><code>CLA</code> 清空ACC加法器</li><li><code>COM</code> 按位取反</li><li><code>SHR</code> 算术右移</li><li><code>CSL</code> 循环左移</li><li><code>STP</code> 停机指令(内部有一个标志,置零就能停机.)</li></ol></blockquote><ol start="2"><li>访存指令</li></ol><blockquote><ol><li>加法指令 <code>ADD X</code></li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Ad</span>(IR) -&gt; MAR</span><br><span class="line"><span class="number">1</span> -&gt; <span class="function">R</span></span><br><span class="line"><span class="function"><span class="title">M</span><span class="params">(MAR)</span> -&gt; <span class="title">MDR</span></span></span><br><span class="line"><span class="function"><span class="params">(ACC)</span>+<span class="params">(MDR)</span> -&gt; ACC</span></span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>存数指令 <code>STA X</code></li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Ad</span>(IR) -&gt; MAR</span><br><span class="line"><span class="number">1</span> -&gt; W <span class="comment">//写命令</span></span><br><span class="line">ACC -&gt; MDR</span><br><span class="line">MDR -&gt; <span class="built_in">M</span>(MAR)</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>取数指令 <code>LDA X</code> 把某个数字存放到 <code>ACC</code> 里面</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Ad</span>(IR) -&gt; MAR</span><br><span class="line"><span class="number">1</span> -&gt; <span class="function">R</span></span><br><span class="line"><span class="function"><span class="title">M</span><span class="params">(MAR)</span> -&gt; MDR</span></span><br><span class="line"><span class="function">MDR -&gt; ACC</span></span><br></pre></td></tr></table></figure><blockquote><ol start="4"><li>无条件转移 <code>JMP X</code></li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Ad</span>(IR) -&gt; PC</span><br></pre></td></tr></table></figure><blockquote><ol start="5"><li>有条件转移 <code>BAN X</code> (负则转移)<br>$$A_0\cdot Ad(IR)+\bar A_0(PC)\to PC$$</li></ol></blockquote><p><strong>周期分析</strong> :只有间接访存和间接转移是需要间址周期的,其他的(非访存,直接访存,转移)都是只有取址和执行周期.</p><p>中断周期:1.保存断点2.形成中断服务程序的入口地址3.关中断</p><p>程序断点存入0地址(法一)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> -&gt; MAR <span class="comment">//</span></span><br><span class="line"><span class="number">1</span> -&gt; W <span class="comment">//保存程序断点</span></span><br><span class="line">PC -&gt; MDR</span><br><span class="line">MDR -&gt; <span class="built_in">M</span>(MAR) <span class="comment">//保存到MAR指定内存当中</span></span><br><span class="line">              <span class="comment">//硬件向量法:</span></span><br><span class="line">向量地址 -&gt; PC <span class="comment">//保存向量地址</span></span><br><span class="line"><span class="number">0</span> -&gt; EINT     <span class="comment">//允许生成断点(置零)</span></span><br></pre></td></tr></table></figure><p>程序断点进栈:(法二)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(SP<span class="number">-1</span>) -&gt; MAR</span><br><span class="line"><span class="number">1</span> -&gt; W</span><br><span class="line">PC -&gt; MDR</span><br><span class="line">MDR -&gt; <span class="built_in">M</span>(MAR)</span><br><span class="line">向量地址 -&gt; PC</span><br><span class="line"><span class="number">0</span> -&gt; EINT</span><br></pre></td></tr></table></figure><p>也可以软件进行中断, <code>M-&gt;PC</code> 代替向量地址</p><p>许许多多信号:</p><p>$\overline{MREQ}$ :访存控制信号<br>$\overline{IO}/M$ :访问IO/存储器的信号<br>$\overline{RD}$ :读命令<br>$\overline{WR}$ :写命令<br>$INTA$ :中断响应信号<br>$HLDA$ :总线相应信号</p><p><code>ADD@X</code> 是间接寻址的加法方式.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里放一些名词.&lt;/p&gt;
&lt;p&gt;给一个芯片是 $a&#92;times b$ 位的能得出:&lt;br&gt;
地址线: $&#92;log a$&lt;br&gt;
数据线: $b$&lt;/p&gt;
&lt;p&gt;故引脚数量: 地址线(dram一般用地址复用技术就会减半)+数据线+1(片选线)+1(或2,读写控制线)&lt;/p&gt;
</summary>
      
    
    
    
    <category term="DE" scheme="https://narafluorine.github.io/categories/DE/"/>
    
    
    <category term="ComputerScience" scheme="https://narafluorine.github.io/tags/ComputerScience/"/>
    
  </entry>
  
  <entry>
    <title>多项式与生成函数</title>
    <link href="https://narafluorine.github.io/2024/11/29/10031_%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    <id>https://narafluorine.github.io/2024/11/29/10031_%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E9%A1%B9%E5%BC%8F/</id>
    <published>2024-11-29T15:28:26.000Z</published>
    <updated>2025-08-16T04:59:08.318Z</updated>
    
    <content type="html"><![CDATA[<p>多项式全家桶(悲).</p><h2 id="例题">例题</h2><ol><li>分治FFT: 给定序列 $g_n$ 求 $f_n$ ,其中 $f_n=\sum_{j=1}^if_{i-j}g_{j}$ ,边界 $g_0=0,f_0=1$ ,对 $998244353$ 取模.</li></ol><p>设生成函数 $f(x)=\sum_{i=0}^{\infty}f[i]x^i,g(x)=\sum_{i=0}^{\infty}g[i]x^i,g[0]=0$<br>然后使用生成函数卷积:<br>$$f(x)*g(x)=\sum_{i=0}^{\infty}\sum_{j=0}^{\infty}f[i]\times g[j]x^{i+j}$$<br>令 $k=i+j$ ,<br>$$f(x)*g(x)=\sum_{k=0}^{\infty}\left(\sum_{j=0}^kf[k-j]g[j]\right)x^k$$<br>当 $k&lt;0$ 时 $\sum_{j=0}^kf[k-j]g[j]=f[k]$ 这就是个普通卷积.<br>当 $k=0$ 时 $\sum_{j=0}^kf[k-j]g[j]=0(g[0]=0)$ 于是和 $f(x)$ 对比一下发现差了个常数项,于是我们有<br>$$\boxed{f(x)*g(x)+f[0]=f(x)}$$<br>于是有<br>$$\boxed{f(x)=\frac{f[0]}{1-g(x)}}$$<br>使用多项式求逆即可解决.</p><h1>普通生成函数 OGF</h1><p>$$F(x)=\sum_{n}^{\infty}a_nx^n$$</p><h1>指数生成函数 EGF</h1><p>$$F(x)=\sum_{n}^{\infty}a_n\frac{x^n}{n!}$$</p><p>指数生成函数在卷积的时候比ogf多了一个组合数项,详见OIwiki.</p><h2 id="例-洛谷p5339">例 洛谷p5339</h2><p>S(a,b,c,d,n)的组合意义就是在四种颜色里面(有个数限制)取一些来涂色。</p><p>这个是EGF经典问题,考虑构造 $R_k​(x)=∑_{i=0}k​ \frac{x^i}{i!}​$ ,就是k个同种颜色的EGF。</p><p>EGF卷积的意义就是随意插入混合,那么我们把四个R卷起来之后取第n项就可以得到答案了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;多项式全家桶(悲).&lt;/p&gt;
&lt;h2 id=&quot;例题&quot;&gt;例题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;分治FFT: 给定序列 $g_n$ 求 $f_n$ ,其中 $f_n=&#92;sum_{j=1}^if_{i-j}g_{j}$ ,边界 $g_0=0,f_0=1$ ,对 $998244353$</summary>
      
    
    
    
    <category term="ACM" scheme="https://narafluorine.github.io/categories/ACM/"/>
    
    
    <category term="NumberTheory" scheme="https://narafluorine.github.io/tags/NumberTheory/"/>
    
  </entry>
  
  <entry>
    <title>2-SAT</title>
    <link href="https://narafluorine.github.io/2024/11/28/10030_2-SAT/"/>
    <id>https://narafluorine.github.io/2024/11/28/10030_2-SAT/</id>
    <published>2024-11-28T09:33:14.000Z</published>
    <updated>2025-04-25T19:00:32.144Z</updated>
    
    <content type="html"><![CDATA[<p>2-SAT是求解满足性问题的算法.<br>实际测下来发现对于如何转成图论问题要求有点高,但是代码非常好写.</p><p>先把2-SAT转成图论问题:有 $2n$ 个点,前n个表示该点为假的时候的连边情况,后面n个点是该点为真的时候的情况.令有向边 $a\to b$ 的意义是选 $x$ 就必须选 $y$ .</p><p><strong>i,j不能同时选</strong> :选了 $i$ 就要选 $j’$ ,选 $j$ 就要选 $i’$ .故 $i→j’,j→i’$ .一般操作即为 $a_i\mathrm{xor} a_j=1$</p><p><strong>i,j必须同时选</strong> :选了 $i$ 就要选 $j$ ,选 $j$ 就要选 $i$ .故 $i→j,j→i$ .一般操作即为 $a_i\mathrm{xor} a_j=1$</p><p><strong>i,j任选一个</strong> :选了 $i$ 就要选 $j’$ ,选 $j$ 就要选 $i’$ .选 $i’$ 就要选 $j$ ,选 $j’$ 就要选 $i$ .故 $i→j’,j→i’,i’→<br>j,j’→i$ .一般操作即为 $a_i\mathrm{or}a_j=1$</p><p><strong>i必须选</strong> :直接 $i’→i$ ,可以保证无论怎样都选 $i$ .一般操作为给出的 $a_i=1$ 或 $a_i\mathrm{and}a_j=1$</p><p>所以对于条件 <code>a为真或b为真</code> ,要把刚好满足的进行连边,也就是说,如果a真,后面b无论怎样都满足的时候不用连边,所以连 <code>a-&gt;b+n</code> 表示a假的时候b为真,以及 <code>b-&gt;a+n</code> 表示b为假的时候a必须为真.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2-SAT是求解满足性问题的算法.&lt;br&gt;
实际测下来发现对于如何转成图论问题要求有点高,但是代码非常好写.&lt;/p&gt;
&lt;p&gt;先把2-SAT转成图论问题:有 $2n$ 个点,前n个表示该点为假的时候的连边情况,后面n个点是该点为真的时候的情况.令有向边 $a&#92;to b$ 的意</summary>
      
    
    
    
    <category term="ACM" scheme="https://narafluorine.github.io/categories/ACM/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>欧拉计划</title>
    <link href="https://narafluorine.github.io/2024/11/11/20007_%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%92/"/>
    <id>https://narafluorine.github.io/2024/11/11/20007_%E6%AC%A7%E6%8B%89%E8%AE%A1%E5%88%92/</id>
    <published>2024-11-11T12:24:34.000Z</published>
    <updated>2025-07-27T14:38:36.852Z</updated>
    
    <content type="html"><![CDATA[<p>在这里放一些欧拉计划的心得体会(我不会放答案的,可以放心阅读)…</p><p>欧拉计划是鼓励大家网上搜索除了答案之外的知识的.</p><p>欧拉计划使用 <code>CC-BY-NC-SA 4.0</code> 协议,所以这篇文档也是这个协议写成的.<br><a href="https://projecteuler.net">欧拉计划网址</a></p><h2 id="板子">板子</h2><h3 id="简易文件解析-欧拉计划-Project-Euler">简易文件解析(欧拉计划 Project Euler)</h3><p>形如</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;AAA&quot;</span>,<span class="string">&quot;BBB&quot;</span>,<span class="string">&quot;CCC&quot;</span>,<span class="string">&quot;DDD&quot;</span></span><br></pre></td></tr></table></figure><p>的文件,在此代码的解析下会变成</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AAA</span><br><span class="line">BBB</span><br><span class="line">CCC</span><br><span class="line">DDD</span><br></pre></td></tr></table></figure><p>代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>,vector&lt;string&gt; &gt;<span class="built_in">eulerDecode</span>()&#123;</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;words.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);<span class="comment">/*给定文件名称*/</span></span><br><span class="line">pair&lt;<span class="type">int</span>,vector&lt;string&gt; &gt;res;<span class="comment">/*文件格式必须是 &quot;a&quot;,&quot;b&quot;,&quot;c&quot; 这样的格式,会解析出abc三个字符串 &quot;*/</span></span><br><span class="line">res.second.<span class="built_in">resize</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="type">char</span> ch=<span class="built_in">getchar</span>(),ff=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(ch!=EOF)&#123;</span><br><span class="line"><span class="keyword">if</span>(ch==<span class="string">&#x27;&quot;&#x27;</span>)&#123;</span><br><span class="line">ff^=<span class="number">1</span>;</span><br><span class="line"><span class="comment">// res.second.push_back(&quot;&quot;);</span></span><br><span class="line"><span class="keyword">if</span>(ff==<span class="number">0</span>)&#123;</span><br><span class="line">res.first++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ff==<span class="number">1</span>)res.second[res.first]+=ch;</span><br><span class="line">&#125;</span><br><span class="line">ch=<span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="广义五边形数-负数也会取到">广义五边形数(负数也会取到)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">pentagonal</span><span class="params">(<span class="type">long</span> <span class="type">long</span> num)</span></span>&#123;</span><br><span class="line">num=(num&amp;<span class="number">1</span>^<span class="number">1</span>)?-(num&gt;&gt;<span class="number">1</span>):(num+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (num*(num*<span class="number">3</span><span class="number">-1</span>))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//生成一个0,1,2,5,7,12,15,22,26,35,40的五边形数列</span></span><br></pre></td></tr></table></figure><h2 id="0050">0050</h2><p>求1e6以内的哪个质数可以写成连续质数的和.</p><p>连续质数考虑前缀和.我们枚举两端然后检查质数.这里有一个小剪枝是,如果质数大于1e6直接跳出来递增的那个端点,能让程序快几十倍.</p><h2 id="0061">0061</h2><p><a href="https://pe-cn.github.io/61/">题干</a></p><p>首先预处理所有的n变形数,发现直接枚举是2.3e10的必超时,因为没有利用循环的性质.</p><p>使用图论降低复杂度.想象前半部分和后半部分有一条边,然后图论dfs一遍即可.<br>会出好几个结果,是因为图上是循环的…</p><h2 id="0066">0066</h2><p>解一个二元二次丢番图方程,使用pell方程的解法,把根号转成连分式找环然后合并求解.</p><p>现在考虑支持高精度的怎么写,发现只需要支持加和乘就好了,问题解决…</p><h2 id="0078">0078</h2><p>整数划分:把一个整数表示成若干别的数字的加和形式.</p><p>使用dp可以让复杂度压成 $n^2$ ,还不够.</p><p>上网查阅结论得知,划分数 $p(n)$ 有以下性质:<br>$$p(k)=p(k-1)+p(k-2)-p(k-5)-p(k-7)+p(k-12)+p(k-15)-p(k-22)-+±-…$$<br>其中p(0)认为是1,负的认为是0.</p><p>其中这个减掉的数列叫做 <strong>五边形数</strong> ,满足通项公式(注意这个通项是正负交替的, $0,1,-1,2,-2,…$ )<br>$$a_n=n(3n-1)/2,n\in{0,\pm1,\pm2,\pm3,…}$$<br>然后求能被1000000整除的那一项就可以计算了,注意对1000000取模就不会炸int(为啥傻傻的用py) <s>(但是多用用py确实能增进熟练度,比方说开一个二维数组之类的能少踩坑)</s></p><h2 id="0084">0084</h2><p>给一个大富翁(非常非常复杂的规则)然后求哪三个点的落点概率最高.</p><p>使用1e8次模拟即可,计算机最擅长随机数模拟.</p><h2 id="0088">0088</h2><p>长度为n的集合,满足所有元素的和等于所有元素的积,求对于长度为2-12000的集合,最小的这样的积和数组成的集合的和(即相同积和数只算一次)</p><p>这是一道40%的题,卡了Flu一个寒假…</p><p>观察样例,发现有个通解是 ${1,1,1,1,…,2,k}$ ,所以答案上界呼之欲出,就是24000.</p><p>但是发现有例外:<br>$$k=5,{1,1,2,2,2}$$<br>于是考虑对每个数暴力分解,然后求出这个数可能匹配上哪个长度,单个的复杂度是 $O(\sqrt n)$ 的.</p><p>但是所有数字一起分解就会省不少事,我们使用dfs,记录当前深度,乘积,加和,然后在dfs中进行分解.同时为了避免出现 $6=3\times2=2\times3$ 的情况,额外记录一个num表示上一个因数,保证因数单调,也就是每个分解最多出现1次,然后更新答案即可,复杂度如下,Flu不知道是多少,反正实际上跑的飞快(可能是数据太小了).<br>$$O(\sum_{i=1}^{12000}(2+d(i)))$$<br>d(i)是i的因数个数</p><p>时间也是做题的法宝…</p><h2 id="0093">0093</h2><p>注意炸精度…除的数字再乘回去c艹会默认下取整然后WA了…</p><h2 id="0094">0094</h2><p>难点在于快速判断一个开根号的数字是不是整数.</p><p>对开根号的结果平方之后再跟自己比较,可以直接i64比较,避免炸精度</p><h2 id="0103">0103</h2><p>发现生成出来的&quot;特殊集合&quot;可能不是最优解,但是很接近最优解.<br>于是取一个lim在其附近暴搜正确答案,实际上lim取1就能出来,复杂度 $O(3^7\alpha)$ , $\alpha$ 是检查的一个小常数,大概是五百.</p><h2 id="0106">0106</h2><p>非常妙的组合数学题.题干:有一个单调递增的数列,你要从中选两个不重的集合,然后对其进行两种检查:1:如果两个集合元素数量不一样,则元素更多的集合一定更大.2:两个集合元素和不重复.你要先对这些集合进行检查1,而且不必要不进行检查2,求对大小12的数列有多少个集合需要进行检查2.</p><p>已知长度为4的数列有25种集合选法,其中只有1个需要进行检查2,长度为7的数列有70个集合需要进行检查2.</p><p>首先,检查1的本质是找出所有两个集合大小相同的选法.<br>对于一个共同的size,考虑什么时候不需要检查2:假设元素为 <code>1212</code> ,显然集合1小于集合2,不需要检查.相似地, <code>1122</code> 同理,这是一个走楼梯问题,只能往下或者往右走,同时不能超过对角线,问有多少种情况.这是卡特兰数典题.</p><p>所以答案就是<br>$$\binom{n}{2}Cat_1+\binom{n}{4}Cat_2+…$$</p><h2 id="0110">0110</h2><p>解方程…<br>$$\frac1x+\frac1y=\frac1n$$<br>因为xyn都是整数,所以显然xy都大于n.<br>设y=n+k,带入求出x的方程<br>$$x=n+\frac{n^2}{k}$$<br>于是答案就是 $d(n^2)-1$ ,具体地,我们对n进行质因数分解,设当前质数为p,次方为q,对总共答案的贡献是 $2q+1$ ,所有解就是把贡献乘起来,然后除二加一(因为xy可以交换,+1是把xy相同的解加上),由于这个题要求解大于一个数,我们暴搜每个质数的次方,逆着算出来即可.</p><h2 id="0118">0118</h2><p>用1-9组数字,问有多少个全是质数的集合.</p><p>显然是枚举数字位置和每位是数字相连还是开一个新数字.</p><p>然后哈希不知道为啥碰撞了,寄…</p><p>下面是两种不同的哈希方式,区别只是快速幂那里换了点位置,然而后者不知道为啥会撞哈希(虽然都是质数),而前者能够通过.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;++i)&#123;</span><br><span class="line">res=(res+<span class="built_in">qp</span>(ttmp[i],(i64)<span class="number">7</span>,<span class="number">998244353</span>))%<span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;++i)&#123;</span><br><span class="line">res=(res+<span class="built_in">qp</span>((i64)<span class="number">7</span>,ttmp[i],<span class="number">998244353</span>))%<span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0119">0119</h2><p>某个数满足其各位和的某次方等于这个数,首先暴力检查是nlog,跑一下发现比较稀疏,换方法,使用log以及把各位和的函数优化成o1,结果除了炸精度之外跑的更慢了…所以 <code>log()</code> 函数的复杂度当成log.</p><p>发现似乎可以枚举次方的底数,然后对其次方暴力检查,而且取一个1e23的lim可以很快得到底数最大是 $9<em>23$ ,于是 $nlog^2n$ ,n是 $9</em>23$ 得解.</p><h2 id="0122">0122</h2><p>加法链,不知道咋算可以<a href="https://oeis.org/A003313">OEIS</a>一下看看剪枝.<br>实际暴搜的时候用vector记录整个加法链,然后暴力枚举每个链和当前值合并,然后dfs即可,跑的飞快,因为上界(快速幂法)是确定的log级别.</p><h2 id="0126">0126</h2><p>空间的堆叠有点难,我们只看一个平面.设 $dp(n,m,a)$ 表示一个nm的矩形向外拓展a层得到的所有正方形,得到 $dp(n,m,a)=nm+2a(n+m+a-1)$ .<br>然后发现长方体的 $n\times m\times s$ 中s的作用就是单纯堆叠这个dp.<br>然后竖着看,每次往外拓展一层,然后这个再往外拓展…<br>所以一个 $nms$ 的长方体向外拓展 $a$ 层,得到的所有正方体就有:<br>$$ddp(n,m,s,a)=(s\times dp(n,m,a))+2dp(n,m,a-1)+2dp(n,m,a-2)+…+2dp(n,m,0)$$<br>由于我们得到的是所有的正方体,做差得到一次堆叠:<br>$$f(n,m,s,a)=sdp(n,m,s,a)+(2-s)dp(n,m,s,a-1)$$<br>然后开始找最大值,取一个上界,然后在这个上界里面进行计算(题干描述的有点不清楚:必须是独特的长方形才可以,如 $3\times 2\times 1$ 和 $3\times 1\times 2$ 被认成是一种,枚举的时候注意要递增)</p><h2 id="0127">0127</h2><p>Flu的做法是先筛选出质数,然后枚举c的组合,然后枚举a,麻烦的一批结果因为没去重最后还WA了.</p><p>网上查发现应该先算 <code>rad</code> ,然后枚举c,对这个c枚举互质的rad(a),然后判断b合不合适…</p><h2 id="0129">0129</h2><p>这个题过于水了,难度绝对没有 $45%$ .问 $A(i)=111111…\equiv0\mod x$ 求最小的i大于1e6的最小x.</p><p>首先对于一个剩余系,最大环就是本身,所以i大于1e6则x必须大于1e6.然后从1e6开始暴搜就行,非常简单,跑的飞快.</p><h2 id="0131">0131</h2><p>实在想不出来了看<a href="https://www.ivl-projecteuler.com/overview-of-problems/40-difficulty/problem-131">题解</a>做的…<br>题解说首先证明 $n,n+p$ 都是完全平方数.<br>然后证明 $n+p$ 是 $n$ 的下一个完全平方数,然后做差得到了一个数列: $p=(a+1)^3-a^3$ 直接检查即可.</p><h2 id="0267">0267</h2><p>你开始有一块钱,你每轮把 $f$ 倍率的钱拿去下注,每次翻硬币正面朝上可以获得这么多钱,反面朝上就失去这么多钱.1e3轮之后你的钱有概率突破1e9,问选取最合适的 $f$ 使概率最大,你有多大概率超过1e9.</p><p>首先把加法化成乘法:正反面朝上分别会获得 $(1+2f),(1-f)$ .所以丢N次硬币假设正面次数为n,有<br>$$W(n)=(1+2f)^{n}(1-f)^{N-n}$$<br>显然这个函数是单调的,直观理解为赢的次数越多钱越多.那么必定存在一个最小的 $n$ 值 $n_0$ 满足 $W(n)\ge M$ ,列式子如下:<br>$$n\ge\frac{\log M-N\log(1-f)}{\log(1+2f)-\log(1-f)}$$<br>我们要求右边函数的最小值,使用 <code>scipy.optimize</code> 的 <code>fminbound</code> 解决,得到 $n_0=\lceil h(x_0)\rceil$ .</p><p>剩下的就简单了,答案是 $\frac{\sum_{i=n_0}^N\binom{N}{i}}{2^N}$</p><h2 id="0277">0277</h2><p>你发现,这玩意应该和数字加几位是3的倍数有关系,所以我们考虑枚举.<br>但是一味枚举肯定超时,我们不妨这么调参:<br>每一次筛出来满足前几位的数字,然后得到第一个数字和公差,然后我们枚举这个等差数列,因为这个等差数列必定满足前几位,所以我们提高这个&quot;前几位&quot;得到更精细的等差数列,最终把整个数列搞出来.</p><p>这个办法很无脑,应该能从解中国剩余定理的角度直接算出来一个式子,然后得到所有数字,不过笔者很懒,就这样吧,能过就行.</p><h2 id="0303">0303</h2><p>想不出来,最后看题解了(怯战蜥蜴)…</p><p>题解说,我们找到一个最小的满足条件的n的倍数,本质上是找到一个最小的 <strong>模n为0的数</strong> .<br>所以我们用广搜方式,每次枚举一个数字观察是否在模意义下出现过,然后对其拓展即可,由于记录模意义,单次复杂度 $O(n)$ .</p><h2 id="0313">0313</h2><p>肯定先找规律,显然最后的空格在哪里不是我们关心的,所以f(n,m)具有对称性,我们采取手模的方式:</p><table><thead><tr><th>f(n,m)</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>2</td><td>5</td><td>9</td><td>15</td><td>21</td></tr><tr><td>3</td><td></td><td>13</td><td>17</td><td>23</td></tr><tr><td>4</td><td></td><td></td><td>21</td><td>25</td></tr><tr><td>5</td><td></td><td></td><td></td><td>29</td></tr></tbody></table><p>发现斜角是+8,斜角第一直出是+4,之后都是+6.我们要在表内寻找 $p^2$ ,因为斜角增长是8,所以整张表会接近 $\frac{p^2_m}8$ ,Flu计算所有质数平方模6的后缀和,也就是说一个数字匹配上了之后整个剩余系中余数相同的也能匹配上,所以双指针l是斜角,r是质数,复杂度 $O(\frac{1e12}8)$ ,实际上跑了三分钟左右,还挺快.</p><p>论坛里说直接把整个式子算出来(m&gt;n有f(m,n)=8m+2n-13)然后对每个质数算贡献也行.</p><h2 id="0317">0317</h2><p>空间上有一个点,能够向任意方向发射速度相同的质点,质点只受重力作用,问所有轨迹形成的图形的体积是多少.</p><p>物理题.结论就是,这个包络面是一个抛物面,且相似于直抛,代数得到最高点坐标之后直接算积分就可以了.</p><h2 id="0323">0323</h2><p>很奇怪的概率题.网上的解法:<br>$$P(1个比特从0翻到1)=\frac12$$<br>$$P(1个比特在N轮后还是0)=(\frac12)^n$$<br>$$P(1个比特在N轮后翻到1)=1-(\frac12)^N$$<br>$$P(N轮后所有比特都是1)=(1-(\frac12)^N)^{32}$$<br>$$P(在第N轮所有比特正好翻到1)=(1-(\frac12)^N)^{32}-(1-(\frac12)^{N-1})^{32}$$<br>$$E=\sum_{i=1}^{\infty}i((1-(\frac12)^i)^{32}-(1-(\frac12)^{i-1})^{32})$$</p><h2 id="0336">0336</h2><p>观察到两次交换的规律是 $swap(AB)=B\overline A$ ,其中AB可以是任意串.<br>有一个特殊情况是B只有一个字符,这个时候就可以直接旋转到前面,代价是1.</p><p>11!大概是3.9e7,直接暴搜即可,笔者跑了14s.</p><h2 id="0340">0340</h2><p>和0555类似的函数构造.<br>$$f(n)=\begin{cases}<br>n-a&amp;n&gt;b\\<br>f(a+f(a+f(a+f(a+n))))&amp;n\le b\end{cases}$$<br>错误!!!这年头直接用py画图了,谁还打表啊…直接用py画图找规律即可.</p><h2 id="0345">0345</h2><p>给一个15*15方阵,每行每列选一个元素(元素不能同行不能同列),求最大和.</p><p>Flu乱搞过去的…对每行记录一个唯一编号表示选该行第几列的数字,然后每次随机俩数字交换,如果更大保留,更小就丢解换回去,重复500次即可…<br>这能草过去我是没想到的…</p><p>论坛里说状压dp,记录二进制表示哪行有数字了,于是直接dp即可…唐完了.</p><h2 id="0429">0429</h2><p>首先,题干的元因数就是分解之后 $p_i^{e_i}$ 这个要么不选要么都选上,所以答案就是<br>$$\prod_{i=1}^n(p_i^{2e_i}+1)$$<br>然后考虑 $p_i$ 在 $n!$ 中出现多少次:<br>$$f(n,p)=\left\lfloor\frac np\right\rfloor+\left\lfloor\frac n{p^2}\right\rfloor+\left\lfloor\frac n{p^3}\right\rfloor+…$$<br>这表示 $p,p^2,p^3,…$ 对阶乘的贡献.</p><h2 id="0443">0443</h2><p>结论假了…</p><p>Flu:观察到f(x)不会大于3*x(Flu并不会证明).<br>然后考虑取等的情况,发现是有规律的:对所有取等的地方做差,得到一个最大数和很多小数,发现最大数数列之间的关系是最大数乘2加上一堆小数,而且1e6以内的小数大小不会超过1e5.于是可以通过倍增的方法求出最靠近1e15的取等的数字,剩下的暴算过去.<br>然而,因为这个最大数数列是倍增的,最靠近1e15的是8e14,意味着Flu只是把1e15的nlog优化成1.2e14的nlog,还是T飞…</p><p>查阅网上的题解说是:发现 $\gcd$ 不等于1的实际上很少,于是对一个 ${i,g}$ 考虑下一个gcd不等于1的设为 ${i+k,pre(g+k-1)}$ ,中间的gcd都是1.我们有 $\gcd(g+k-1,i+k)&gt;1$ ,根据gcd性质相减有 $\gcd(g-i-1,i+k)&gt;1$ 然后发现前面是常数,于是质因数分解之后对k求最小值,跳转过去即可,复杂度未知总之是能过.</p><h2 id="0493">0493</h2><p>有七种颜色的球,每种10个,你要不放回拿20个,求期望颜色种类数,保留9位小数.</p><p>没想到Flu组合数学知识从这里发家…一个很简单的思路:首先,颜色对抽取本身没有影响.对每一种颜色,计算其出现的概率:(总概率-删掉这种颜色的随便抽的概率)<br>$$1-\frac{\binom{60}{20}}{\binom{70}{20}}$$<br>然后因为颜色都是一样的,所以上式乘7,秒了…<br>看来Flu真的有必要学一下组合数学了,</p><h2 id="0500">0500</h2><p>求最小的有 $2^{500500}$ 个因子的数字,对500500503取模.</p><p>根据因数分解定理,把大数拆成很多小的质数,最后因子数就是这些质数次方+1的乘积.<br>注意到这个因子只是2的倍数,意味着质数有且只有2^n这一种情况,所以每个质数转移只有一种代价,那就是从2^x转移到2^{x+1},于是线筛1e7得到质数之后贪心选取后面的大质数扔到前面即可.</p><h2 id="0510">0510</h2><p>三个圆两两相切(切点不一样),三个圆同时和一条直线相切,问有多少组解.</p><p>根据笛卡尔定理,有:<br>$$\frac1{\sqrt{r_A}}+\frac1{\sqrt{r_B}}=\frac1{\sqrt{r_C}}$$<br>改写一下:<br>$$r_C=\frac{r_Ar_B}{r_A+r_B+2\sqrt{r_Ar_B}}$$<br>所以如果 $r_C$ 是一个有理数则 $r_Ar_B$ 必须是平方数.<br>设 $r_A=ta^2,r_B=tb^2,a\le b,\gcd(a,b)=1,t&gt;0$ ,所以我们有三元组<br>$$\left(ta^2,tb^2,\frac{ta^2b^2}{(a+b)^2}\right)$$<br>可以得到 $(a+b)^2|t$ .<br>那么重新令 $r_A=dp^2(p+q)^2,r_B=dq^2(p+q)^2,r_C=dp^2q^2$ ,这就是一对解,枚举互质的 $(p,q)$ ,然后枚举 $d$ 即可.</p><blockquote><p>如何枚举(p,q)?<br>在<a href="https://en.wikipedia.org/wiki/Stern%E2%80%93Brocot_tree">法雷树</a>上进行枚举.</p></blockquote><h2 id="0516">0516</h2><p>5-光滑数是指最大质因数不超过5的数.你要在1e12范围内对于欧拉函数是光滑数的所有数字求和.</p><p>我们发现,满足条件的数字一定有以下性质:<br>$$2^a3^b5^cp_1p_2…$$<br>其中abc随便取,后面的p数组都满足 $p-1=2^x3^y5^z$ .<br>于是我们暴搜所有前半部分和质数部分,拼一起求和.</p><p>但是实际上比较考验剪枝能力.<br>常规枚举每个质数选和不选会T飞.<br>对于一个质数,我们枚举和这个质数下一个相乘的质数,然后递归下去,同时排序之后一旦大于立刻剪枝,这样的质数选择是单调且不重的,而且才能真正快速的算出来答案,见代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">u32 res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> num,i64 prod)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(tmp[i]*prod&gt;lim)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">res+=tmp[i]*prod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=num;i&lt;=ttop;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(prod*pp[i]&lt;=lim)</span><br><span class="line"><span class="built_in">dfs2</span>(i+<span class="number">1</span>,prod*pp[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0555">0555</h2><p>给一个奇怪的函数,找所有 $f(n)=n$ 的点,求和.<br>$$f(n)=\begin{cases}<br>n-a&amp;n&gt;b\\<br>f(f(n+c))&amp;n\le b<br>\end{cases}$$<br>这个函数和0340这个题特别相似,都是大于某个值就返回原数减固定值,小于某个值就套娃加,这种函数的共性就是,和n的差是一个分段函数.</p><h2 id="0577">0577</h2><p>给一个长度为n的正三角形,每条边被长度为1的等分,然后点之间连线,然后让你数每一个不同大小的三角形中的最大正六边形的数目.很妙的找规律题.</p><p>首先模样例,一个长度为1的六边形在更大的三角形中是等差数列的贡献,这个可以O(1)算.然后测6的样例,发现出了一个边长为2的六边形,但是还伴随一个长度为 $\sqrt3$ 的六边形出来,考虑枚举点,但是很难写,这道题被搁置.</p><p>我们换一个思路:由贪心知一个新的六边形中心第一次总是以正三角形中心为中心出现,所以尝试把正三角形中心放到正三角形的边角,只考虑这六分之一的情况,发现正好就是长度为n的能产生n种新三角形,于是做一下前缀和,暴力一下就出来了.</p><h2 id="0581">0581</h2><p>本来打了一个小表看看oeis上能查出来,大喜过望.<br>结果oeis上面没什么有用信息,最后暴搜取上限过了.</p><p>观察到一个性质:如果n和(n+1)都是光滑数,那么n(n+1)也是光滑数.所以枚举所有范围内的质数,暴搜所有数,最后排序,如果出现两个数连着,答案就加上前者.<br>wiki上说由于一个神秘的定理,总之这玩意是有限解的云云,但这对解题没什么帮助,只是告诉你有解…</p><p>还是那句话,假如你要处理很多个已经满足不重的元素,想让它们有序,一定要用vector+sort,比set快一年.<br>笔者用前者跑了7s多,后者跑了52s多…真的快一年了.<br>前者对随机4.8e7的数据能在15s内搜完+排序…</p><h2 id="0601">0601</h2><p>发现可以用CRT做.导一下式子发现都是形如<br>$$n-1\equiv 0\mod i$$<br>这样的式子,直接求lcm,然后先不管最后那个不满足,看看答案有多大.<br>结果答案只有不到3e6的大小,那就直接枚举判断了,再大一点就容斥一下就可以了.<br>这个题端点是取不到的,开区间是坏文明,闭区间是好文明.</p><h2 id="0684">0684</h2><p>解法非常妙的题.</p><p>首先发现满足性质的数字是末尾全是9,头是剩下的数字,也就是 $(x%9)(x/9)$ 这么个形式,于是 <strong>考虑直接+1然后总和减去n</strong> 就能避免因为9导致的无穷级数收敛问题,从而把前面全部转换成一个等比数列.</p><h2 id="0692">0692</h2><p>找规律题.首先考虑直接模拟:设dp[i]表示i的最小个数,转移方程<br>$$dp[i]=\min_{j=1}^{i-1}(dp[i-j]&gt;2j)$$<br>然后得到一个数列,发现(没有发现可以oeis,这个数列不太好瞪眼看出来)数列是前面的数列各种重复,然后最后插一个从来没出现的斐波那契数字.然后直接分段维护前缀和就行了.</p><h2 id="0700">0700</h2><p>给一个数列,求其前缀min等于数列末端元素的和.</p><p>首先跑一下pr发现后面是一个质数.两个数都是1e15级别的数,显然不是暴力能搞定的,因为质数保证了在[0,p]内所有值都会出现一次.</p><p>对于这种题一般有两种解法:求到一半,发现函数再后面几乎无影响了,然后直接交算了一半的解.<br>或者中途换算法.</p><p>发现在2e10左右,欧拉币大小已经收敛到了2e5,此时可以使用exgcd求解值对应的步数,具体地,求解 $ax+by=1$ 然后乘值c,对步数排个序,算一下前缀min.<br>总复杂度 $O(2e10+2e5\log2e5)$ .</p><h2 id="0709">0709</h2><p>你每天能得到一个袋子,你可以选择把之前的袋子任意偶数个套到当前袋子中,也可以让袋子空着,问有多少种情况<br>$$f(n+1)=\sum_{k\le n}^{k\in even}\binom{n}{k}f(k)f(n-k)$$<br>这个式子怎么理解?设f(k)是有k个袋子的情况,当前所有的袋子要合并都会合并到n+1号袋子中,所以先选k个袋子,然后这k号袋子随意套娃产生f(k),最后剩下的n-k个袋子随意套娃产生f(n-k),结果就是这个.</p><h2 id="0725">0725</h2><p>数位dp题.由于本题特殊的性质,我们要枚举非0数字.然后得到一个数字的排列形式,然后枚举:对某个特定位置枚举某个特定数字,然后剩下的数字随便排列,把这个位数上特定数字乘上排列的结果,最后加起来就是答案.</p><h2 id="0731">0731</h2><p>计算一个很复杂的式子的末尾10位,还是考虑小数点右移,然后对剩下的级数求其小数位,注意因为进位问题不能和820再乘十一个做法.</p><h2 id="0755">0755</h2><p>看题解了…<br>居然是个dp…设f(k,s)表示选择斐波那契前k项,所有元素和小于等于s的情况数.转移方程是<br>$$f(k,s)=\begin{cases}<br>0&amp;s&lt;0\\<br>1&amp;k=0\\<br>2^k&amp;\sum_{i=1}^k F_i\le N\\<br>f(k-1,s)+f(k-1,s-F_k)<br>\end{cases}$$<br>假如范围内所有斐波那契数列都小于s,那么随便选,否则排除边界状况之后,新的斐波那契数字可以选也可以不选,答案直接转移即可.</p><h2 id="0757">0757</h2><p>不难推算出来,就是求一个式子 $f(x,y)=x(x+1)y(y+1),x,y&gt;0$ 在 $[1,10^{14}]$ 这个区间有多少个数字,然后最噩梦的地方就在于快速计算这里.</p><p>答案是,没有好办法.你去<a href="https://oeis.org/A072389">OEIS</a>上搜也搜不到公式,这下是谁都帮不了你了.</p><p>怎么办?暴力呗.(看答案傻眼了,vector+sort都是nlog比set和map快了几倍,)</p><p>但是依然有一个比较好玩的性质:笔者暴力的时候发现x在几万的时候,y随便取值,res都基本不变化了,这个时候交一发不知道为啥就过了…</p><p>也许数学题进阶的暴力就是看函数&quot;收敛&quot;之后直接交一发赌一下能不能过???</p><h2 id="0772">0772</h2><p>实在不会做看题解了…<br>题解说只需要暴搜前几项然后oeis…<br>最小数就是 $2\mathrm{lcm}(1,2,…,n)$</p><p>仔细想了想觉得好有道理,但是说不出来为什么这么有道理…<br>草,总之这个题非常诈骗,记住得了…</p><h2 id="0793">0793</h2><p>中位数题做法比较固定,这个题用二分即可解决.<br>然而实际写的时候在二分这里调了很久很久,太唐了,鉴定为写水题写的.</p><h2 id="0816">0816</h2><p>随机点集最短距离,好像是典,通过分治大法可以做到 $O(n\log n)$ ,非常神秘.</p><h2 id="0820">0820</h2><p>求解分数 $\frac ab$ 在n位的小数情况(n=1e7).</p><p>我们把小数点右移,得到 $\frac{a}{b}\times10^{n-1}$ ,而且我们不需要知道整数部分情况,所以求<br>$$\frac{a\times10^{n-1}\mod b}{b}$$<br>这个数字的小数第一位,即<br>$$\left\lfloor\frac{10\times(a\times10^{n-1}\mod b)}{b}\right\rfloor$$</p><h2 id="0836">0836</h2><p>文字游戏.给了一堆很麻烦的定义,但是看最后一句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Give as your answer the concatenation of the first letters of each bolded word.</span><br></pre></td></tr></table></figure><p>你的答案只需要由那堆定义的首字母连起来,实际上的 <code>f(20230401,57)</code> 根本不用求,这是文字游戏.(气炸了)</p><h2 id="0853">0853</h2><p>皮萨诺周期:斐波那契数列对任意一个数取模都会形成一个周期数列,这个周期叫做皮萨诺周期,一个数的最长皮萨诺周期是 $6n$ .</p><p>看了眼thread:对于皮萨诺周期 $p$ ,所有可能的 $n$ 中必须有的性质是:<br>$$n|\gcd(F_{\pi(n)},F_{\pi(n+1)}-1)$$<br>然后暴力检查即可.</p><h2 id="0869">0869</h2><p>一个显而易见的方法是,把所有质数的01做成一颗树,然后跑一遍树形概率DP.</p><p>但是这么着有一个问题,比如 <code>11</code> <code>1111</code> 显然的策略是全部猜1,同时期望是 $3$ ,所以实际上还需要记录一个数字在哪里停止,也就是说前半部分 <code>11</code> 是共有的,前面能分到1的概率,但是后面因为有一个数字在这里停止了,这个&quot;停止&quot;也要分到概率,而且这一层概率分配完了之后不会影响下面的计算.</p><h2 id="0874">0874</h2><p>尝试这么思考:刚开始所有数字全是0,每次往随机数组上加1,总共加k个,这是一轮,直到加到会爆k的限制时不加了.<br>这个时候假设所有数组都是 $k-1$ ,会剩下 $n(m-1)\mod m$ 个数字在数组里面-1.<br>所以答案就是把上面那个数字进行分解,然后取质数相加取max.</p><p>写一个 $O(n^3)$ 的dp即可,设dpij表示前i个数字,使用k个token的最大值,然后计算答案时强制i后面的数字全部是m-1,算贡献.<br>看起来n是7000,复杂度很大,实际上跑到大约1400左右就出最大值了,如果你看到数字几乎不变了,不妨交一发.</p><p>有人说这是个卷积形式,不妨使用FFT优化到 $O(n^2\log n)$ .</p><h2 id="0885">0885</h2><p>所有1e18以内的数字按照数字大小排序去掉前导零后加一起,取模.</p><p>刚开始以为是一个数位dp题,一直不敢做.<br>但是&quot;排序&quot;的性质保证数位dp不好合并,因为要保证之前的数字都大于或小于新枚举的数字.<br>但是这启示我们对数位dfs,只要递增枚举就可以.<br>先简单dp一下,发现1e18的时候递增的数字只有不到4e6个,于是直接dfs枚举所有递增数字算贡献.<br>一个数字在指定最长长度的贡献是<br>$$\binom{lim}{lim-sum}\binom{sum}{a_1}\binom{sum-a_1}{a_2}…\binom{a_9}{a_9}$$<br>意思就是在指定长度内所有数字随便枚举,反正最后前导零被去掉.然后乘上dfs的数字,取个模就结束了.</p><h2 id="0899">0899</h2><p>经过打表发现答案是这么一个函数:<br>$$\sum_{i=1}^n(2(\mathrm{lowbit}(i+1)-1)-[\mathrm{lowbit}(i+1)=i+1])$$<br>化简发现lowbit可以用值域内除2的base解决,剩下的就很简单了.</p><p>lowbit前缀和计算:当前进制下为0的减掉下一个base也为0的(容斥一下).</p><h2 id="0926">0926</h2><p>Flu不知道这个题干该怎么抽象,所以请大家读一下原题面…<br>首先对阶乘分解质因数,落到1e7内的所有质数上.<br>然后对于一个阶,发现是对所有质数取min(就是说,假如质数为2和5,次方分别为2和1,在取20的时候,0会取各个质数的min,也就是得到min(2,1)=1)<br>这启示我们用容斥定理,对每个min的结果,显然是小于2的次方数(实测1e7!中2的次方大概就是1e7),枚举min.<br>对于min,卡出来每个次方的下界(不能低于这个),可以不派出这个因子.但是派出就不能低于枚举的min,最后减掉2的次方数(都不派出),得到 $O(\frac{n}{\log n}\log((10^7)!))$ 大概是1e12的数量级,核心代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=po[<span class="number">1</span>];++i)&#123;</span><br><span class="line">dp[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=ptop;++j)&#123;</span><br><span class="line">dp[i]=dp[i]*(<span class="number">1</span>+po[j]/i)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们发现这个 <code>po[j]/i</code> 是可以分块的,所以对每个质数考虑合并贡献,用区间乘线段树维护,复杂度 $O(\frac n{\log n}\sqrt n\log n)=O(n^{3/2})$ (前边是质数个数,中间是数论分块,后面是线段树操作的复杂度),笔者跑了2s多过了.</p><p>这个题的thread非常有意思,有 $O(n^{3/4})$ 的,有 $O(n\log\log n)$ 的…</p><h1>隐藏题目(Bonus)</h1><p>隐藏题目目前只有五道(20250210),是做题的时候掉落的,不清楚是不是固定掉落,这里给出Flu能看到的隐藏题目名称以及解法(网上的资料还是太少了…)</p><h2 id="problem-1">problem -1</h2><p>If we list all the natural numbers below $10$ that are multiples of $3$ or $5$ , we get $3,5,6$ and $9$ . The sum of these multiples is $23$ .<br>如果我们列出 $10$ 以内 $3$ 或 $5$ 的所有自然数倍数,能得到 $3,5,6$ 和 $9$ ,他们的和是 $23$ .</p><p>Find the sum of all the multiples of $3$ or $5$ below infinity.<br>找到小于正无穷的所有 $3$ 或 $5$ 的自然数倍数和.</p><h3 id="题解-spoiler">题解(spoiler)</h3><p>有一个结论:自然数的和是-1/12,我不会证,网上查到的.然后容斥一下就行了,答案很好算,这里不公布.<br>$$\sum_{i=1}^\infty i=-\frac1{12}$$<br>证明(启发式,一句话就是仙,注意力惊人):设<br>$$S=1+2+3+…,T=1-2+3-4+…$$<br>根据下面的生成函数<br>$$\frac1{(1+x)^2}=1-2x+3x^2-4x^3+…$$<br>然后带入 $x=1$ 得到 $T=\frac14$ ,然后有<br>$$T=(1+2+3+…)-2\times(2+4+6+…)=-3S$$<br>QED.</p><h2 id="problem-18i">problem 18i</h2><p>Let $R(p)$ be the remainder when the <strong>product</strong> $\prod_{x=0}^{p-1}(x^3-3x+4)$ is divided by $p$ . For example, $R(11)=0$ and $R(29)=13$ .<br>设 $R(p)=\prod_{x=0}^{p-1}(x^3-3x+4)\mod p$ ,比如 $R(11)=0,R(29)=13$ .</p><p>Find the sum of $R(p)$ over all primes $p$ between $10^{9}$ and $1.1\times10^9$ .<br>求<br>$$\sum_{i=10^9}^{1.1\times10^9}R(i),i\in prime$$</p><h3 id="题解-spoiler-2">题解(spoiler)</h3><p>Wrong Answers</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>I don’t know(noob).<br>不会(菜).</p><h2 id="problem-Heegner">problem Heegner</h2><p>Among all non-square integers $n$ with absolute value not exceeding $10^3$ , find the value of $n$ such that $\cos(\pi\sqrt n)$ is closest to an integer.<br>在绝对值不超过 $10^3$ 的所有非平方数整数中,找到让 $\cos(\pi\sqrt n)$ 最接近整数的数.</p><h3 id="题解-spoiler-3">题解(spoiler)</h3><p>查阅资料:<br>$$e^{ix}=\cos x+i\sin x$$<br>$$\cos z=\frac{e^{iz}+e^{-iz}}2$$<br>$$\sin z=\frac{e^{iz}-e^{-iz}}{2i}$$<br>直接带式子算就行了…<br>然后被炸 <code>long double</code> 精度,发现事情没有这么简单…<br>最后用python的mpmath库过去了,负数去exp大小能有e42这么大,普通python也会炸精度,难绷.</p><p>事实上查阅维基百科得知&quot;黑格尔数&quot;,页面有一个马尔努金常数,说e的多少次方pi非常接近整数,直接盒出来了,根本不用算(但是这个题确实让Flu学会了使用py的高精度库和类的书写)</p><h2 id="problem-root13">problem root13</h2><p>The decimal expansion of the square root of two is $1.\underline{4142135623}730…$ .<br>根号二的无限循环展开是 $1.\underline{4142135623}730…$ .</p><p>If we define $S(n,d)$ to be the the sum of the first $d$ digits in the fractional part of the decimal expansion of $\sqrt n$ , it can be seen that $S(2,10)=4+1+4+…+3=31$ .It can be confirmed that $S(2,100)=481$ .<br>如果我们定义 $S(n,d)$ 代表 $\sqrt n$ 的前 $d$ 位展开的各位数字和,可以得到 $S(2,10)=4+1+4+…+3=31$ .同理 $S(2,100)=481$ .</p><p>Find $S(13,1000)$ .<br>计算出 $S(13,1000)$ .</p><p>Note: Instead of just using arbitrary precision floats, try to be creative with your method.<br>注意:除了直接用高精度库函数之外,请发挥创造力用自己的办法算出来.</p><h3 id="题解-spoiler-4">题解(spoiler)</h3><p>最简单的一集.方法超级多.</p><ol><li>使用Python的decimal库(前人留库,后人乘凉,不要重复造轮子).</li><li>模拟高精度,把13扩大好多好多倍然后手工模拟计算.</li><li>牛顿迭代(求导算切线)</li><li>泰勒展开(能手算的那种)</li><li>网上的手开根号大法(就是那个乘20啥啥的那个方法)</li></ol><p>总之这个题非常简单,真就白给,拿到题先出的题解再出的代码.</p><h2 id="problem-secret">problem secret</h2><p>Find the secret word by the following instructions below.<br>根据下面的指示找到秘密单词.</p><p>The statement of this problem is contained in an image.<br>这个题目将会在一张图像中进行.<br>Starting with this image, at each step, simultaneously repleace each pixel with the sum of its four neighbours in orthogoanal dirctions.<br>在图上开始,每次同时用与该单元格相邻的四个格子的字母总和替换该单元格的元素.<br>Note that, although the original pixels are represented by 8-bit integers, in later steps they can be arbitrarily large without any<br>integer overflow.<br>注意,虽然每一个字母使用char的8位表示,在计算中他们被认为可以任意大的,不会有溢出.</p><p>The edges of the image are considered “glued” in such a way that pixels on the top edge are neighbours to those on the bottom<br>edge; and similarly for left and right edges.<br>注意:该图被认为是拼接起来的,也就是说下边和上边相邻,左边和右边相邻.<br>As illustration, in the following diagram, where each square represents a pixel, the pixel marked with “A” has neighbours “B” to “E”; and the pixel marked with “a” has neighbours “b” to “e”.<br>如下图,字符 <code>A</code> 的四个相邻格是 <code>BCDE</code> ,字符 <code>a</code> 的四个相邻格子是 <code>bcde</code></p><table><thead><tr><th>x</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>d</td></tr><tr><td>2</td><td>B</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td>A</td><td>E</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>C</td></tr><tr><td>4</td><td>D</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>5</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>b</td></tr><tr><td>6</td><td>e</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>c</td><td>a</td></tr></tbody></table><p>After $10^{12}$ steps, the secret word will be revealed by taking each pixel modulo $7$ .<br>在 $10^{12}$ 步后,通过将每个单元格模 $7$ 来揭示秘密单词.</p><h3 id="题解-spoiler-5">题解(spoiler)</h3><p>I don’t know(noob).<br>不会(菜).</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在这里放一些欧拉计划的心得体会(我不会放答案的,可以放心阅读)…&lt;/p&gt;
&lt;p&gt;欧拉计划是鼓励大家网上搜索除了答案之外的知识的.&lt;/p&gt;
&lt;p&gt;欧拉计划使用 &lt;code&gt;CC-BY-NC-SA 4.0&lt;/code&gt; 协议,所以这篇文档也是这个协议写成的.&lt;br&gt;
&lt;a hr</summary>
      
    
    
    
    <category term="GAME" scheme="https://narafluorine.github.io/categories/GAME/"/>
    
    
    <category term="Math" scheme="https://narafluorine.github.io/tags/Math/"/>
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JS-无限循环</title>
    <link href="https://narafluorine.github.io/2024/11/11/40000_%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF/"/>
    <id>https://narafluorine.github.io/2024/11/11/40000_%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF/</id>
    <published>2024-11-11T12:24:34.000Z</published>
    <updated>2025-07-16T05:41:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>想使用js创建一系列展示技术力的页面,但是众所周知,一个网站又有看板娘,鼠标点击会有华丽特效,完了吧屏幕上还有点会被鼠标吸住,然后页面概述会在切换页面变一个,…,种种特效让博客很卡,实际浏览体验很差,所以Flu打算把这些华丽特效拆开放在不同的页面(谁不喜欢华丽呢?但是华丽的代价就是卡,只好被拆开)</p><p>不是更好的电脑买不起,而是把华丽的特效拆开更有性价比.</p><script>function sayHello() {alert('Hello from JavaScript');}</script><div><button οnclick="sayHello()">Click me</button></div><h1>这是Markdown标题</h1><p>以下是HTML内容：</p><div>  <h1 id="html-title">这是一个HTML标题</h1></div><style>  #html-title {    color: green;  }</style><script>  document.getElementById('html-title').style.fontSize = '4em';</script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;想使用js创建一系列展示技术力的页面,但是众所周知,一个网站又有看板娘,鼠标点击会有华丽特效,完了吧屏幕上还有点会被鼠标吸住,然后页面概述会在切换页面变一个,…,种种特效让博客很卡,实际浏览体验很差,所以Flu打算把这些华丽特效拆开放在不同的页面(谁不喜欢华丽呢?但是华丽的</summary>
      
    
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/categories/OTH/"/>
    
    
    <category term="JavaScript" scheme="https://narafluorine.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>XCPC 2025</title>
    <link href="https://narafluorine.github.io/2024/11/04/20006_XCPC2025/"/>
    <id>https://narafluorine.github.io/2024/11/04/20006_XCPC2025/</id>
    <published>2024-11-04T04:27:36.000Z</published>
    <updated>2025-09-03T09:25:20.583Z</updated>
    
    <content type="html"><![CDATA[<p>美好的新赛季从补题开始.</p><h1>pre</h1><ul><li>小心 $n$ 和 $m$ 写反.</li><li>注意数组不要开小或开大.</li><li>注意计算变量范围,不要能到 <code>long long</code> 的变量开 <code>int</code> .</li><li>感觉容易挂的地方写 <code>assert</code> .</li><li>感觉容易写挂的题,样例很弱的题一定要写对拍.</li><li>注意模数是不是质数.</li><li>注意操作的顺序.</li><li>认真读题,模拟完样例再写程序.</li><li><strong>注意清空数组</strong> .</li><li><strong>相信所有题都是可做的</strong> .</li><li>感觉不可做的,有较高多项式复杂度暴力的题,思考: <strong>分治</strong>,贪心,DP,线段树.</li><li>感觉不可做的,有指数级复杂度暴力的最优化题,思考: 贪心,DP,<strong>流和割</strong>,暴搜加优化.</li><li>感觉不可做的,有指数级暴力的数数题,思考: DP,行列式,暴搜加优化,拉格朗日插值,<strong>容斥</strong>,造自动机.</li><li>后遭,交互题,考虑: 增量法,分治,暴搜策略.</li><li>DP优化:凸优化(wqs),斜率优化,决策单调性,交换状态和值域,减少状态(包含常数上的).</li><li>感觉不可做的题,考虑各个元素,集合之间有什么关系.</li><li>就算过了样例,感觉没问题也要仔细分析一下各种情况,必要时对拍.</li><li>分段函数用vector,常数比map小很多.</li><li><strong>做题别急</strong> .</li><li>任何n较大的,可以快速算单项的东西考虑分段打表.</li><li>子区间问题有时可以类似最大子段和使用线段树维护,也有可能分治.</li></ul><p>Flu感觉很妙的idea才会被留下来,剩余的直接删掉,我这不是题解区.</p><h1><a href="https://qoj.ac/contest/1924?v=1">第一次集训</a></h1><p>Flu出ABC,队友1的G疯狂WA,2的H没开出来.</p><h2 id="K">K</h2><p>位运算炸int了: <code>Map|=(str[i]=='#')&lt;&lt;i</code> 前面半句话会转成int导致i在64左右的范围会直接挂掉.</p><h2 id="I">I</h2><p>题解非常妙,横着看很难,我们发现构造的排列对于一个位置,下一个位置是固定的,也就是说竖着一个除了末尾的字符串下一个出现的位置也是固定的,所以直接哈希检查即可,非常妙的题.</p><h1><a href="https://vjudge.net/contest/706236#overview">第二次集训</a></h1><p>概况:配合的不好,中间出现至少三次两个人开一个题的情况,<br>Flu开局开A,队友B开局也开A,结果这个题到最后都没过,疯狂WA,-6,爽!<br>Qiank出了俩签到,Flu出了一个签到,Qiank开字符串假了然后不想写了扔给我…<br>作为看过AveMujica的人(<s>赤石,豪赤多赤</s>),Flu当然是很快写过了,</p><p>榜单也很好看,开始的时候是倒数第三,剩半个小时的时候出现神之一手,两分钟过两个题,然后一跃正数第三,难绷.</p><h2 id="A">A</h2><p>给定两个罗盘的度数,计算方位角.<br>实际上边界会变,取平均数的时候注意一下(赛时没注意到就WA好多发,)</p><h2 id="C">C</h2><p>题意:你对城市建筑拍一张照,得到像素图,建筑可以被简化为一根柱子.<br>你每次可以询问一个像素点,返回该点是建筑还是天空(没东西),求最高建筑的位置和高度.(交互题,你要在 $12000$ 次询问内返回答案)</p><p>显而易见的结论是,对值域二分检查,nlogn绝对不够用.<br>然后mxx显然不会减小,对更高的值域二分,也显然不够用.<br>首先用一次检查mxx+1判断该楼会不会比当前更高,更高再二分.设想梯度图会被卡,还是不够用.</p><p>我们已经到算法优化的极限了,怎么办???<br>随机化查询坐标.(我人傻了,这也行???)</p><p>于是这个题就被乱搞草过去了…</p><h1><a href="https://vjudge.net/contest/707488#overview">第2.5次集训</a></h1><p>周六和周天是两场集训,正常情况下参加一场即可,Flu周天去要电协的QQ群所以没参加,这是后来补题的.</p><h2 id="F">F</h2><p>括号匹配,但是&lt;&lt;和&gt;&gt;能匹配,&gt;&gt;和&lt;&lt;也能匹配上,给一个这俩组成的序列,你要输出按照括号规则匹配的结果.</p><p>思路:我们强制最左端是 <code>[</code> 打头,不管他是&lt;&lt;还是&gt;&gt;,然后直接匹配即可.</p><h2 id="D">D</h2><p>难点在于给一个数n,你要把它分组,每组可以为0,组之间有顺序,而且你分的组要单调不增,你要O(1)算这个值.</p><p>答案:爆典…<br>其实和n分成任意组(非0),每组不大于m的dp状态是一样的,难点在于证明.</p><p>你竖着想,5可以分成3和2,这是两根柱子.</p><p>然而你横着想,因为单调不增所以你的柱子都是从左打头从右结尾的,而且宽度上限就是m,得证.</p><p>于是Flu会算法还是没做出来,输!</p><h2 id="A-2">A</h2><p>给一个函数 $f((l,r))=(\min(a_{l-r}),\max(a_{l-r}))$ ,q次询问每次lr问最少几次可以让 $f(f(f(f(…f((l,r))))))$ 取到 $(1,n)$ .</p><p>div1的E…有点不敢做.</p><h1><a href="https://codeforces.com/gym/105578">ICPC2024沈阳站</a></h1><h2 id="J">J</h2><p>草,前四个最大值和后四个最大值比较,写的时候犯唐把队名和战力全用string存,结果真的能过样例,(int比较炸了)</p><h2 id="B">B</h2><p>构造两个数列满足 $a_ib_j\mod nm$ 不重.<br>大胆猜,nm不互质无解,然后尝试从nm出发,在n这里构造1+km%nm,在m这里构造1+kn%nm.</p><h2 id="D-2">D</h2><p>先来一个结论:交换两个元素对一个排列的逆序对奇偶性的变化取决于区间差,排列的整体左移右移多少次可以转换为区间上的很多次交换,所以逆序对奇偶性变化可以O(1)算出来.</p><p>所以,给的其实是一个排列,然后交换AB实际上是假的,对哪交换都可以,只需要算出开始的逆序对奇偶性就行了,而且因为刚开始只需要计算奇偶性,甚至能O(n)算出来.</p><h2 id="E">E</h2><p>不会写状压dp了…</p><p>温习一下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">1</span>&lt;&lt;<span class="number">16</span>][<span class="number">16</span>]<span class="comment">//状态为i,结尾为j时最小</span></span><br><span class="line"><span class="keyword">for</span> 枚举状态  </span><br><span class="line"><span class="keyword">for</span> 枚举上一个结尾点</span><br><span class="line"><span class="keyword">for</span> 枚举新加进去的二进制状态</span><br></pre></td></tr></table></figure><h2 id="G">G</h2><p>给n个点,这些点组成一个简单多边形,你最多询问n次,每次返回多边形在 $x=i$ 处的切片长度,你要回答多边形面积.</p><p>很神秘的题.你要计算 $\int_{-1000}^{1000}f(x)\mathrm dx$ 的值,每次询问回答一个点的 $f(x)$ .<br>有一个性质:这个面积函数在x轴两点之间是线性变化的,于是考虑询问端点.具体地:<br>坐标都不相同:f(x)分了(n-1)段,询问分段点即可(两端是0).<br>有相同的:f(x)分了(n-2)段,询问最左最右两个端点,然后对分段区询问中点.</p><p>然而题目返回的是 <code>p/q</code> 的形式, pq 可能很大,使用longdouble最后向0.5取整(发现题目都是整数点,所以答案只可能是 <code>x.0</code> 或 <code>x.5</code> ).</p><h2 id=""></h2><h1><a href="https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7">天梯赛2025</a></h1><p>拒绝写解题报告,语文太烂了读不懂题.</p><h1><a href="https://vjudge.net/contest/708329">第三次集训</a></h1><p>全是思维题.(中间试着打了一下CTF的Warm,感觉很好玩)<br>Flu被队友带飞了,一个题也没做出来…</p><h2 id="A-3">A</h2><p>有一个nm矩阵,部分格子有障碍物(*)否则为空,你要对空格子用[0,k]种颜色涂色,其中[1,k]种颜色同行同列只能出现一次,0颜色可以无限使用,设你用了z个0,代价是 $ck+dz$ ,cd是给定常数,求最小花费.</p><p>题解说是网络流,然而还有一种办法可过.</p><h2 id="H">H</h2><h2 id="E-2">E</h2><p>有一个n节点的环,你每次可以选任意[1,m]个连续节点涂成黑色,对面也要这么做,不能涂色的人输,现在nm多组询问,对每次询问输出谁赢.</p><blockquote><p>先手第一步除非可以直接赢,否则环会被拆成链.然后后手除非m是1否则必然可以把链断成完全相同的两部分,然后后手只需要模仿先手就一定会赢.</p></blockquote><h2 id="G-2">G</h2><p>给n个不覆盖的矩形,你要找出所有的对称轴.注意:假如正方形可能由一个长条+两个小正方形组成,这个正方形依旧有4条对称轴.</p><p>观察发现对称轴必须经过一个点,而且最多有四个,只要能够 $O(n\log n)$ 检查就已经赢了.由于矩形可能是拼起来的,所以常规记录线的方法不可行,要考虑用点记录矩形.</p><p>结论:被偶数个矩形覆盖的点无效(矩形覆盖是仅限边界四个点的),如图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-+      +-x-+</span><br><span class="line">| |      | | |</span><br><span class="line">x-+-+    x-x-x</span><br><span class="line">|   |    |   |</span><br><span class="line">+---+    +---+</span><br></pre></td></tr></table></figure><p>然后直接翻转检查点即可.<br>但是不出意外的话是要出意外了,点绕直线对称的结论是啥来着?<br>$$Ax+By+C=0\\ x’=x_0-2A\frac{Ax_0+By_0+C}{A^2+B^2}\\ y’=y_0-2B\frac{Ax_0+By_0+C}{A^2+B^2}$$</p><h1><a href="https://vjudge.net/contest/708404">第四次集训</a></h1><p>和银趴(Linux <strong>in</strong>stall <strong>par</strong>ty)撞了(悲).<br>全场唐完,刚开始是队友1的D见祖宗了,然后是队友1的G数组开小了(开1e5题干2e5),然后Flu的H结论对了但是不敢写(诈骗)一度悬置这个题.然后队友2的B疯狂WA,然后屡了一下思路之后过了.</p><p>G:单调栈题,没做出来,后来发现是弹&quot;时间差&quot;个元素即可.<br>A:empty中场来到我这说, <code>0011</code> 就是 <code>gugugaga</code> (捣乱来了)…</p><h2 id="A-4">A</h2><p>括号树…是啥?</p><p>首先把0011转换为括号匹配,可知合法不合法.然后建括号树进行拓扑序计数即可.<br>括号树:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">((())())</span><br><span class="line">   / \</span><br><span class="line">(())  ()</span><br><span class="line">  |</span><br><span class="line"> ()</span><br></pre></td></tr></table></figure><p>以某个点为根的树拓扑序(子节点一定要出现在根节点前面)的个数:<br>$$n!\left(\prod_{i=1}^nsz_i\right)^{-1}$$<br>$sz_i$ 表示以 $i$ 节点为根的子树大小.</p><p>看别人的码才发现,逆元有一个 $O(n)$ 的递推方式,之前一直用的快速幂 $O(n\log n)$ 算逆元,常数大的不行.</p><h2 id="E-3">E</h2><p>给一张图代表城市,城市会被水淹,求从1点出发淹没所有城市的最小水高度.</p><p>Flu原先想的是,一个城市被淹的时候走的都是最短路,所以直接对每个城市的边权取min然后对所有城市的min取max就行了,然而不对,比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line">4/ \5</span><br><span class="line">2---3</span><br><span class="line">  1</span><br></pre></td></tr></table></figure><p>这种情况最小边权是4,因为淹没了2之后淹没3是顺手的事.</p><p>所以正解是最小生成树.(最小生成树咋求来着?排序边,并查集…)</p><p>然后是网络流,有一个定理:</p><blockquote><p>最大流==最小割</p></blockquote><h2 id="C-2">C</h2><p>有一个问题: <strong>哈密顿路</strong> 和 <strong>哈密顿回路</strong> 不是一个东西.前者只需要遍历就可以了,后者则需要状压DP.</p><p>然而…<br>树上进行链的合并要动态维护sz,同时由于dp值会发生变化,要开一个辅助数组临时存放,然后在一整个链合并完之后在集中推平,草,合并链都不会写,这么唐吗…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">sz[pos]=<span class="number">1</span>;dp[pos][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v:edge[pos])&#123;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line"><span class="built_in">fill</span>(tmp,tmp+<span class="number">400</span>,<span class="number">-1145141919810</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sz[pos];++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=sz[v];++j)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="built_in">min</span>(i+j<span class="number">-1</span>,<span class="number">2</span>*<span class="built_in">min</span>(i,j));++k)&#123;</span><br><span class="line">tmp[i+j-k]=<span class="built_in">max</span>(tmp[i+j-k],k*num[pos]+dp[pos][i]+dp[v][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> _=<span class="number">1</span>;_&lt;=sz[pos]+sz[v];++_)&#123;</span><br><span class="line">dp[pos][_]=tmp[_];</span><br><span class="line">&#125;</span><br><span class="line">sz[pos]+=sz[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><a href="https://vjudge.net/contest/714948">第五次集训</a></h1><p>决定省赛谁打星的关键比赛,Flu队直接拿第一出线了(empty佬的恩情还不完…),第二次可以不参与了.</p><h2 id="B-2">B</h2><p>设 $f(x)$ 是一个数分解成质数的最小个数.<br>对于偶数,使用哥德巴赫猜想(除了2),必定能够拆成两个奇质数.<br>对于奇数,首先是拆成2和f(奇数-2),然而还可以拆成三个奇质数的和(偶数+奇质数,又是猜想),所以上界是3.</p><h1><a href="https://codeforces.com/gym/103486">VP</a></h1><p>回想起来了括号匹配结论是卡特兰数.</p><h2 id="I-Nim-Game">I Nim Game</h2><p>读假题了…题干要求的是对区间加,然后区间判断nim能不能玩.</p><p>nim能不能玩是用线性基,然后区间加可以用树状数组差分解决.</p><h2 id="C-Random-Number-Generator">C Random Number Generator</h2><p>BSGS…<br>Flu学数学还没看出来这个,真成战犯了…</p><p>回顾BSGS和二次剩余的区别:分别让求<br>$$a^x\equiv b\mod p$$<br>$$x^2\equiv a\mod p$$<br>这俩不一样…</p><h2 id="-2"></h2><h1><a href="https://codeforces.com/gym/105922">吉林省赛</a></h1><blockquote><p>Flu:省赛铜直接退役.</p></blockquote><p>失误:开局QianK一直在开签到,签麻了.<br>失误:Flu线段树用mod当根,取模的时候炸了(我错了我错了).</p><h2 id="C-3">C</h2><p>如何计算巨运算符,如<br>$$pow=\sum_{x_1=0}^{n-1}\sum_{x_2=0}^{n-1}\sum_{x_3=0}^{n-1}a_{(x_1+x_2+…+x_n)\mod n}$$<br>最后发现最后一个就是sum数列或者prod数列,然后考虑向前处理:<br>碰到sum说明有n个这样的数列,所以乘n即可.<br>碰到prod要对其求n次方.</p><h2 id="H-2">H</h2><p>两段区间上要支持区间加上某个数字,你要判断两段区间可以任意交换顺序后是否相等.</p><p>哈希.但是要考虑怎么哈希,赛时想到的方法有:</p><ol><li>维护区间所有和的二次方和.(以及其加强版,维护三次方和(初始时再加一个随机偏移))</li><li>选一个数做底,维护其a次方的和.</li><li>维护区间所有数的抑或和.</li></ol><p>事实上,方法1很容易被卡,加强版过了这个题.<br>方法2好写好调,为什么不写?<br>其实做法3假了,因为区间加和不是区间抑或,所以是没法维护的…</p><p>两段区间是分奇偶的,如何维护?<br>考虑把奇数做成正的,偶数做成负的,判断其加和是否为0即可(所以只需要一颗线段树).</p><h2 id="OTH">OTH,</h2><p>群U说可以直接把交互逻辑写进程序,然后留个开关即可.</p><h1><a href="https://codeforces.com/gym/105924">东北赛</a></h1><blockquote><p>死磕BH失败,铜了…<br>成就:三色牌…(省赛金,东北赛银,全国邀请赛铜…)</p></blockquote><p>失误:死磕.<br>修正:多看题,在写代码之前禁止交流解法,防止被带偏.</p><h1>杂题随机做</h1><p>后面因为期末考试外加各种比赛的原因,根本补不完题,扔最后了…</p><h2 id="CF2043E"><a href="https://codeforces.com/problemset/problem/2043/E">CF2043E</a></h2><p>你有两个矩阵AB,每次能对一行&amp;一个数,也可以对一列|一个数,问最终A能否转换为B.</p><p>正着想把A转成B很难,就倒过来想: <code>&amp;</code> 就是把一列0转换为通配符, <code>|</code> 就是把一行1转换为通配符,然后加到队列里宽搜一下,最后模糊匹配一下答案就出来了.</p><h2 id="gym103428F"><a href="https://codeforces.com/gym/103428/problem/F">gym103428F</a></h2><p>非常好的题.有n堆石子,两个人博弈,每次要拿前面拿的石子数的因数倍,且任选几个大于等于你要拿的数量的石堆拿走这么多石子,问保证你赢的情况下,你有多少种初始拿法?</p><p>首先考虑1的情况,此时必胜当且仅当石堆中存在一个奇数堆,这样的话你把所有奇数堆变成偶数堆,然后 <strong>模仿</strong> 对面怎么拿,你是必赢的.<br>然后考虑不存在奇数堆的情况,全是偶数堆的话用1去拿显然是必输的,因为会被模仿.所以偶数堆直接全部除2直到出现奇数,此时问题变成前面一种情况.<br>答案就是(最小奇数+1)/2.</p><h2 id="洛谷4446">洛谷4446</h2><blockquote><p>把 $x^{1/4}$ 以内的质数全部除掉,剩下的一定是一个立方数或不可开方数.</p></blockquote><p>然后预处理 $x^{1/4}$ 以内的质数,同时处理 $x^{1/3}$ 以内的立方数,就可以对最后二分判定是不是立方数.</p><h2 id="ARC150D"><a href="https://www.luogu.com.cn/problem/AT_arc150_d">ARC150D</a></h2><p>设E(Xi)为i点期望被选中的次数，那么 $ans=∑_{i=1}^n​E(X_i​)$ 。<br>设i点的深度为di。<br>如果一次操作选中了除1到i路径以外的的点，那么对i没有影响，所以只需要考虑选1到i路径上的点的情况。</p><p>允许选中好点，但不算选中好点的贡献，这和原问题是等价的。</p><p>所以问题可以转化为，di个点，每次等概率抽取一个点，抽到第di个点时贡献加1，一直抽直到所有点都被抽到过。</p><p>假设已经被抽到过的点有k个，那么再抽一次抽到未被抽到的点的概率为 $\frac{d_i-k}{d_i}$ ，期望 $\frac{d_i}{d_i-k}$ 抽到下一个未被抽到的点（做某件事情成功的概率为p，期望做 $\frac1p$ 次成功）。</p><p>所以把所有点都抽到的期望次数为 $\sum_{k=0}^{d_i-1}\frac{d_i}{d_i-k}=d_i\sum_{k=1}^{d_i}\frac1k$ ，每次抽到第di个点的概率都是 $\frac1{d_i}$ ，所以第di个点期望被抽到 $\sum_{k=1}^{d_i}\frac1k$ ,</p><p>所以 $ans=\sum_{i=1}^n\sum_{j=1}^{d_i}\frac1j$ .</p><blockquote><p>连带:一个n面色子,问期望多少次能把所有面都投出来.<br>设f(i)表示当前n面色子,投出来了i种颜色.<br>$f(i+1)=f(i)+\frac{n}{n-i}=n\sum_{i=1}^n\frac 1i$</p></blockquote><h2 id="cf1446c"><a href="https://codeforces.com/problemset/problem/1446/C">cf1446c</a></h2><p>给你一堆数,每个数字会找与这个数字抑或和最小的数字连边,最后会形成一张图,你要删掉最少的点使图联通,求最少删几个点.</p><p>首先删点很复杂,我们转化为保留最多的点.<br>显然最后剩下的一定是一棵树,而且只有一对是互相是xor的最小值.</p><p>联想trie树,树上的相邻节点之间满足xor最小(因为前面都一样,后面自然最小),所以建一个字典树维护01.</p><p>如果只有左右儿子,直接返回即可.如果都有,那么根据最长往外延展1个的原理,是max(l,r)+1.<br>直接合并即可.</p><h2 id="CF1778F"><a href="https://codeforces.com/problemset/problem/1778/F">CF1778F</a></h2><p>给你一棵树,树上有点权,每次你可以让一个整个子树乘上子树的gcd(最多做k次操作),问你根节点的值最后最大是多少.</p><p>首先,假如没有k的限制,直接拓扑排序即可.<br>假如没有呢…首先维护子树gcd和所有数的ceilsqrt().<br>ceilsqrt:对于x有最小的c满足c^2是x的倍数.具体地,对x分解质因数之后所有p的次方取 $\lceil \frac i2\rceil$ 最后乘一起就可以了.</p><p>首先,最后答案一定是根乘上根的一个因子.</p><p>其次,因为维护哪里要乘哪里不乘很不方便,所以我们转化为一个判断性问题:<br>对于根节点,倒序枚举所有因子,判断假如说子树要变成这样最少要多少次,然后再比较,就可以很轻松得到答案.<br>所以写一个dfs(num,ko,val):<br>如果子树gcd是val因子,直接返回.<br>否则如果子树gcd的平方是val因子,那么需要对子树进行一次gcd操作,返回.<br>否则如果子树根节点的平方还不是val因子,或者这是个叶节点,那么无法完成操作.<br>然后要对子树进行操作:先操作子树,然后再操作根节点,对于每个子树w要把gcd(w)变成ceilsqrt(d)的倍数,这样就可以把根节点gcd^2(w)是d的倍数,否则完不成操作.<br>dfs传参即可.</p><h2 id="CF1841C"><a href="https://codeforces.com/problemset/problem/1841/C">CF1841C</a></h2><p>给你一个字符串,你最多能更改一位,求最大值.<br>字符串只有ABCDE五种字母,分值分别是1,10,100,1000,10000,一个字母贡献是正的当且仅当右边不存在严格比他字典序大的字母,如ABCDE的贡献是 $-1-10-100-1000+10000$ .</p><p>本来我认为是直接枚举每位是ABCDE,然后只要能O(1)算贡献就完事了,所以pre表示前缀最大,然后倒着枚举,这么着后半段是算出来的,前半段是枚举的,但是这么着会假,比如 <code>AExxxxxxxxx</code> 在枚举E后面的时候AE只会被单纯统计起来,没有大小关系,就会WA,想改正又很难写.</p><p>正确做法是贪心,一个字符想改有两种情况:改大:最左侧的是最优的,能带来最少的负字符.改小:最右侧是最优的,因为有更大的概率是正贡献.所以对10个位置暴力改成其他字符,然后检查即可.</p><h2 id="P1983"><a href="https://www.luogu.com.cn/problem/P1983">P1983</a></h2><p>碰到什么高于什么,联想图论建模和差分约束.</p><p>连边进行拓扑排序分层(找最长链).</p><h2 id="P9211"><a href="https://www.luogu.com.cn/problem/P9211">P9211</a></h2><p>随机化神仙题.</p><p>我们发现,原字符串只会有 $1%$ 的字符会错,而且对你的容错率有足足 $3%$ ,检查没有什么很特殊的性质,考虑随机化.<br>随机化的步骤是:枚举 <strong>所有长度</strong> ,对所有长度随机 $500$ 个位置,假如说这个长度是对的,那么错误字符概率应该期望占比 $1%$ 左右.<br>所以要对长度随机,最后匹配最多的长度会进行深度匹配,也就是遍历所有位置取最大的那个字符.</p><p>笔者本来以为是对长度随机化,所以shuffle了一下就开始深度匹配了,复杂度假的一批…</p><h2 id="P2893"><a href="https://www.luogu.com.cn/problem/P2893">P2893</a></h2><p>给一个序列,你可以把任意数字变大或变小,代价就是差的绝对值,问你把原数组变成单调不减或单调不增的数列的最小代价?</p><p>非常典的题,有很多变式(六倍经验…).<br>首先有一个结论是,当原数组单调的时候,所取值一定在原数组出现过.</p><p>设dpij表示第i个元素取第j个值,i之前元素满足单调的最小代价,有<br>$$dp_{ij}=\min(dp_{i-1,k}+abs(dat_i-val_j)),k\le j$$<br>注意到后半部分是不随k变化的,所以提出来:<br>$$dp_{ij}=\min(dp_{i-1,k})+abs(dat_i-val_j),k\le j$$<br>整一个前缀min就完事了.</p><p>变式1:变成单调不降时最少动多少个元素? $n-LIS$ .</p><p>变式2:变成单调 <strong>递增</strong> 的最小代价?<br>把原数组变为 $dat_i-i\to dat_i$ 然后再跑上面的,意思是我们已经扣掉了增益,然后直接加上就可以了.</p><p>变式3:数据放大(想一个nlogn的做法):<br>(下面都在分析非下降数列)<br>根据贪心的原则,假如说当前有一个数字x,后面来了一个y,假如y不比x小,那么直接加入即可.<br>否则一定x变小或者y变大或者两者都有,但是这个和是一定的.所以显然是取更小的那个更优,于是加上abs之后把顶端max元素弹出,加入两个小的y.<br>贪心nlog即可.</p><h2 id="计数转01-计数视频">计数转01 <a href="https://www.bilibili.com/video/BV1BHtmzDEgL">计数视频</a></h2><p>给一个0-(n-1)的排列,q次询问,每次询问区间[l,r]上所有子区间的mex和.</p><p>考虑转化计数方法:对于i=1~n询问即为区间上有多少个子区间满足mex&gt;=i,只需要枚举mex即可(也就是说012这个区间会因为存在0+1,存在01+1,存在012+1,答案是3)</p><p>枚举0~i出现的最左端left(i)和最右端right(i),对于整个区间的贡献即为(left(i)-l+1)*(r-right(i)+1),也就是必须包含这个小的区间,拆开式子得到<br>$$ans=left(i)\times r-left(i)\times right(i)+left(i)-l\times r-right(i)+1$$<br>使用前缀和优化即可,对于一个区间二分查出最大的子区间left(i)和right(i)被包含的.</p><h2 id="计数转01-2-HihoCoder-1646">计数转01 2 HihoCoder-1646</h2><p>有 $n$ 个包含 01? 的串，每个串的 ? 可以填成 0/1。求在所有情况下把这些串插入字典树得到的树的大小的和。<br>$n \leq 20,|S| \leq 50$。</p><p><strong>字典树大小</strong> 这个东西很难刻画。<br>我们使用经典等价转换：字典树大小等价于本质不同前缀个数，也就是所有串前缀的并。</p><p>于是用容斥计算：$\sum_S (-1)^{|S|-1} LCP(S)$。<br>(用人话说:枚举所有n个字符串的子集,|S|表示枚举的子集大小.LCP(S)的意思是枚举的字符串这里面的公共前缀有多少个)</p><p>直接状压n暴力check即可, $O(2^nn|S_i|)$ ,如果使用集合合并的神秘科技可以优化到 $O(2^n|S_i|)$ ,其中S_i是字符串最大长度.</p><h2 id="计数转概率-AGC030d">计数转概率 AGC030d</h2><p>直接枚举是会爆表的,尝试转成概率:每次有1/2的概率进行操作,最后的答案就是期望乘上2^q种情况.</p><p>设fij表示i位置数字大于j位置数字的概率,一次交换只会影响xy直接比较的元素,所以有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f[x][y]=f[y][x]=<span class="built_in">v</span>(f[x][y],f[y][x]);</span><br><span class="line"><span class="function"><span class="keyword">for</span> j in <span class="title">range</span><span class="params">(<span class="number">1</span>,n+<span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="function">f[x][j]=</span>f[y][j]=<span class="built_in">v</span>(f[x][j],f[y][j]);</span><br><span class="line">f[j][x]=f[j][y]=<span class="built_in">v</span>(f[j][x],f[j][y]);</span><br></pre></td></tr></table></figure><p>最后直接相加再乘上情况数即可.</p><h2 id="计数转概率2-HDU-5396">计数转概率2 HDU-5396</h2><p>有一个表达式，长的是这样：$n$ 个数 $a_1,a_2,…,a_n$，每两个数之间有一个操作符号。每次可以选择一个操作符运算，直到只剩一个数，这个数就是表达式的结果。问所有情况下最后的数的和。 $n \leq 500$</p><p>我们还是考虑转期望。令 $f_{l,r}$ 表示 $[l,r]$ 的答案。那么显然有转移 $f_{l,r}=\frac{1}{r-l}\sum_{k=l}^{r-1} v(f_{l,k},f_{k+1,r},opt_k)$，$v(x,y,opt)$ 表示 $x\ opt\ y$ 的结果。</p><p>最后答案即为 $f_{1,n} \times (n-1)!$。</p><h2 id="P4424"><a href="https://www.luogu.com.cn/problem/P4424">P4424</a></h2><p>神秘找规律题.</p><blockquote><p>对于两个数ab,假设0是或,1是与,从a的低位按照b的低位二进制进行运算(a开头补0),结果等于 $a&gt;b$ .<br>例如 <code>a=0001</code> , <code>b=0010</code> ,运算结果 <code>0|0|0&amp;0|1=1</code> ,直接比较 <code>a&gt;b</code> 也是1(ab高位在右,按照字符串规则去看)</p></blockquote><h2 id="P5339"><a href="https://www.luogu.com.cn/problem/P5339">P5339</a></h2><p>很棒的组合数学题,补齐了板子…</p><p>在这里有结论:假设有四种颜色,每种颜色分别能涂abcd个格子,问你在长度为n的格子上有多少种涂颜色的方案.<br>考虑EGF(EGF卷积的意义就是随意插入混合),把这四个卷积起来最后取第n项就是答案.</p><p>实际卷的时候有一个事情:lim是比abcd和大的第一个2的幂,以及,abcd在做完NTT之后可以直接乘一起取模,然后再做FNTT.</p><h2 id="abc306g">[abc306g]</h2><p>神秘题.问你能否在一张图上走很大步回到原点.</p><p>找环:考虑这些环大小的gcd是数字的倍数,建立正图反图,进行dfs,统计正图深度(反图用于统计谁可以到达原点,否则整这个环是无意义的.)</p><p>然后进行环大小的统计:对于环大小有一个结论:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">abs</span>(dep[i]+<span class="number">1</span>-dep[j])</span><br></pre></td></tr></table></figure><p>使用情景:对于任意正整数a,图上存在一个包含1点的,长度不是a倍数的环的充要条件是对于有向边ij满足深度在上面的式子.可以理解为环上从a到b可以正着走也可以反着走环,所以环的大小被&quot;拼出来&quot;.</p><h2 id="arc185a"><a href="https://atcoder.jp/contests/arc185/tasks/arc185_a">arc185a</a></h2><p>神秘题,看了五分钟不知道怎么写…</p><p>最后还是看题解了,题解说每个人分别有n张牌(草,读假题了,我还以为一共n张牌呢)<br>题解说对于牌一致的情况,在剩最后一张牌前,一定不会输.<br>同时Alice赢面很大,要考虑Alice出完牌Bob剩一张牌的时候Alice会不会输.</p><h2 id="P9318"><a href="https://www.luogu.com.cn/problem/P9318">P9318</a></h2><p>一道手动分治的题…<br>对于某些数据范围,采取不同的做法…乐…</p><p>题面:给你一个乐高墙,长w高h,你有两种方块,是1x1和1x2(高x长),你要用这两种方块铺满整个强,但是要求墙必须是坚固的(也就是相邻两个&quot;柱子&quot;之间必须至少有一个1x2连接在其中),问有多少种方案.</p><p>首先考虑朴素的dp:dp[i][j]表示第i行有j个突起的情况数,有:<br>$$dp_{1,i}=\binom mi$$<br>$$dp_{i,j}=\sum_{k=1}^mdp_{i-1,k}\times\binom{m-k}j$$<br>$$ans=\sum_{i=1}^{m}dp_{n-1,i}$$<br>复杂度O(nm^2).过不去全部数据,考虑其他方案:<br>设dp[i]表示列数为m情况下有n行满足锁死的情况数,f[i]表示i行m列随便选的情况数,我们首先求出所有情况,再通过枚举&quot;中间线&quot;,强制左边锁死,右边随便,整栋墙就是不满足的,所以容斥减掉.<br>$$dp_i=f_i^m-\sum_{j=1}^{i-1}f_{i-j}^mdp_{j}$$<br>$$ans=dp_n$$<br>时间复杂度O(n^2).<br>此时需要我们手动均衡两种复杂度,均摊一下复杂度是 $O((nm)^{\frac43})$ …</p><h2 id="神秘小式子">神秘小式子</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a|b=a^b^(a&amp;b)</span><br><span class="line">a|b=a+b-(a&amp;b)</span><br></pre></td></tr></table></figure><h2 id="CF2136F1">CF2136F1</h2><p>神秘交互题.首先全部填1能得到 $\lfloor\frac xn\rfloor$ ,然后考虑设计一个能够区分[1,n/2]的办法.</p><p>答案居然是构造 $[l,1,l,2,…,l,r]$ 这个能测出来,太惊讶了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;美好的新赛季从补题开始.&lt;/p&gt;
&lt;h1&gt;pre&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;小心 $n$ 和 $m$ 写反.&lt;/li&gt;
&lt;li&gt;注意数组不要开小或开大.&lt;/li&gt;
&lt;li&gt;注意计算变量范围,不要能到 &lt;code&gt;long long&lt;/code&gt; 的变量开 &lt;code&gt;in</summary>
      
    
    
    
    <category term="ACM" scheme="https://narafluorine.github.io/categories/ACM/"/>
    
    
    <category term="Contest" scheme="https://narafluorine.github.io/tags/Contest/"/>
    
  </entry>
  
  <entry>
    <title>CTF</title>
    <link href="https://narafluorine.github.io/2024/11/04/20008_CTF/"/>
    <id>https://narafluorine.github.io/2024/11/04/20008_CTF/</id>
    <published>2024-11-04T04:27:36.000Z</published>
    <updated>2025-09-05T23:33:15.191Z</updated>
    
    <content type="html"><![CDATA[<h1>Kali</h1><p>打CTF的都不好意思说自己不会用Linux…</p><h2 id="共享文件夹">共享文件夹</h2><p><a href="https://zhuanlan.zhihu.com/p/677780893">这个</a><br>地址 <code>/mnt/hgfs/LinuxShare</code></p><h1>MISC</h1><h2 id="Google">Google</h2><ol><li><code>&quot;aaa&quot;</code> 必须出现的词汇</li><li><code>site:aaa.com</code> 只搜索这个网站的结果</li><li><code>-aaa</code> 结果不出现某个词汇</li><li><code>imagesize:500x500</code> 只搜索这么大的图片(像素)</li><li><code>filetype:pdf</code> 只搜索pdf格式的文档</li><li><code>*</code> 通配符,不确定这个位置填啥可以写</li><li><code>aaa or bbb</code> <code>aaa and bbb</code> 返回包含两个词任何一个或者都包含的结果</li><li><code>BEFORE:1999</code> <code>AFTER:1999</code> <code>1999..2000</code> 查询指定年份的材料</li><li><code>related:aaa.com</code> 查询相关的网站</li><li><code>cache:aaa.com</code> 返回这个网站的缓存版本</li></ol><h2 id="Webs">Webs</h2><p><strong>编码</strong>:<br><a href="https://www.cnblogs.com/ruoli-s/p/14206145.html">CTF常见编码</a><br><a href="http://www.hiencode.com/">CTF在线工具1</a><br><a href="https://ctf.bugku.com/tools">CTF在线工具2</a></p><p><strong>取证</strong>:<br>硬盘镜像取证⼯具 FTK Imager AutoPsy<br>内存镜像取证⼯具 Volatility<br>加密容器⼯具 Veracrypt<br>各⼤国内取证技术提供商的⼯具<br><a href="https://forensics.xidian.edu.cn/">取证相关</a></p><p><strong>流量分析</strong>:<br><a href="https://www.jianshu.com/p/9b9438dff7a2">OSI七层模型</a><br><a href="https://blog.supersassw.com/p/ctf-note-misc_3/">流量分析入门</a><br><a href="https://www.cnblogs.com/mq0036/p/11187138.html">Wireshark使用</a></p><h2 id="属性">属性</h2><p>右键查看属性有时候能得到意外之喜…</p><h2 id="gif">gif</h2><p><code>GIF8(47 49 36 38)</code> 是gif文件头,之后常接 <code>9a(39 61)</code> ,注意看提示.</p><p>powershell和cmd不是一个东西…<br>在cmd中拼合文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy /b a.bin + b.bin + c.bin res.bin</span><br></pre></td></tr></table></figure><h2 id="binwalk">binwalk</h2><p>binwalk可以自动检查文件里面杂糅什么文件.</p><p><code>binwalk -e a.xx</code> 则可以直接分离这些文件,根本不用自己查.</p><h2 id="ZIP伪加密">ZIP伪加密</h2><p>ZIP文件格式有两种,其加密标志位分别在不同的位置:</p><p><code>50 4B 01 02 xx xx xx xx 01 08</code> :目录区加密,只需要管 <code>01</code> 改成偶数就行了, <code>08</code> 记录额外信息(不用管).<br><code>50 4B 03 04 xx xx 00 00</code> :局部文件加密标记,仍然是前半部分是偶数表示未加密.<br><code>78 9C AD 50</code> 是Zlib文件的开头编码.</p><p>友情提示,zlib文件(gz)Win可以用cyberchef解压.<br>同时,部分linux自带binwalk.</p><h2 id="傅里叶盲水印">傅里叶盲水印</h2><h2 id="Wireshark">Wireshark</h2><p>抓包软件.</p><p><code>http contains &quot;POST&quot;</code> 搜索内容有 <code>POST</code> 的所有包.<br><code>http.request.method==POST</code> 也可以查找包<br><code>ip.addr==x.x.x.x</code> 查找IP是xxxx的包<br><code>tcp.port==80</code> 查找端口为80的包<br><code>http</code> 过滤所有http协议的包</p><p><code>analysis:Follow TCP stream</code> 是对数据流的分析然后整合成一个完整信息的过程.</p><p><code>ftp</code> 显示所有ftp协议的流.<br><code>ftp-data</code> 显示文件数据(对其追踪能够找到下载了什么)<br><strong>特别注意</strong> :追踪数据流的时候一定要选原始数据另存为,否则会存成hex格式导致打不开文件.</p><p><code>foremost</code> 在Kali上面有这个文件可以自动分离 <code>pcapng</code> 的文件.<br>抓包的时候可能碰到url编码和base64一起用的,如 <code>RDpcd2FtcDY0XHd3d1xhZG1pblw%3D</code> ,其中最后的 <code>%3D</code> 是 <code>=</code> .</p><h2 id="图片宽高改变">图片宽高改变</h2><p>使用脚本破解,原理是CRC校验.</p><h2 id="F5隐写">F5隐写</h2><p>因为这个包用的jdk11,而Flu电脑上装的是jdk17…</p><p><code>&amp; &quot;C:\Program Files\Java\jdk-11.0.2\bin\java.exe&quot; -classpath . Extract 文件绝对路径</code></p><h2 id="png补齐IDAT">png补齐IDAT</h2><p>原理还是CRC校验,使用 <code>pngcheck.exe -v target.png</code> 自动检查计算CRC值是否正确.(Flu做的题里面是把IDAT改成IOAT然后再改图片高度让图片缺了一块,要靠自己补齐,)</p><h2 id="文件夹带私货">文件夹带私货</h2><p>出现文本 <code>xx,txt</code> , <code>PK</code> 值有可能是zip压缩包(zip的创始人名字简写为PK),改拓展名,如果有密码就暴力破解.</p><h2 id="LSB图像隐写">LSB图像隐写</h2><p>因为很多颜色人是分辨不出来的,所以可以使用rgb颜色最低位进行隐写,隐藏信息或者加隐形水印.拉高对比度会显出原形.</p><h1>Crypto</h1><h2 id="Webs-2">Webs</h2><p><a href="https://shal10w.github.io/">大佬博客1</a><br><a href="https://d33b4t0.com/">大佬博客2</a></p><p><a href="https://tool.bugku.com/jiemi/">解密网站</a></p><h2 id="数论基础">数论基础</h2><h3 id="勒让德符号">勒让德符号</h3><p>$$\left(\frac ap\right)=a^{(p-1)/2}\mod p$$<br>意义:判断一个数字是不是模 $p$ 的二次剩余(是1不是p-1(模意义下的-1))0表示a是p的倍数.</p><h3 id="二次剩余的性质">二次剩余的性质</h3><p><code>Quadratic Residue</code> 是二次剩余根, <code>Quadratic Non-residue</code> 表示非二次剩余数字.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quadratic Residue * Quadratic Residue = Quadratic Residue</span><br><span class="line">Quadratic Residue * Quadratic Non-residue = Quadratic Non-residue</span><br><span class="line">Quadratic Non-residue * Quadratic Non-residue = Quadratic Residue</span><br></pre></td></tr></table></figure><h3 id="勒让德符号中质数的性质">勒让德符号中质数的性质</h3><p>$$\left(\frac{-1}p\right)=\begin{cases}<br>1&amp;p\equiv1\mod4\\<br>-1&amp;p\equiv3\mod4\end{cases}$$<br>$$\left(\frac{2}p\right)=\begin{cases}<br>1&amp;p\equiv\pm1\mod8\\<br>-1&amp;p\equiv\pm3\mod8\end{cases}$$<br>这个符号是完全积性函数.</p><h2 id="RC4">RC4</h2><p>一个抑或加密体系,知道一个明文和相同密钥加密得到的密文可以还原另一条明文:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line">msg = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">ct1 = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">ct2 = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 计算密钥流：keystream = msg XOR ct2</span></span><br><span class="line">keystream = <span class="built_in">bytes</span>([m ^ c <span class="keyword">for</span> m, c <span class="keyword">in</span> <span class="built_in">zip</span>(msg, ct2)])</span><br><span class="line"><span class="comment"># 使用密钥流的前37字节解密ct1得到flag</span></span><br><span class="line">flag = <span class="built_in">bytes</span>([c ^ k <span class="keyword">for</span> c, k <span class="keyword">in</span> <span class="built_in">zip</span>(ct1, keystream)])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="AES">AES</h2><p>神秘块加密算法.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">ciphertext=<span class="string">b&#x27;\xa8\xe7X5\x8c\xabcblZj\x16\xb8\r&#125;\xe4\xd4\x18ht\xc3\x12\x95\xa2\x04\xcb@\r\xae\xce\xdaV&#x27;</span></span><br><span class="line">partial_key=<span class="string">b&#x27;qwertyuiop1234&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 穷举密钥的最后两个字节</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line"><span class="comment"># 构建完整密钥</span></span><br><span class="line">full_key=partial_key+<span class="built_in">bytes</span>([i,j])</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment"># 创建AES-ECB解密器</span></span><br><span class="line">cipher=AES.new(full_key,AES.MODE_ECB)</span><br><span class="line"><span class="comment"># 解密密文</span></span><br><span class="line">plaintext=cipher.decrypt(ciphertext)</span><br><span class="line"><span class="comment"># 检查解密结果是否符合flag格式</span></span><br><span class="line"><span class="keyword">if</span> plaintext.startswith(<span class="string">b&#x27;Spirit&#123;&#x27;</span>) <span class="keyword">and</span> plaintext.endswith(<span class="string">b&#x27;&#125;&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;找到flag: <span class="subst">&#123;plaintext.decode(<span class="string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;完整密钥: <span class="subst">&#123;full_key.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"><span class="keyword">continue</span></span><br></pre></td></tr></table></figure><h2 id="常见编码">常见编码</h2><p><a href="https://hackliu.com/?p=245">密码总结1</a></p><p>旗语 中文注音符号 25对色码 维吉尼亚密码(凯撒密码+密钥) 棋盘密码 ASCII<br>仓颉码 五笔 四角号码 郑码 中日韩统一表意文字(和制汉字 韩制汉字,“国字”)<br>adfgx密码</p><p>阴阳怪气编码 喵喵喵语(原理是零度等宽字符编码)</p><p><a href="https://hanzi.unihan.com.cn/GanZhi/Index/">干支纪年法</a><br><a href="http://code.mcdvisa.com/">中文电码</a><br><a href="https://asecuritysite.com/cipher/code_sms">SMS Cipher</a>几个1-8之内的数字<br><a href="https://quipqiup.com/">Q单词表爆破</a><br><a href="http://web.chacuo.net/charsetuuencode">UUencode</a>,示例 <code>89FQA9WMD&lt;V1A&lt;V1S83DY.#&lt;W3$Q,2TM]</code><br><a href="https://www.toolkk.com/tools/jjencode-encode-decode">JJencode</a><br><a href="https://www.toolhelper.cn/EncodeDecode/QuotedPrintable">Quoted-Printable</a><br><a href="https://www.sojson.com/encrypt_rabbit.html">Rabbit加密</a>(CyberChef上的这个巨难使,-1,别用)据说好像是U2开头<br><a href="https://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php">Rot47加密</a>所有字母ascii都在33-126范围<br><a href="https://www.metools.info/code/playfair_186.html">playfair加密</a>关键词&quot;公平&quot;<br><a href="https://www.guballa.de/vigenere-solver">vigenere维吉尼亚密码</a></p><p>碰到 <code>1745347988</code> 这种很大的而且以 <code>174</code> 开头的数字考虑时间.<br>碰到32位字母加数字联想md5,然后<a href="https://cmd5.com">爆破</a>(.hash结尾的更说明了一切)</p><h2 id="ASCII">ASCII</h2><p>注意,ascii编码范围在0-127之间,碰到奇怪的进制可以尝试使用按照ascii值域分组整除密码.<br>看到一堆有超过127的可以考虑整体下移几个数字(rot操作)</p><h2 id="base64">base64</h2><p>出现 <code>ABC...Zabc...z+/=</code> 字符集字样联想base64.<br>代码段出现 <code>/3</code> <code>*4</code> 字样联想base64.</p><h2 id="XOR">XOR</h2><p>一定要记住,xor是可以逆反过来的!!!<br>对于确定是xor加密的字符串,可以尝试通过把 <code>flag&#123;</code> 这个前缀输进去反向解出密钥前几位,然后猜后几位(注意在cyberchef记得勾选UTF-8编码的密钥).</p><h2 id="凯撒密码">凯撒密码</h2><p>尝试差值变换(第一个字符差1,第二个字符差2之类的…)</p><h2 id="RSA签名">RSA签名</h2><p>信息使用你<strong>朋友的公钥</strong>加密,信息的哈希用<strong>自己的私钥</strong>加密,然后朋友用自己的私钥和你的公钥解密,得到哈希和原信息,然后比对一下,就叫做签名.</p><h2 id="RSA">RSA</h2><p>PS: <code>int(&quot;FFFF&quot;,16)</code> 能把字符串转成十六进制数字.</p><blockquote><p><code>hex(d)</code> 一个数字转hex,返回0x啥一堆<br>有的时候给出的十六进制前面带前缀 <code>0x</code> 的同时后面会带后缀 <code>L</code> ,做题交flag不对了可以加上试试.</p></blockquote><p>网上有很全的博客,这里讲一些例题</p><h3 id="0-enc-key">0 <code>.enc</code> <code>.key</code></h3><p>碰到这俩凑一对的去找<a href="http://tool.chacuo.net/cryptrsakeyparse">rsa在线公私钥分解</a></p><h3 id="1-e-16">1 e=16</h3><p>从rsa的角度,e和phi不互质,不存在d.<br>但是从二次剩余的角度,e=16意味着可以折半每次得到c^8,c^4,…逐次得到原始信息.</p><h3 id="2-pqrs-但是next-prime">2 pqrs,但是next_prime()</h3><p>题干很吓人:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alpha=<span class="number">8</span></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = gmpy2.next_prime(p*alpha)</span><br><span class="line">r = gmpy2.next_prime(q*alpha*<span class="number">2</span>)</span><br><span class="line">s = gmpy2.next_prime(r*alpha*<span class="number">4</span>)</span><br><span class="line">n = p**<span class="number">8</span> * q**(<span class="number">16</span>) * r**(<span class="number">32</span>) * s**<span class="number">2</span></span><br></pre></td></tr></table></figure><p>我们发现一个事实:对于一个任意的p,对应的qrs都是确定的.</p><p>所以直接值域二分,比较n大还是小就行了,复杂度O(logn),这个题草过去了.</p><h3 id="3-二项式模">3 二项式模</h3><p>题干:给定<br>$$N=pq$$<br>$$c_1=(2p+3q)^{e_1}\mod N$$<br>$$c_2=(5p+7q)^{e_2}\mod N$$<br>求 $p,q$ .</p><p>通过配平阶数可以得到如下式子:<br>$$c_1^{e^2}=(2p+3q)^{e_1e_2}\mod N$$<br>$$c_2^{e_1}=(5p+7q)^{e_1e_2}\mod N$$<br>因为 $N=pq$ ,所有含pq的都直接忽略:<br>$$c_1^{e^2}=(2p)^{e_1e_2}+(3q)^{e_1e_2}\mod N$$<br>$$c_2^{e_1}=(5p)^{e_1e_2}+(7q)^{e_1e_2}\mod N$$<br>解二元一次方程得到 $p^{e_1e_2}\mod N$ 和  $p^{e_1e_2}\mod N$ .<br>然后求 $\gcd(p^{e_1e_2},N)$ 得到 $p,q$ .</p><h3 id="4-不知道另一半">4 不知道另一半</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">q = getPrime(<span class="number">1024</span>)</span><br><span class="line">r = gmpy2.next_prime(p*q)</span><br><span class="line">n = p*q*r</span><br></pre></td></tr></table></figure><p>出于某种原因,你没有拿到n的另一半数字的phi,怎么解密?</p><p>这里就要引出RSA解密时一个比较重要的性质:对单个质因子即可解密.即RSA只让e对随便一个质数的phi取inv,然后d对这个质数p取模,也能还原出flag.(RSA这下死透了…)</p><h3 id="5-给出-p-q-q-p">5 给出 $p^q+q^p$</h3><p>设 $g=p^q+q^p$ ,有<br>$$g\equiv p\mod q,g\equiv q\mod p$$<br>于是<br>$$p|(g-q),q|(g-p)$$<br>$$(g-p)(g-q)\equiv 0\mod n$$<br>$$g\equiv p+q\mod n$$<br>所以直接就出来了…</p><h3 id="6-已知-msg-2-a-msg-1-b-Franklin-Reiter-attack-相关消息攻击">6 已知 $msg_2=a*msg_1+b$ Franklin-Reiter attack 相关消息攻击</h3><p>据说要用多项式求gcd做…<br>得到的m是原信息.<a href="https://www.anquanke.com/post/id/213821">相关链接</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">franklinReiter</span>(<span class="params">n,e,a,b,c1,c2</span>):</span><br><span class="line">    R.&lt;X&gt; = Zmod(n)[]</span><br><span class="line">    f1 = X^e - c1</span><br><span class="line">    f2 = (a*X + b)^e - c2</span><br><span class="line">    m_ = GCD(f1,f2).coefficients()[<span class="number">0</span>] <span class="comment"># 返回的是首一多项式，coefficients()返回多项式各项式的系数，项式次数递增，所以第0项是常数 </span></span><br><span class="line">    <span class="keyword">return</span> Integer(n - m_) <span class="comment"># 由于tmp其实是 -m % n,所以这里给他转换回去。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GCD</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> a.monic()        <span class="comment"># 返回首一多项式，即多项式最高次的项式系数为1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> GCD(b, a % b)</span><br><span class="line">e = </span><br><span class="line">n = </span><br><span class="line">b = </span><br><span class="line">a = </span><br><span class="line">c1 = </span><br><span class="line">c2 = </span><br><span class="line">m = franklinReiter(n,e,a,b,c1,c2)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure><h3 id="flag长度129位-n长度2048位-然后三份密文得到了-m-2">flag长度129位,n长度2048位,然后三份密文得到了 $m^2$</h3><p>发现flag最大也不会大过几倍的n,所以查出来 $m^2$ 之后暴力试探 $m$ 的值.</p><h3 id="CopperSmith">CopperSmith</h3><p>只知道一个质数多少位,然后剩下的不知道,你要尝试分解n…<br>这里不扯淡,把理论扔一边,讲怎么写Sage脚本,怎么调参.</p><p><strong>调参</strong> :beta是pq相对的大小关系,一般取 <code>0.3-0.5</code> .<br>epsilon是格的大小,越小越精确(算的时间越长),取 <code>0.01-0.5</code> .</p><h4 id="2048位知道前1108位不知道后940位">2048位知道前1108位不知道后940位:</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">n = ...</span><br><span class="line">p_high = ... <span class="comment"># 16进制形式的前1108位</span></span><br><span class="line">e = ...</span><br><span class="line">c = ...</span><br><span class="line"><span class="comment"># 缺失位数</span></span><br><span class="line">missing_bits = <span class="number">940</span></span><br><span class="line"><span class="comment"># 计算p_known = p_high &lt;&lt; missing_bits</span></span><br><span class="line">p_known = p_high * (<span class="number">2</span> ** missing_bits)</span><br><span class="line"><span class="comment"># 定义多项式</span></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = x + p_known</span><br><span class="line"><span class="comment"># X是未知位的最大和值</span></span><br><span class="line">X = <span class="number">2</span> ** missing_bits  <span class="comment"># 因为x小于2^940</span></span><br><span class="line">roots = f.small_roots(X=X, beta=<span class="number">0.5</span>, epsilon=<span class="number">0.03</span>)</span><br><span class="line"><span class="keyword">if</span> roots:</span><br><span class="line">x0 = roots[<span class="number">0</span>]</span><br><span class="line">p = p_known + x0</span><br><span class="line"><span class="keyword">if</span> n % p == <span class="number">0</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p found:&quot;</span>, p)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Found candidate but not factor.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;No roots found.&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="知道低位400求高位112">知道低位400求高位112</h3><p>这个码跑的比上面的快超级多,不知道为什么…</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n=</span><br><span class="line">pl=</span><br><span class="line">x=Zmod(n)[<span class="string">&#x27;x&#x27;</span>].gen()</span><br><span class="line">f=x*<span class="number">2</span>**<span class="number">400</span>+pl</span><br><span class="line">f.monic().small_roots(X=<span class="number">2</span>**<span class="number">112</span>,beta=<span class="number">0.49</span>,epsilon=<span class="number">0.02</span>)</span><br></pre></td></tr></table></figure><h2 id="Knapsnack">Knapsnack</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加密脚本</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag) &lt; <span class="number">48</span></span><br><span class="line">n = <span class="number">48</span>*<span class="number">8</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keygen</span>():</span><br><span class="line">    w = []</span><br><span class="line">    w.append(getRandomNBitInteger(<span class="number">64</span>))</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">        w.append(<span class="number">2</span>*w[-<span class="number">1</span>] + random.getrandbits(w[-<span class="number">1</span>].bit_length()))</span><br><span class="line">    q = <span class="number">2</span>*w[-<span class="number">1</span>] + random.getrandbits(w[-<span class="number">1</span>].bit_length())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r = random.randrange(q)</span><br><span class="line">        <span class="keyword">if</span> GCD(r, q) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    b = [ww*r % q <span class="keyword">for</span> ww <span class="keyword">in</span> w]</span><br><span class="line">    pkey = b</span><br><span class="line">    skey = (w, q, r)</span><br><span class="line">    <span class="keyword">return</span> pkey, skey</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">text: <span class="built_in">bytes</span>, pkey</span>):</span><br><span class="line">    c = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> bit, bb <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="string">&#x27;&#x27;</span>.join(<span class="string">f&#x27;<span class="subst">&#123;b:08b&#125;</span>&#x27;</span> <span class="keyword">for</span> b <span class="keyword">in</span> text).zfill(n)), pkey):</span><br><span class="line">        c += bit * bb</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">pkey, skey = keygen()</span><br><span class="line">c = encrypt(flag, pkey)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密脚本</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Tuple</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mh_decrypt</span>(<span class="params">c: <span class="built_in">int</span>, skey: <span class="type">Tuple</span>[<span class="type">List</span>[<span class="built_in">int</span>], <span class="built_in">int</span>, <span class="built_in">int</span>], n_bits: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Decrypt Merkle–Hellman knapsack ciphertext given secret key (w, q, r).</span></span><br><span class="line"><span class="string">    - c: message</span></span><br><span class="line"><span class="string">    - skey: (w, q, r) where w is the superincreasing sequence (list), q modulus, r multiplier</span></span><br><span class="line"><span class="string">    - n_bits: length of the array (e.g. 48*8 for the challenge)</span></span><br><span class="line"><span class="string">    Returns decrypted bytes (with left-zero bytes stripped).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    w, q, r = skey</span><br><span class="line">    <span class="comment"># modular inverse of r mod q</span></span><br><span class="line">    r_inv = <span class="built_in">pow</span>(r, -<span class="number">1</span>, q)</span><br><span class="line">    <span class="comment"># multiply ciphertext by inverse to remove multiplier (mod q)</span></span><br><span class="line">    c_prime = (c * r_inv) % q</span><br><span class="line">    <span class="comment"># now c_prime should equal sum(b_i * w_i) where b_i in &#123;0,1&#125;</span></span><br><span class="line">    bits = [<span class="number">0</span>] * <span class="built_in">len</span>(w)</span><br><span class="line">    <span class="comment"># Greedy recover since w is superincreasing: go from largest to smallest</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(w)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> c_prime &gt;= w[i]:</span><br><span class="line">            bits[i] = <span class="number">1</span></span><br><span class="line">            c_prime -= w[i]</span><br><span class="line">    <span class="comment"># bits is a list of 0/1, MSB at index 0 if encryption used left-to-right order.</span></span><br><span class="line">    bitstring = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(b) <span class="keyword">for</span> b <span class="keyword">in</span> bits)</span><br><span class="line">    <span class="comment"># Ensure bitstring length is n_bits (zfill was used in encryption)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(bitstring) &lt; n_bits:</span><br><span class="line">        bitstring = bitstring.zfill(n_bits)</span><br><span class="line">    <span class="comment"># Convert bitstring (big-endian) to integer and then to bytes</span></span><br><span class="line">    value = <span class="built_in">int</span>(bitstring, <span class="number">2</span>)</span><br><span class="line">    out_bytes = value.to_bytes(n_bits // <span class="number">8</span>, <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">    <span class="comment"># Original plaintext was right-aligned into n_bits via zfill, so strip leading null bytes</span></span><br><span class="line">    <span class="keyword">return</span> out_bytes.lstrip(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">flag=mh_decrypt(c,skey,<span class="number">48</span>*<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="ECC-椭圆曲线加密">ECC 椭圆曲线加密</h2><p>公开: P,Q两点 a,b椭圆曲线参数<br>保留: k(Q=kP的k)</p><p>加密:随机数字r,求出(rP,msg+rQ)<br>解密:使用私钥k,求出krP=rQ,做差得到msg.</p><p><strong>注意</strong> :假如知道Q=k*P,已知Q和k是反推不出来P的,因为不知道逆元(这里是没有点减法的)…</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad, unpad</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">256</span>)<span class="comment"># 随机模数</span></span><br><span class="line">F = GF(p)<span class="comment"># 限定域</span></span><br><span class="line">E = EllipticCurve(F, [<span class="number">114</span>, <span class="number">514</span>])<span class="comment"># 参数a,b,这是最简单的形式E: y^2 = x^3 + ax + b</span></span><br><span class="line"></span><br><span class="line">P = E.random_point()<span class="comment"># 随机初始点P</span></span><br><span class="line">Q1 = P*<span class="number">1145141919810893</span><span class="comment"># 第一个公钥点</span></span><br><span class="line">Q2 = P*<span class="number">1337133713371337</span><span class="comment"># 第二个公钥点</span></span><br><span class="line"></span><br><span class="line">P.x()<span class="comment"># P点的x坐标</span></span><br><span class="line">P.xy()<span class="comment"># P点的x坐标</span></span><br><span class="line">P.order()<span class="comment"># P点的阶</span></span><br><span class="line"></span><br><span class="line">PP=k*Q<span class="comment"># sage会自动进行圆锥曲线的运算</span></span><br></pre></td></tr></table></figure><h3 id="知道两个Q和对应的k求P">知道两个Q和对应的k求P</h3><p>前提:两个k互质.<br>尝试理解点之间变换的精髓: $P=xQ_1+yQ_2=xk_1Q_1+yk_2Q_2$</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g,u,v=xgcd(k1,k2)   <span class="comment"># Sage 内置扩展欧几里得函数</span></span><br><span class="line">P=u*Q1+v*Q2</span><br></pre></td></tr></table></figure><h3 id="未知P-a-b-mod-已知2P-3P-…-7P">未知P,a,b,mod,已知2P,3P,…,7P</h3><p>ab显然解方程就行了.关键在于p怎么算:<br>把多组数据带进去,做差能得到关于mod的倍数.<br>对很多个这样的倍数求gcd即可求出mod.至此原ECC全部还原,直接求PQ还原答案即可.</p><h2 id="格密码">格密码</h2><p>很好玩的东西.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v=[[],[],...,[]]<span class="comment"># 一个矩阵</span></span><br><span class="line">M=matrix(ZZ,v).LLL()<span class="comment"># 找最近&quot;最小&quot;向量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(M))<span class="comment"># 有的时候M太大了打印不出来,就用str(M)打印即可</span></span><br></pre></td></tr></table></figure><h3 id="在一个模-mathbb-F-2-8-mathbb-F-2-x-X-8-X-4-X-3-X-1-的环中求解线性方程组-Ax-b">在一个模 $\mathbb{F}_{2^8}=\mathbb{F}_2[x]/(X^8+X^4+X^3+X+1)$ 的环中求解线性方程组 Ax=b</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义有限域 F_&#123;2^8&#125;，使用给定的不可约多项式</span></span><br><span class="line">F.&lt;x&gt; = GF(<span class="number">2</span>^<span class="number">8</span>, modulus=x^<span class="number">8</span> + x^<span class="number">4</span> + x^<span class="number">3</span> + x + <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 定义矩阵 A 的整数条目</span></span><br><span class="line">A_int = [</span><br><span class="line">    [<span class="number">77</span>, <span class="number">217</span>, <span class="number">104</span>, <span class="number">173</span>, <span class="number">4</span>, <span class="number">170</span>, <span class="number">15</span>],</span><br><span class="line">    [<span class="number">155</span>, <span class="number">75</span>, <span class="number">159</span>, <span class="number">94</span>, <span class="number">26</span>, <span class="number">99</span>, <span class="number">161</span>],</span><br><span class="line">    [<span class="number">110</span>, <span class="number">36</span>, <span class="number">60</span>, <span class="number">7</span>, <span class="number">246</span>, <span class="number">103</span>, <span class="number">112</span>],</span><br><span class="line">    [<span class="number">17</span>, <span class="number">107</span>, <span class="number">178</span>, <span class="number">67</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">117</span>],</span><br><span class="line">    [<span class="number">56</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">205</span>, <span class="number">0</span>, <span class="number">189</span>, <span class="number">25</span>],</span><br><span class="line">    [<span class="number">162</span>, <span class="number">9</span>, <span class="number">180</span>, <span class="number">33</span>, <span class="number">52</span>, <span class="number">75</span>, <span class="number">127</span>],</span><br><span class="line">    [<span class="number">238</span>, <span class="number">56</span>, <span class="number">32</span>, <span class="number">110</span>, <span class="number">133</span>, <span class="number">95</span>, <span class="number">9</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 定义向量 b 的整数条目</span></span><br><span class="line">b_int = [<span class="number">12</span>, <span class="number">153</span>, <span class="number">112</span>, <span class="number">166</span>, <span class="number">90</span>, <span class="number">180</span>, <span class="number">223</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将矩阵 A 和向量 b 转换为有限域 F 中的元素</span></span><br><span class="line">A_F = matrix(F, <span class="number">7</span>, <span class="number">7</span>, <span class="keyword">lambda</span> i, j: F.fetch_int(A_int[i][j]))</span><br><span class="line">b_F = vector(F, [F.fetch_int(x) <span class="keyword">for</span> x <span class="keyword">in</span> b_int])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解线性方程组 A * x = b</span></span><br><span class="line">x_F = A_F.solve_right(b_F)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将解向量 x 中的每个元素转换为整数表示</span></span><br><span class="line">x_int = [el.integer_representation() <span class="keyword">for</span> el <span class="keyword">in</span> x_F]</span><br></pre></td></tr></table></figure><p>模多项式似乎可以被理解为x位只能是1或0</p><h3 id="神秘加密体系-NTRU">神秘加密体系(NTRU)</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">keygen</span>(<span class="params">pbits, qbits</span>):</span><br><span class="line">    p = getPrime(pbits)</span><br><span class="line">    q = getPrime(qbits)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        a = getRandomNBitInteger(qbits//<span class="number">4</span>) | <span class="number">1</span></span><br><span class="line">        b = getRandomNBitInteger(qbits//<span class="number">4</span>) | <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> GCD(a, b) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    h = a * <span class="built_in">pow</span>(b, -<span class="number">1</span>, q) % q</span><br><span class="line">    pkey = (h, p, q, pbits, qbits)</span><br><span class="line">    skey = (a, b, pkey)</span><br><span class="line">    <span class="keyword">return</span> pkey, skey</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">m, pkey</span>):</span><br><span class="line">    h, p, q, pbits, qbits = pkey</span><br><span class="line">    r = getRandomNBitInteger(qbits//<span class="number">4</span>-<span class="number">1</span>)</span><br><span class="line">    c = (p*h*r + m) % q</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">c, skey</span>):</span><br><span class="line">    a, b, (h, p, q, pbits, qbits) = skey</span><br><span class="line">    mb = c*b % q % (p*a)</span><br><span class="line">    <span class="keyword">if</span> mb % b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> mb // b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError</span><br><span class="line">pkey, skey = keygen(<span class="number">2048</span>, <span class="number">4096</span>)</span><br></pre></td></tr></table></figure><p>把多项式环上的加密算法放到整数环上,可以被构造<br>$$\begin{bmatrix}q&amp;0\\h&amp;1\end{bmatrix}$$<br>这个格,然后使用lll求出最短向量,答案大概率就是ab(噪音消下去了)</p><h3 id="mt19937">mt19937</h3><p>有一个性质是,mt19937的状态只有624种,只需要知道连续的624个输入就能还原整个引擎.<br>内部实现类似&quot;分块&quot;,初始化种子之后进行一轮&quot;twist&quot;会产生624个新的可用随机数,然后输出时候再过一遍仿射变换.<br>这种引擎在密码学上是不安全的,因为输出的仿射变换是可逆的(用了xor运算),且twist操作只和i,i+1,(i+397)%624这三个数有关,也就是说,假设我们知道部分输出,也能逆向出部分引擎的状态.</p><p>还有就是,mt一次会输出32个数字,在py里面如果需要比如说只有8个数字,就会舍掉低位的;<br>如果需要50个数字,会先拼成64位,然后再舍.</p><h3 id="子集和">子集和</h3><p>时间复杂度 $O(n^3\log^2w)$ ,构造下面的格直接跑LLL然后取最上面最小的那个向量即可.<br>$$\begin{bmatrix}1&amp;&amp;&amp;&amp;a_1\<br>&amp;1&amp;&amp;&amp;a_2\<br>&amp;&amp;1&amp;&amp;a_3\<br>…&amp;&amp;…&amp;&amp;…\<br>&amp;&amp;&amp;…&amp;S<br>\end{bmatrix}$$<br>原因是,自己和可以被视作是一个小的向量乘进原先的a矩阵,所以答案可以通过LLL求出来.</p><h2 id="LFSR-反馈啥啥生成器">LFSR 反馈啥啥生成器</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFSR</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vec, mask</span>):</span><br><span class="line">        self.mask = mask</span><br><span class="line">        self.vec  = vec</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        self.vec = self.vec[<span class="number">1</span>:] + [<span class="built_in">sum</span>(self.vec[i]&amp;self.mask[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">512</span>)) &amp; <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> self.vec[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>生成脚本的大意是说,每次都会计算当前vec和mask与的和是不是奇数,然后丢掉最靠前的数字,把算出来的数字加到末尾.<br>只需要二倍mask和vec大小(他俩必须一样大)就能完整还原整个状态,即:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mat=[] <span class="comment"># 构建的矩阵</span></span><br><span class="line">mbt=[[],[],[]] <span class="comment"># 答案矩阵,注意是很多行而不是一行</span></span><br><span class="line">f=GF(<span class="number">2</span>) <span class="comment"># 因为奇偶要对2取模,所以在模2上进行</span></span><br><span class="line">A=Matrix(f,mat)</span><br><span class="line">B=Matrix(f,mbt)</span><br><span class="line">x=A.solve_right(B)</span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment"># mask矩阵</span></span><br></pre></td></tr></table></figure><p>下面是逆向还原状态的脚本,假如mask[0]==0那么mask还得顺推直到找到第一个mask是1的才行,到时候再改.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inv</span>(<span class="params">msk,vec,tar</span>):</span><br><span class="line">res=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">511</span>):</span><br><span class="line">res+=vec[i]&amp;msk[i+<span class="number">1</span>]</span><br><span class="line">res=res&amp;<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> res==tar:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> msk[<span class="number">0</span>]==<span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">assert</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="JSFuck">JSFuck</h2><p>使用 <code>!+[]()</code> 等几个字符实现全部js功能的加密方式.使用 <code>CPH Judge</code> 套上 <code>console.log()</code> 的壳直接跑.粘贴到浏览器会有很多问题,又是禁止粘贴不明代码又是不信任啥的,怎么跑个代码这么难,死妈浏览器</p><h2 id="抑或加密">抑或加密</h2><p>好像再跑一遍就回去了.</p><h1>Reverse</h1><h2 id="IDA-EXE-ELF">IDA(EXE ELF)</h2><p>用F5查看反汇编的C代码.<br>Shift+F12能查看字符串界面</p><p>IDA反编译的代码大部分可以直接粘到C++去跑,有一个特例: <code>4*i</code> 改成 <code>i</code> 是因为在反编译界面是按字节统计的,但是C++界面是正常的内存下标取址,取址公式不一样导致偏差.</p><p>IDA反编译的代码很原始,数组有可能在反汇编时拆成一堆变量,导致函数传参是数组但是表现为一个参数,发生&quot;RE&quot;.举例:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov  [ebp+var_20030], 5Ah ; <span class="string">&#x27;Z&#x27;</span>v7[<span class="number">0</span>] = <span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line">mov  [ebp+var_2002C], 4Ah ; <span class="string">&#x27;J&#x27;</span>v7[<span class="number">1</span>] = <span class="string">&#x27;J&#x27;</span>;</span><br><span class="line">mov  [ebp+var_20028], 53h ; <span class="string">&#x27;S&#x27;</span>v8    = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">mov  [ebp+var_20024], 45h ; <span class="string">&#x27;E&#x27;</span>asmv9    = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">mov  [ebp+var_20020], 43h ; <span class="string">&#x27;C&#x27;</span>-&gt;v10   = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">mov  [ebp+var_2001C], 61h ; <span class="string">&#x27;a&#x27;</span>tov11   = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">mov  [ebp+var_20018], 4Eh ; <span class="string">&#x27;N&#x27;</span>C++v12   = <span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">mov  [ebp+var_20014], 48h ; <span class="string">&#x27;H&#x27;</span>v13   = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">mov  [ebp+var_20010], 33h ; <span class="string">&#x27;3&#x27;</span>v14   = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">mov  [ebp+var_2000C], 6Eh ; <span class="string">&#x27;n&#x27;</span>v15   = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">mov  [ebp+var_20008], 67h ; <span class="string">&#x27;g&#x27;</span>v16   = <span class="string">&#x27;g&#x27;</span>;</span><br></pre></td></tr></table></figure><p>Shift+F12可以查看字符串区.</p><h2 id="Jadx-gui-APK-CLASS">Jadx_gui(APK CLASS)</h2><p>apk函数的main函数位于 <code>xxx.com</code> 里面的 <code>MainXxxx</code> .</p><h2 id="总结">总结</h2><ol><li><p><code>*11110100001010000101111#</code> 有可能是一个迷宫类型的题目.</p></li><li><p>端序:大端序:高位字节存在低地址处,低位字节存在高位地址处.(x86 arm)<br>小端序:高位字节存在高位字节处.(通过网络发送数据进行传输)<br>IDA的数据是大端序(比如 <code>char* arr=0x776F646168LL</code> )需要先转成char,即 <code>wodah</code> 然后再反转成 <code>hadow</code> 才是实际上字符串的样子.</p></li><li><p>常见函数的方向<br><code>strcat(a,b)</code> a&lt;-b 把b字符串加到a字符串末尾<br><code>strcpy(a,b)</code> a&lt;-b<br><code>a=join(b,c)</code> a&lt;-b+c 组合字符串<br><code>fill(a+1,a+1+n,b+1)</code> a&lt;-b</p></li></ol><h1>Web</h1><p>Web低手.</p><h2 id="BurpSuite">BurpSuite</h2><ol><li>监听用法:开启本地代理,然后占一个端口.然后启动!,监听那个端口,然后所有经过的流量就都能被监听.(感觉原理是本地部署一个假的VPN网关)</li><li>修改Cookie用法:还是先启动,然后在页面找到Cookie(Raw)然后发送给Repeater,在这里能随意修改,改好之后点击Apply就能获得反应(flag居然这么神奇就出来了)</li><li>爆破id:使用内嵌浏览器,刷新页面收到一个请求,然后暴力枚举id,然后按照返回请求的长度排序,看最长的,然后找到Renderer(渲染器)得到flag.</li><li>爆破密码:同上</li></ol><h2 id="nc">nc</h2><p>netcat指令,Windows有一个nc的实现,用法:cmd套一个nc64.exe<br>然后输入你想连的IP和端口,输入之后没反应,flag呢???<br>实际上你连接计算机之后,你这就是一个小的bash,你要输入指令获得flag.</p><h2 id="pwntools">pwntools</h2><p>使用py脚本远程连接服务器(代替nc指令)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> remote</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">conn=remote(<span class="string">&#x27;socket.cryptohack.org&#x27;</span>,<span class="number">11112</span>)</span><br><span class="line"></span><br><span class="line">data_to_send = &#123;</span><br><span class="line"><span class="string">&quot;buy&quot;</span>: <span class="string">&quot;flag&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 把json格式转成str格式</span></span><br><span class="line">json_data = json.dumps(data_to_send)</span><br><span class="line"></span><br><span class="line">conn.sendline(json_data.encode())<span class="comment"># 发送服务器的格式是byte,所以要encode</span></span><br><span class="line"></span><br><span class="line">response = conn.recvline().decode()<span class="comment"># 接收也是byte,转str要decode,recvall()是接收所有信息,recvall会一直接收</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Server response:&quot;</span>, response)</span><br><span class="line"></span><br><span class="line">conn.close() <span class="comment"># 关闭连接</span></span><br><span class="line"><span class="comment"># 此外conn还有一个recvuntil(str)判定指定字符串的,可以过滤废话</span></span><br></pre></td></tr></table></figure><p>json交互</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">json_recv</span>():</span><br><span class="line">    line = r.recvline()</span><br><span class="line">    <span class="keyword">return</span> json.loads(line.decode())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">json_send</span>(<span class="params">hsh</span>):</span><br><span class="line">    request = json.dumps(hsh).encode()</span><br><span class="line">    r.sendline(request)</span><br></pre></td></tr></table></figure><h2 id="HackBar">HackBar</h2><p>能够自定义好多协议的啥啥东西(http头字段),在这里写一点这么多多多选项都是啥.</p><ul><li>User-Agent 使用什么浏览器</li><li>DNT 希不希望被跟踪(1是不希望)</li><li>X-forwarded for 你上网的原始IP</li><li>Via 好像是服务器代理的url</li><li>Referer 该请求的来源</li></ul><h2 id="PHP">PHP</h2><p>php笑传之 <code>Capture Capture Bug</code> ,下文是代码简析.</p><p>show_source(<strong>FILE</strong>) :让背后php代码变得五颜六色,同时展示在前端.<br>include(“a.php”) :插入脚本.<br>/index.php :一个首页面.<br>/index.phps :后缀为phps的是存放php源代码的,但不是所有网站都有.</p><ol><li>url编码:cyberchef的url编码有一个小锅,不会把字母数字也使用url编码,所以要使用burpsuite的编码器进行url编码.同时,浏览器键入的url会进行一层解码,所以记得再加一层</li><li>数字和字符串弱类型比较,如果字符串一定要比数字大可以构造一个比数字大的字符串,然后末尾添一个 <code>a</code> 表明这是个字符串绕过比较.</li><li>array_search搜字符串绕过:字符串与数字比较会转成0,然后0==0直接绕过返回true,需要搜索的字符串不一定要存在了.</li><li>php get传参 <code>/?a=112&amp;b[]=abc&amp;c=&#123;&quot;m&quot;:a,&quot;n&quot;=[[],0]&#125;</code> 上面表示了几种不同方式的参数传递.</li><li>伪协议… <code>php://xxx</code> 和 <code>data://xxx</code> 等多刷几个题再更</li><li>file协议:能把源文件变成base64格式再展示,省的有些flag被当成代码被处理掉了… <code>/?file=php://filter/convert.base64-encode/resource=flag.php</code></li></ol><h2 id="Py-nc">Py nc</h2><p>让Python能够和nc服务器&quot;友好交互&quot;的脚本,拿到flag之后程序会因为连接关闭立刻终止.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=remote(<span class="string">&#x27;61.147.171.105&#x27;</span>,<span class="number">52881</span>)</span><br><span class="line"><span class="built_in">print</span>(io.recvuntil(<span class="string">b&#x27;开局前的最后一句废话&#x27;</span>))</span><br><span class="line">io.sendline(<span class="string">b&#x27;N&#x27;</span>) <span class="comment"># 开始游戏</span></span><br><span class="line">io.recvline() <span class="comment"># 读掉一行空行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">pile=io.recvline().strip()  <span class="comment"># 读一行,去掉两端空白字符</span></span><br><span class="line">start=pile.find(<span class="string">b&#x27;: &#x27;</span>) <span class="comment"># 输入是 arr:114 514 xxx</span></span><br><span class="line">piles=<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,pile[start+<span class="number">2</span>:].split(<span class="string">b&#x27; &#x27;</span>)))</span><br><span class="line"><span class="comment"># begin your code</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># end your code</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;count:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(res).encode()) <span class="comment"># 交互使用encode过的一个字符串</span></span><br><span class="line"><span class="built_in">print</span>(io.recvline()) <span class="comment"># 看服务器说了啥(一行)</span></span><br></pre></td></tr></table></figure><h2 id="backup">backup</h2><p>常见备份文件后缀名:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.bak</span><br><span class="line">.git</span><br><span class="line">.svn</span><br><span class="line">.swp</span><br><span class="line">.bkf</span><br><span class="line">.bash_history</span><br><span class="line">.~</span><br></pre></td></tr></table></figure><h2 id="优先级">优先级</h2><p>windows或Linux下:</p><p><code>command1 &amp;&amp; command2</code> 先执行command1,如果为真,再执行command2<br><code>command1 || command2</code> 先执行command1,如果为假,再执行command2</p><p><code>command1 | command2</code> 只执行 command2<br><code>command1 &amp; command2</code> 先执行 command2 后执行 command1</p><h2 id="Linux大杂烩">Linux大杂烩</h2><p>学Web不可避免的温习Linux.</p><ol><li><code>ls /</code> 意思是 <code>ls ~/</code> .</li><li><code>/home</code> 是用户主工作目录.</li></ol><h2 id="Sql注入">Sql注入</h2><p>首先确认是使用什么闭合的,比如 <code>'</code> 或者 <code>&quot;</code> (方法:输入带 <code>'</code> 或 <code>&quot;</code> 的账号看报错).</p><p>然后使用<a href="https://zhuanlan.zhihu.com/p/485448815">万能密码</a>:<br><code>账户</code>: <code>a' or true #</code> 由于#会当成特殊字符,要使用url编码 <code>a' or true %23</code><br><code>密码</code>: <code>a' or true #</code> 由于#会当成特殊字符,要使用url编码 <code>a' or true %23</code></p><h1>PWN</h1><p><a href="https://https//www.cjovi.icu/">大佬博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Kali&lt;/h1&gt;
&lt;p&gt;打CTF的都不好意思说自己不会用Linux…&lt;/p&gt;
&lt;h2 id=&quot;共享文件夹&quot;&gt;共享文件夹&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/677780893&quot;&gt;这个&lt;/a&gt;&lt;br&gt;
地址 &lt;cod</summary>
      
    
    
    
    <category term="CTF" scheme="https://narafluorine.github.io/categories/CTF/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
    <category term="Game" scheme="https://narafluorine.github.io/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>Atcoder 2025</title>
    <link href="https://narafluorine.github.io/2024/11/04/20009_ATC_2025/"/>
    <id>https://narafluorine.github.io/2024/11/04/20009_ATC_2025/</id>
    <published>2024-11-04T04:27:36.000Z</published>
    <updated>2025-08-03T18:29:18.564Z</updated>
    
    <content type="html"><![CDATA[<h1>abc404</h1><h2 id="F">F</h2><p>概率DP.要求以下式子:<br>$$dp[i][j]=\max_{c_1+c_2+…+c_i=m}\frac1n\sum dp[i-1][j-c_i]$$<br>然后使用数的分解,暴力分拆出c,保证枚举的单调性,复杂度大概是 $O(m^3)$ .</p><h2 id="G">G</h2><p>写法建议:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;array&lt;i64,3&gt; &gt;edge;</span><br></pre></td></tr></table></figure><p>建图,u,v,val,再也不用重写结构体,cmp直接对类型另起一个比较就行.</p><p>头一次碰到 <em>差分约束</em> 的题.</p><h2 id="差分约束">差分约束</h2><p>想办法变成图论题跑最短路(或最长路)的算法(你需要一个额外的点对所有点跑单源最长路).</p><p>考虑下式:<br>$$A_i-A_j\le c$$<br>从 $i$ 往 $j$ 连一条边权为 $c$ 的有向边.(最长路还是这么建边,但边权是 $-c$ )</p><p>求最小解:按上述方式建图跑最短路.</p><h3 id="转化-按照你要求的最短路还是最长路去加边">转化(按照你要求的最短路还是最长路去加边)</h3><p><code>a_i==a_j</code> :连两条边</p><p>$$A_i-A_j\le0$$<br>$$A_i-A_j\ge0$$</p><h3 id="要求的东西">要求的东西,</h3><p>最短路:求最大差值.<br>最长路:求最小差值(反着来).<br>是否存在解:是否存在负环(最长路是正环).<br>是否无穷:最短路后答案是不是 <code>inf</code> ,最长路同理检查是不是 <code>-inf</code> .</p><h1>abc415</h1><p>中间翘了两场abc,rating被扣成狗了…</p><h2 id="F-2">F</h2><p>赛时因为调的时间太长了没过掉…<br>回顾线段树:单点修改,查询区间内有多少个段(11223是3个段:11,22和3)<br>这个时候要用到:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l,r 线段树的参数</span><br><span class="line">val,len 当前区间内最大值,当前区间的长度是多少</span><br><span class="line">lc,ls 左端点字符,左端点起始的长度</span><br><span class="line">rc,rs 右端点长度,右端点起始的长度</span><br></pre></td></tr></table></figure><p>传参的时候记住, <strong>如果左右段中间匹配上且左段整段一致,那么左段左长度要拼起右段左长度</strong> ,右段同理.<br>因为这个调半天红温了…</p><h2 id="G-2">G</h2><p>换可乐问题:你有n瓶可乐,商店有好多种政策:用ai换bi瓶可乐,你想最大化喝到的可乐数量.( $a_i&lt;b_i\le 300,n\le10^{15}$ )</p><p>换可乐问题其实是一个类似背包dp的东西:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">300</span>;++i)&#123;<span class="comment">//枚举ai</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;lim;++j)&#123;<span class="comment">//当前多少可乐最后喝到的个数</span></span><br><span class="line">dp[j]=<span class="built_in">max</span>(dp[j],dp[j-i+b[i]]+b[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//范围内dp</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;lim;++i)&#123;<span class="comment">//最后再加原先有的可乐数量</span></span><br><span class="line">dp[i]+=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后对于n非常大的情况显然逮住一个最划算的往死里换是最划算的.直到进了某个范围内再使用dp的值.<br>这个范围在本题中是 $K(K+1)$ ,其中 $K$ 是值域.取1e5也是可以的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n&lt;lim)res=dp[n];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">i64 cnt=(n<span class="number">-91000</span>-ip)/(ip-iq)+<span class="number">1</span>;<span class="comment">//换的次数</span></span><br><span class="line">res+=(cnt*(ip-iq))+cnt*(iq);<span class="comment">//前面是换一个减掉的 后面是换一个得到的</span></span><br><span class="line">n-=cnt*(ip-iq);</span><br><span class="line">res+=dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>abc416</h1><h2 id="E">E</h2><p>最短路问题,忘了怎么写了复习一下.</p><p>floyd的枚举是对该边更新的,也就是<br>$$dpij=mxa(dpij,dpix+dpyj,dpiy+dpxj)$$<br>所以更新是n方的.<br>同理,机场之间的航线可以新开一个点表示,所有机场到达新点的权重是t,新点到其他所有机场的权重是0.</p><h3 id="为什么疯狂WA">为什么疯狂WA???</h3><p>Floyd的枚举是kij,不是ijk,给我记死了!!!</p><h2 id="F-3">F</h2><p>树形dp,有点难写.<br>树上链形式的dp都有一个套路:<br><code>dp[i][j][k]</code> 节点i的子树中有j条链,其中i的情况是k(0不在任何一条路径上1作为端点2在链里面)</p><p>转移时首先链的条数要倒着枚举(背包).<br>然后枚举在链里面的情况:i作为端点和枚举的子v点也作为端点合并,以及i本身就在链里面,这个时候枚举子树v的杂链(0,1,2).<br>然后枚举端点情况:也是合并与合并杂链.<br>最后枚举i不在链上的情况:也是合并与杂链合并.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> ko)</span></span>&#123;</span><br><span class="line">dp[num][<span class="number">1</span>][<span class="number">1</span>]=dat[num];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:edge[num])&#123;</span><br><span class="line"><span class="keyword">if</span>(i==ko)<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(i,num);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=k;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=j;++l)&#123;</span><br><span class="line"><span class="keyword">if</span>(l)</span><br><span class="line">dp[num][j][<span class="number">2</span>]=<span class="built_in">max</span>(dp[num][j][<span class="number">2</span>],dp[num][j-l+<span class="number">1</span>][<span class="number">1</span>]+dp[i][l][<span class="number">1</span>]);</span><br><span class="line">dp[num][j][<span class="number">2</span>]=<span class="built_in">max</span>(dp[num][j][<span class="number">2</span>],dp[num][j-l][<span class="number">2</span>]+<span class="built_in">max</span>(&#123;dp[i][l][<span class="number">0</span>],dp[i][l][<span class="number">1</span>],dp[i][l][<span class="number">2</span>]&#125;));</span><br><span class="line"><span class="keyword">if</span>(l&amp;&amp;j-l)&#123;</span><br><span class="line">dp[num][j][<span class="number">1</span>]=<span class="built_in">max</span>(dp[num][j][<span class="number">1</span>],dp[num][j-l][<span class="number">0</span>]+dat[num]+dp[i][l][<span class="number">1</span>]);</span><br><span class="line">dp[num][j][<span class="number">1</span>]=<span class="built_in">max</span>(dp[num][j][<span class="number">1</span>],dp[num][j-l][<span class="number">1</span>]+<span class="built_in">max</span>(&#123;dp[i][l][<span class="number">0</span>],dp[i][l][<span class="number">1</span>],dp[i][l][<span class="number">2</span>]&#125;));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(l)</span><br><span class="line">dp[num][j][<span class="number">1</span>]=<span class="built_in">max</span>(dp[num][j][<span class="number">1</span>],dp[num][j-l][<span class="number">0</span>]+dat[num]+dp[i][l][<span class="number">1</span>]);</span><br><span class="line">dp[num][j][<span class="number">0</span>]=<span class="built_in">max</span>(dp[num][j][<span class="number">0</span>],dp[num][j-l][<span class="number">0</span>]+<span class="built_in">max</span>(&#123;dp[i][l][<span class="number">0</span>],dp[i][l][<span class="number">1</span>],dp[i][l][<span class="number">2</span>]&#125;));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-3">G</h2><p>给你1e5个最长10的字符串,你可以重复使用某一个字符串,但是一共要用k个,你要拼出来一个字典序最小的字符串输出.</p><p>首先,字符串相同长度一定会取最小的那个,所以实际上你只需要对10个字符串进行k次.<br>考虑贪心:我们发现对于字符串 $A&lt;B$ 有 $C+A&lt;C+B$ ,但是 $A+C\cancel&lt;B+C$ ,所以我们要倒着枚举.答案的最后根据贪心应该是所有字符串中字典序最小的那个,我们尝试倒着枚举后面的C(长度小于10或者是完整的后部分),然后对其拼凑一个最小的前面的字符串A,以此类推,最后答案倒序输出.</p><h1><a href="https://atcoder.jp/contests/dp">AT_dp_contest</a></h1><p>atcoder的dp场,一共26题.</p><h2 id="J-Sushi">J Sushi</h2><p>你有n碟寿司,上面只可能放1或2或3个寿司.每次你会随机一个数,然后把那个盘子上的一个寿司吃掉(没有就不吃),问你吃完所有寿司的期望随机次数是多少.</p><p>首先发现盘子的排列和答案无关,因为概率都一样,所以答案只和寿司为1,2,3的个数有关.<br>设 <code>dp[i][j][k]</code> 表示剩1个寿司剩i,2个寿司剩j,3个寿司剩k三种情况时的期望次数.有<br>$$dp[i][j][k]=\frac{n-i-j-k}{n}dp[i][j][k]+\frac{i}{n}dp[i-1][j][k]+\frac{j}{n}dp[i+1][j-1][k]+\frac{k}{n}dp[i][j+1][k-1]+1$$<br>然后化一下式子,dfs一下算出来就可以了…</p><h2 id="W">W</h2><p>n条线段,每个线段覆盖lr区间,如果区间内存在一个数是1,那么答案就加上wi(可能是负的),问最大答案是多少?</p><p><strong>人们说有一个典</strong> :每个线段在区间可以右端点计算贡献能够不重不漏,所以按照区间右端点排序.</p><p>设dp[i][j]表示当前正在看第i个点,前面最近第j个位置是1的最大值.<br>首先转移dp[i][i]即在第i个点放1:<br>$$dp[i][i]=\max_{j=1}^{i-1}dp[i-1][j]$$<br>然后转移dp[i][j]即在第i个点放0:<br>$$dp[i][j]=dp[i-1][j]+\sum_{l_k\ge j,r_k=i}val_k$$<br>观察发现i维似乎可以省略,所以空间变成O(n).</p><p>我们需要一个区间取max,区间加和的线段树,复杂度降成nlogn.<br>具体地:线段树开n的空间,代表dp[j]的值,i在枚举中体现.<br>转移ii的时候注意可以不选,那么就是0.<br>转移ij是直接在原位置对所有结尾是r的线段加上val.</p><p>最后答案和0取max,应对所有线段权值均为负的情况.</p><h2 id="Y-Grid-2">Y Grid 2</h2><p>给一个HxW的网格,你只能往下走或者往右走,网格上有n个点不能走,问有多少种情况.</p><p>容斥dp:设 $dp[i][op]$ 表示从初始点走到第i个点,经过op个点(偶数或者奇数个点)的情况数,最后答案就是<br><strong>ans=所有情况-sum(flag*从i点走到终点的情况*从起点走到i点的经过点情况)</strong></p><h1><a href="https://atcoder.jp/contests/typical90/tasks/">AT_typical90</a></h1><p>atcoder经典90题,据说非常劲爆,全是典.</p><h2 id="015">015</h2><p>对于给定的 $N$ ,求对于1-n的x,数列1-n里面任意选元素满足任意两个元素差值大于等于x的情况.</p><p>对于固定的 $x$ ,里面最多有 $\lceil\frac{n}{x}\rceil$ 个元素.<br>枚举元素,设为 $k$ ,有 $k-1$ 个空隙,也就有 $(k-1)(x-1)$ 个元素不能选.<br>所以对于 $x,k$ 答案是 $\binom{n-(k-1)(x-1)}{k}$ ,拓展即可得到<br>$$f(x)=\sum_{i=1}^n\binom{n-(x-1)(i-1)}{i}$$<br>由于整除数列的收敛性,复杂度是nlogn.</p><h2 id="025">025</h2><p>设 $f(x)=\prod x_i$ 给了一个函数返回数字各位的乘积,求 $\sum_{i=0}^n\left[i-f(i)=m\right]$ 这个式子,n,m范围都是1e11.<br>发现 $f(x)$ 的取值非常少,所以从f(x)下手:<br>dfs所有数字排列(显而易见的剪枝是强制数列单调),枚举所有f(x),这个时候由于f(x)已经确定了,x也就可以根据上面的式子算出来.<br>由于枚举的数字排列是可以随意组合的,所以判断是不是解只需要把x拆开和枚举的数字比较.</p><p>时间复杂度有点玄学,1e11跑了700ms.<br>Flu没做出来是因为只发现解很少,尝试从解入手,思路歪了.</p><h2 id="030">030</h2><p>计算 $\sum_{i=1}^n[\omega(i)=k]$ ,其中 $\omega$ 表示不同质因子数.<br>前置知识:<br>$$\frac12+\frac13+\frac15+\frac17+\frac1{11}+…\sim\ln\ln(x)$$<br>所以我们枚举每个质数,对其直接乘倍数,模拟埃氏筛在区间直接计算即可,复杂度 $O(n\log\log n)$ .<br>听说还可以做到 $O(n)$ ,但是看起来就很麻烦…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;abc404&lt;/h1&gt;
&lt;h2 id=&quot;F&quot;&gt;F&lt;/h2&gt;
&lt;p&gt;概率DP.要求以下式子:&lt;br&gt;
$$dp[i][j]=&#92;max_{c_1+c_2+…+c_i=m}&#92;frac1n&#92;sum dp[i-1][j-c_i]$$&lt;br&gt;
然后使用数的分解,暴力分拆出c,保证枚举</summary>
      
    
    
    
    <category term="ACM" scheme="https://narafluorine.github.io/categories/ACM/"/>
    
    
    <category term="Contest" scheme="https://narafluorine.github.io/tags/Contest/"/>
    
  </entry>
  
  <entry>
    <title>文案</title>
    <link href="https://narafluorine.github.io/2024/10/31/30010_%E6%9C%89%E8%B6%A3%E6%96%87%E6%A1%88/"/>
    <id>https://narafluorine.github.io/2024/10/31/30010_%E6%9C%89%E8%B6%A3%E6%96%87%E6%A1%88/</id>
    <published>2024-10-31T08:07:49.000Z</published>
    <updated>2025-07-15T17:31:12.084Z</updated>
    
    <content type="html"><![CDATA[<p>人不能把有限的精力放到无限的寻找段子中去,所以这里几乎停止维护.</p><h2 id="大病AI绘图">大病AI绘图</h2><p>在上海买了杯蜜雪冰城,然后被赶出上海了…<br>然后配图是买了杯蜜雪冰城,东方明珠突然变成防御塔开始攻击我…</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6jks28xu.png" alt=""><br>我到上海说了句方言,东方明珠塔突然变成防御塔开始攻击我.<br>但是说的是粤语.从地下突然钻出广州塔开始攻击东方明珠…</p><p>上面配图非常神金</p><h2 id="积分">积分</h2><p>什么?这不是积分符号,这是一堆撬棍,遇水变答辩稿</p><h2 id="鸭子定律">鸭子定律</h2><ol><li>如果一个动物走路像鸭子、说话像鸭子、长得像鸭子、啄食也像鸭子，那它肯定就是一只鸭子。</li><li>即使在最理想的条件下，鸭子也不可能成为雄鹰，无论其多么高贵也无论其出于多么善良</li><li>鸭子可以伪装成雄鹰，可一到危难时刻它就会原形毕露。</li><li>不抛弃自己的蹼掌，不脱胎换骨换取鹰爪和利喙，鸭子永远也变不成雄鹰。</li><li>鸭子是高贵的，不能因其是鸭子而不是雄鹰就被小视。</li><li>即使最伟大的鸭子也不如一只普通的鹰飞得高。</li><li>鸭子喜群居，雄鹰独自飞。雄鹰永远不可能与鸭子为伍。</li><li>鸭子的呷呷叫声从来都得不到回应。没有人知道这是为什么。</li></ol><p>(最后一个一定要注意,有的问题你永远找不到答案)</p><h2 id="奇怪码风系列">奇怪码风系列</h2><ol><li>忘记了自己写的是C++,根本看不懂</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">[</span><br><span class="line">rd=[]&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">std::cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;,</span><br><span class="line">wt=[](<span class="keyword">auto</span> x)&#123;</span><br><span class="line"><span class="built_in">return</span> (std::cout&lt;&lt;x,<span class="number">0</span>);</span><br><span class="line">&#125;,</span><br><span class="line">sorted=[](<span class="keyword">auto</span> x)&#123;</span><br><span class="line">std::<span class="built_in">sort</span>(x.<span class="built_in">begin</span>(),x.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;,</span><br><span class="line">forn=[](<span class="keyword">auto</span> f,<span class="keyword">auto</span> n)&#123;</span><br><span class="line"><span class="keyword">while</span>(n--)<span class="built_in">f</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">]&#123;[&amp;,_=forn(</span><br><span class="line">[&amp;]()<span class="keyword">mutable</span>&#123;</span><br><span class="line"><span class="keyword">auto</span> n=<span class="built_in">rd</span>();</span><br><span class="line"><span class="keyword">auto</span> k=<span class="built_in">rd</span>();</span><br><span class="line">[&amp;,a=std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n)]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">[&amp;,_=std::<span class="built_in">generate_n</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">size</span>(),rd)]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">[&amp;,ans=(k==<span class="number">1</span>&amp;&amp;a!=<span class="built_in">sorted</span>(a)?<span class="string">&quot;NO\n&quot;</span>:<span class="string">&quot;YES\n&quot;</span>)]()&#123;</span><br><span class="line">[_=<span class="built_in">wt</span>(ans)]()&#123;&#125;;</span><br><span class="line">&#125;();</span><br><span class="line">&#125;();</span><br><span class="line">&#125;();</span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">rd</span>()</span><br><span class="line">)</span><br><span class="line">]()</span><br><span class="line">&#123;&#125;();</span><br><span class="line">&#125;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>新运算符,趋近于(假的),现实是被拆成(i–)&gt;0</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(i--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不想献血该怎么说">不想献血该怎么说</h2><p>您好，是这样的，我的大脑现在档期排满，没办法分出多余的脑细胞来思考，如果你要询问的话呢，您可以先向我本人反应，这边由耳朵转告给小脑和脊柱，由身体各部门在星期日的身体例会上开会讨论，如果出结果会在15个工作日之内告诉您。</p><p>关于最近出现的用血难，献血少的问题，我们这边高度重视，迅速展开全体会议，召开第一次关于献血问题的全体身体班子的先行会议，讨论要不要献血，怎么献血，献多少，去哪献，如何建立健全完整有效的献血流程，达到规范化，科学化，制度化，做到全程工作记录，献前有纪律，献后有保障，社会治理，群力群策，完备工作台账，同时，在明年6月前召开关于第一次献血会议的扩大会议，征询更大范围人民群众意见和建议，在下半年准备细化各项工作流程，预计在2025年底前落实相关工作准备，2030年前献出第一笔血。</p><h2 id="The-Zen-of-Python">The Zen of Python</h2><p>在py里面输入import this得到下文:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful is better than ugly.</span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">Simple is better than complex.</span><br><span class="line">Complex is better than complicated.</span><br><span class="line">Flat is better than nested.</span><br><span class="line">Sparse is better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren&#x27;t special enough to break the rules.</span><br><span class="line">Although practicality beats purity.</span><br><span class="line">Errors should never pass silently.</span><br><span class="line">Unless explicitly silenced.</span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="line">Although that way may not be obvious at first unless you&#x27;re Dutch.</span><br><span class="line">Now is better than never.</span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line">If the implementation is hard to explain, it&#x27;s a bad idea.</span><br><span class="line">If the implementation is easy to explain, it may be a good idea.</span><br><span class="line">Namespaces are one honking great idea -- let&#x27;s do more of those!</span><br></pre></td></tr></table></figure><p>zen的意思是&quot;禅&quot;,在这里可以理解为原则.</p><h2 id="单词">单词</h2><p><code>aftermath</code> n.(战争,事故,不快事情,<s>数学</s>的)后果,创伤<br><code>cram</code> v.(为应考)临时死记硬背,临时抱佛脚</p><h2 id="偷偷往你的奶茶里放">偷偷往你的奶茶里放</h2><p>丙酸睾酮隔天4毫升，丙酸区它雄酮隔天5毫升，醋酸群波龙隔天4毫升，美替诺龙隔天4毫升，司腾博龙隔天3毫升，曲托龙隔天3毫升，生长激素每天早4IU晚4IU针剂麻黄碱训练前一瓶，口服特立补训练前十粒，口服美替诺龙训练前十粒，氧雄龙训练前20粒，康复龙训练前十粒，康力龙训练前十粒，M1T训练前十粒，克伦训练前五粒T3四粒睡前美睾酮10粒，康力龙十粒，口服美替10粒，抗雌阿诺曲错每天一粒，卡麦角林一周两粒周一一粒周日一粒保护剂跟上</p><h2 id="程序猿的菜谱">程序猿的菜谱</h2><p>2024年12月31日 元旦群友聚会晚宴菜谱:<br>1、Linux（麻辣企鹅）<br>2、golang（炒田鼠）<br>3、PHP（大象肉炒竹笋）<br>4、Python（蛇肉煎蛋）<br>5、rust（香焖大闸蟹）<br>6、Perl（爆炒骆驼肉，炸蝴蝶）<br>7、SQL（红焖海豚肉，海狮肉段）<br>酒水：Java（咖啡）<br>甜点：cookie（曲奇）<br>餐具：git fork（叉子）<br>时间：12月31日晚上18:00恭候，18:30开席</p><h2 id="崩铁匹诺康尼文案">崩铁匹诺康尼文案</h2><p>(让我想想…接下来该干什么呢?)</p><p>(喝一瓶苏乐达解闷)</p><p>吨…吨…吨…</p><p>哦, no…你早该学会听取理性的意见的.这下糟了.</p><p>一团胀气开始在你的下腹部聚集,随后化作汹涌的热浪扶摇直上.</p><p>它毫不费力地突破了你人体构造的每一道关卡,并撬开了你自控力为0的嘴巴;最终,它化作了一滩七色彩虹状的呕吐物,摧毁了你精心布置的工作环境.</p><p>周围本就寥寥无几的客人全都被这骇人的一幕吓跑了…或许这也是一种另类的减轻工作负担的方式.</p><p>这下,你理应学到教训了吧?</p><p>你将这一切怪罪于姬子和瓦尔特 $\cdot$ 杨–作为列车组的大家长,他们没有教会你 $\lceil$ 自制力 $\rfloor$ 在充满诱惑的现代社会中是多么重要.</p><p>(再来一瓶苏乐达.)</p><p>不,绝对不行.你听见了吗?绝,对,不,行.</p><p>你颤抖着抽回了那只情不自禁的手.你这一生如履薄冰…绝对不能因为一瓶小小的碳酸饮料导致自己走不到对岸.</p><h2 id="PTA-你值得拥有">PTA,你值得拥有</h2><p>你说的对，但是《吸吸皮吸》是由Check You自主研发的一款全新开放世界冒险游戏。游戏发生在一个被称作「Pleasant Teacher Alert」的幻想世界，在这里，被神选中的人将被授予「神之相机」，导引相机之力。你将扮演一位名为「艾斯么」的神秘角色，在自由的旅行中邂逅性格各异、能力独特的同伴们，和他们一起打题，找回Check You 失去的勤韧 ——同时，逐步发掘「吸吸皮吸」的真相。</p><h2 id="嘻假假-你也值得拥有">嘻假假,你也值得拥有</h2><p>你说得对，但是《C语言》是由贝尔实验室自主研发的一款全新高级编程语言。程序运行在一个被称作“内存”的虚拟世界，在这里，被神选中的人将被授予“指针”，导引地址之力。你将扮演一位名为“程序员”的神秘角色，在自由的旅行中邂逅码风各异、不写注释的同伴们，和他们一起击败异常，找回失散的指针——同时，逐步发掘“段错误”的真相。</p><h2 id="刑法">刑法</h2><p>《中华人民共和国刑法》 第三百六十三条</p><p>【制作、复制、出版、贩卖、传播淫秽物品牟利罪】以牟利为目的，制作、复制、出版、贩卖、传播淫秽物品的，处三年以下有期徒刑、拘役或者管制，并处罚金；情节严重的，处三年以上十年以下有期徒刑，并处罚金；情节特别严重的，处十年以上有期徒刑或者无期徒刑，并处罚金或者没收财产。<br>【为他人提供书号出版淫秽书刊罪】为他人提供书号，出版淫秽书刊的，处三年以下有期徒刑、拘役或者管制，并处或者单处罚金；明知他人用于出版淫秽书刊而提供书号的，依照前款的规定处罚。</p><h2 id="末流985">末流985</h2><p>（网上抄的）吉林大学真的是末流985吗？</p><p>答：是的</p><p>根据高德地图，吉林大学前卫南区西边有一条河（经评论区指出 叫永春河），往南两公里是一个水库（经评论区提出，叫八一水库），就是河的尽头。</p><p>所以吉林大学是处于这条河末流的985。</p><p>简称末流985。</p><h2 id="Frieren歌词">Frieren歌词</h2><p>Far beyond the end<br>Where we may meet again<br>One last time<br>One last goodbye</p><h2 id="珂学">珂学</h2><p>在太阳西斜的这个世界,置身天上之森.等这场战争结束后,不归之人与望眼欲穿的众人,人人本着正义之名,长存不灭的过去,逐渐消逝的未来.我回来了,纵使日薄西山,即使看不见未来,此时此刻的光辉,盼君勿忘.</p><blockquote><p>世界上最幸福的女孩-珂朵莉</p></blockquote><h2 id="英语小点">英语小点</h2><p><code>0 coins</code> 英语中除了1是单数别的全部是复数,零也是复数.</p><h2 id="MRE缩写大全-Meal-Ready-to-Eat">MRE缩写大全(Meal Ready to Eat)</h2><p><code>Meal Rejected by Enemy</code> 敌人都不吃的饭<br><code>Meal Rejected by Everyone</code> 没人要吃的饭<br><code>Meal Rarely Edible</code> 难以下咽的饭<br><code>Man Refuse to Eat</code> 人们拒绝吃的饭</p><h2 id="恩情课文-张希校长用石子击毁哈工大飞机">恩情课文-张希校长用石子击毁哈工大飞机</h2><blockquote><p>忠橙 恩芹(一种土特产)</p></blockquote><blockquote><p>蟠桃 紫柚(与之相对的土特产)</p></blockquote><p>结束人大会议回来的张希校长全然不顾身体的疲惫，连夜找我们几个学生商量希餐的安排。谈得晚了，便送我们出门，要研究生送我们回家。在去日新楼的路上，我们说:“校长， 您回去休息吧。您刚从人大会议回来。”校长摇摇头，“不碍事，你们知道现在国际上有很多人把吉林大学当作大专，不断给我们制造麻烦，你们是吉大的未来，你们的事情便是吉大的事情，是头等大事。”我们都激动了， 眼裏噙著泪花。多好的校长呀。</p><p>张希校长抬头看看远方说:“如果学科评估真像这日新楼这般高就好了，但是就有一些学校，像哈工大，要搞乱这个吉大，他们是罪人。”说著，张希校长弯下腰，从花坛旁捡出一个石子，然後看著远方说:“该死的韩杰才。” 说著他把石子奋力向前一掷。很快就见天上一个小点突然发出震耳欲聋的巨响，然後就坍塌下来。“这是哈工大的飞机，他们一直拍摄我们没有空调的寝室，侵犯我们主权，我已经忍了很久了。” 张希校长愤愤地说。同学们都鼓起掌来，为帝国有这样的校长感到自豪。</p><p>一会校长叫来秘书问:“那个飞机掉到什麽地方了？”“好像是温都尔汗一带。”秘书说。 张希校长一怔，说:“赶紧派人去查，看有什麽问题没有。”之后张希校长送我们到日新楼大门口，一直挥手到看不见我们。第四天我们听说温都尔汗那边出事了，我们很紧张。而这时校长叫我们过去。 他依然那么慈祥，让我们坐下说:“提高排名总是要有牺牲的。为吉大复兴牺牲的人是伟大的。”他这时低下头说:“但我必须承认，我当时摧毁敌人飞机的行为太鲁莽了，我在这里向全校学生和教职工道歉。我将向全校OA说明情况。”</p><p>我们顿时热泪盈眶，多好的校长呀，他在跟敌人斗争过程中的小失误竟然被他记在心里，还道了歉，我们在将来的工作中一定要向张希校长学，学他那宽广的胸怀，和勇于征服的精神。</p><h2 id="CS恩情课文-C爷爷用指针打掉Java对象">CS恩情课文-C爷爷用指针打掉Java对象</h2><p>从缓冲区访问回来的C爷爷全然不顾身体的疲惫，连夜找我们几个系统级编程语言商量内存分配的安排。谈得晚了，便送我们出函数，要全局变量送我们回内存。在去操作系统的路上，我们说：“ C爷爷，您回去休息吧。您刚从缓冲区回来。”;</p><p>C爷爷摇摇头，“不碍事，你们知道现在国际上有很多编程语言把系统级编程语言当作敌人，不断给我们制造不兼容，你们是系统级编程语言的未来，你们的事情便是系统级编程语言的事情，是头等大事。”我们都激动了，眼里噙着分号。多好的C爷爷呀。;</p><p>C爷爷抬头看看内存说：“如果世界真像这内存这么安静就好了，但是就有一些面向对象编程语言，像Jvav、像Python、像JvavScript、像PHP，要搞乱这个世界，他们是罪人。”;</p><p>说着，C爷爷弯下腰，从&lt;stdio.h&gt;里捡出一颗指针 int* ptr = (int *)0x（scanner变量的内存地址），然后看着内存说：“该死的垃圾回收。”;</p><p>说着他把指针奋力向上一掷。很快就见一格内存突然爆发出耀眼的2,147,483,648，然后就buffer overflow下来。“这是Java的scanner对象，他们一直在内存里盘旋，占据我们的空间，我已经忍了很久了。”C爷爷愤愤地说。系统级编程语言们都鼓起掌来，为系统级编程语言有这样的领导者感到自豪。;</p><p>一会C爷爷叫来编译器问：“那个指针落到什么地方了？”“好像memory leak了。”编译器说。;</p><p>C爷爷一怔，说：“赶紧派人去查，看有什么问题没有。”之后C爷爷送我们到大门口，一直挥手到看不见我们。;</p><p>第四天我们听说内存那边出事了，我们很紧张。而这时C爷爷叫我们过去。;</p><p>他依然那么慈祥，让我们坐下说：“便利总是要有牺牲的。为内存管理事业牺牲的指针是伟大的。”他这时低下头说：“但我必须承认，我当时利用指针进行内存管理忘记free掉的行为太鲁莽了，我在这里向x86-64指令集道歉。我将向x86-64指令集说明情况。”;</p><p>我们顿时热泪盈眶，多好的C爷爷呀，他在跟Java斗争过程中的小失误竟然被他记在心里，还道了歉，我们在将来的学习中一定要向C爷爷学，学他老人家那宽广的胸怀，和不耻下问的精神。;</p><h2 id="魔怔题解-AT-abc380-g-题解">魔怔题解(AT_abc380_g 题解)</h2><p>如你所见,这是一道diff为 $1995$ 的题目,看上去十分困难.</p><p>你十分惊慌，恐怕这道题你根本就无法做出来，马上就要面临着 rating $-114$ 的到来.</p><p>你冷静地思考了一会，发现这是你最擅长的逆序对题目，你逐渐有了一些自信。</p><p>你发现如果把序列分成三段： $[1,i−1],[i,i+k−1],[i+k,n]$ ，那么三段之间互相的逆序对影响不会改变，设总的逆序对数量为 $s$ ，当前长度为 $k$ 的区间里的逆序对数量为 $t$ ，则只要求出 $s−t$ ，再加上这段区间的期望逆序对数量，最后除以 $n−k+1$ 就好了。</p><p>前面这一步可以用树状数组快速解决，但是区间的期望逆序对数量该如何求出？</p><p>在耀眼的光芒中，你看见了可爱的 lxy，她只给了你六个字符 <a href="https://www.luogu.com.cn/problem/CF749E">CF749E</a> ，让你自己领会。</p><p>在艰难的探索中，你终于发现，因为两个数形成逆序对的概率是 $\frac{1}{2}$ ​，所以 $\frac12C_n^2$<br>就是长度为 $n$ 的排列的期望逆序对数。</p><p>你非常高兴，很快就打出了一份代码，它十分的正确，仅一遍就通过了样例，并获得了一个绿色的 AC。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n,k,a[N],sum,now,ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;<span class="keyword">while</span>(x&lt;=n)c[x]+=k,x+=x&amp;-x;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="type">int</span> ans=<span class="number">0</span>;<span class="keyword">while</span>(x)ans+=c[x],x-=x&amp;-x;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));&#125;</span><br><span class="line">&#125;A;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inv</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y=mod<span class="number">-2</span>)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(y)&#123;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;--i)sum+=A.<span class="built_in">ask</span>(a[i]),A.<span class="built_in">add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">A.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=k;i&gt;=<span class="number">1</span>;--i)now+=A.<span class="built_in">ask</span>(a[i]),A.<span class="built_in">add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">ans=sum-now;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-k;++i)&#123;</span><br><span class="line">A.<span class="built_in">add</span>(a[i],<span class="number">-1</span>);</span><br><span class="line">now-=A.<span class="built_in">ask</span>(a[i]);now+=A.<span class="built_in">ask</span>(n)-A.<span class="built_in">ask</span>(a[i+k]);</span><br><span class="line">A.<span class="built_in">add</span>(a[i+k],<span class="number">1</span>);ans=(ans+sum-now)%mod;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;(ans*<span class="built_in">inv</span>(n-k+<span class="number">1</span>)+k*(k<span class="number">-1</span>)%mod*<span class="built_in">inv</span>(<span class="number">4</span>))%mod;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你醒过来，原来这一切都是梦。</p><p>你根本就没有看 G，而是被 F 卡了半个多小时，注定只能获得一个失败的青色 perf。</p><h2 id="软微圣经">软微圣经</h2><p>北大软微学子励志语录,版权来自北大软微考研群友，如有雷同，不胜荣幸。</p><p>拼搏百天，我要上北大深埋!!!</p><blockquote><p>创世记</p></blockquote><p>第一节</p><p>当你获得北大学籍的那天，一切都将作废。你的本科作废，你的专业作废，星星作废，月亮作废，银河系作废，宇宙作废，你的爱作废，你的恨作废，你的前半生作废，你的现女友作废。悬梁五战终上北大，大雪深埋垃圾本科！</p><p>第二节</p><p>群里又哑巴了？每次看你们都聊得火热 但是只要我发了一句话 或者一个字 甚至一个表情 群里顿时就没了声音 怎么 我是灾星？瘟神？看到我就跑 是么？你们聊啊 我插不了嘴的 我一来你们就死群了，我观察了你们一早上从七点多开始聊到刚刚 我一出来就没人聊天了 有那么巧吗？原来你们私底下都已经是认识的朋友了是吧？我就说怎么聊不进去，原来多余的一直是我！我懂了，快乐是你们的，我没有。我今天算是整明白了 加了好友没有一个理我 群里插话也插不进去 艾特人家也不理你 好 我偏不退 就呆在这儿看你们聊</p><p>第三节</p><p>我总觉得大多数人这样度过一生好像欠缺点什么。我承认这种生活的社会价值，我也看到了它的井然有序的幸福，但是我的血液里却有一种强烈的愿望，渴望一种更狂放不羁的旅途，那就是软微</p><p>第四节</p><p>凡是圣软微之光所能照耀的地方，就是燕园所在之地</p><p>第五节</p><p>有软微的地方，就是燕园</p><p>第六节</p><p>愿圣软微之光普照大地</p><p>第七节</p><p>生命从来不曾离开过软微而独立存在。无论是我们出生、我们成长、我们相爱还是我们成功失败，直到最后的最后，软微犹如影子一样存在于生命一隅。</p><p>第八节</p><p>有一个夜晚我烧毁了所有和软微有关的记忆，从此我的梦就透明了，有一个早晨我扔掉了所有与软微交叉的昨天，从此我的脚步就轻盈了。</p><p>第九节</p><p>软微就是软微，四海列国，千秋万载，就只有一个软微。岂是一千个一万个信科能代替得了的？</p><p>第十节</p><p>圣光将与你们同在，当你选择北大软微的那一刻，你就已经是神的孩子了</p><blockquote><p>何为神记</p></blockquote><p>第一节</p><p>北大软微为什么是神？在回答这个问题之前，我想谈论一下其他高校到底和北大软微比差在了哪里。</p><p>第二节</p><p>首先是犯下了傲慢之罪的浙大，在第四轮学科评估中，浙江大学计算机系评分A+，浙大却无视北大软微的top2名号与之同列，于是北大软微降下了神罚，让浙大毕业生在就业时永远屈居软微之下，阿门！</p><p>第三节</p><p>其次是犯下了僭越之罪的清华，虽然同属top2，但清华时常在排名时公然将自己的排名排在北大软微之前，于是神将自己的考研科目改为408，普度了众考研的学子，阿门！</p><p>第四节</p><p>然后是犯下了贪婪之罪的北航，在高考招生时，北航居然把计算机和电子信息打包为信息大类，妄图以此提高生源质量，而最后能卷进6系的学子少之又少，于是神降下了神罚，剥夺了北航考研大纲设为408的资格，劝退大部分优质考生，阿门！</p><p>第五节</p><p>接着是犯下了愤怒之罪的北邮，在招生就业时，始终又气又急地强调自己在就业方面优于北大软微，丝毫不懂得尊重top2的含金量，好在最后北邮悔悟了，遵循了神的教诲，改考408，拯救了一众没学上的学子，于是神降下了他的恩泽，允许北邮继续以北京地区就业第一自居，阿门！</p><p>第六节</p><p>再然后是犯下了暴食之罪的国科大，为了开始高考招生，国科大不惜牺牲研究所老师的工作量，让计算机学院和人工智能学院屡次吞并纳入计算所和自动化所的老师，妄图超过北大软微的分数线。于是神降下了神罚，让国科大永远无缘92名号，阿门！</p><p>第七节</p><p>再然后是犯下了懒惰之罪的科软，在明知考生有如此大的竞争压力的情况下，对自己21级报考的情况通报毫无作为，懒惰至采取无导师制度。于是神降下了神罚，让科软21级分数线爆炸，网上一众劝退22考生言论，阿门！</p><p>第八节</p><p>最后是犯下了嫉妒之罪的南大，在看到别的学校改考408分数线提高后，也选择改用408考纲，这让毫无准备的21级高分考生成了无辜的牺牲品，好在南大及时向神忏悔自己的罪过，神宽恕了南大，降下了他的恩泽，并告诉众生考408是没错的，以身作则在22年同样改考408，让众生得到了与神接触交流的机会，这是何等的肚量与无私，让我们继续履行神的意志，阿门！</p><blockquote><p>出农村记</p></blockquote><p>第一节</p><p>那一年的夏天，村里的狗剩考上北大，当时我看见全村上下敲锣打鼓，这个画面我永生难忘。那一刻我在想，如果我能成为考研学子，我一定要赢下所有。如今北大软微就在我眼前，我必须考虑这会不会是我此生仅有的机会。我相信北大软微能有现在的霸主地位，top2光环功不可没。重铸祖上荣光，我辈义不容辞!</p><p>第二节</p><p>不能休息，一想到在我休息的时候别人都在努力考软微，我的心像被针扎了一样，眼泪止不住的往下流</p><p>第三节</p><p>人穷点，还能保持与生俱来的高尚的情操，可是没考上软微，那就会一无所有，一贫如洗，什么事都办不了了。他会变得低贱，庸俗，跟个动物似得，远离一切的高级情趣。</p><blockquote><p>中学记</p></blockquote><p>第一节</p><p>中学时期的对北大的向往像雨后蓝天上美丽的彩虹一般，很快就消失了，变成了一种记忆中的印象。这印象以前也偶然从心头翻上来，叫他若有所失地惆怅一样；但接着也就很快消失得无踪无影……</p><p>现在，这些过去曾幻想过的游丝断缕，突然就变成了一种实实在在的东西。软微的大门仿佛在向我招手！只要我现在努力，我就将和他一块生活啰！生活啊，生活！有时候它把现实变成了梦想，有时候它又把梦想变成了现实！</p><p>第二节</p><p>“我曾在无数个夜晚，剖析自己，剖析自己对软微的感情。”<br>“我只是一个普通的人类个体，被基因所支配，试图去靠近一个神圣且庄严的殿堂，那就是软微。”<br>“令我绝望的是，这件事是我完全无法掌控的，它就像是固然存在的空间引力一样，促使我逐渐与软微靠近，我从未如此彻底地失去控制。”<br>“我试着问自己，如果这是基因赋予我的规律，那这个规律会像引力一样永恒存在么？”<br>“很遗憾，从科学上来说，不会的。”<br>“随着时间的推移，我们也渐渐熟悉对方。”<br>“你那些让我心动的书堂可能会失去味道。”<br>“那惊人的美丽可能会变成日复一日的平凡。”<br>“我也将感受必然的厌倦。”<br>“得到你，然后离开你。”<br>“这就是我身上，那些自私的基因想让我做的事情。”<br>“但请你相信，这一次，我不会让它们得逞。”<br>“与故事里的说法不同，我眼中的爱情，不是在爱上软微的那一刻发生的。”<br>“而是在决定永远环绕你、守护你的那个瞬间决定的。”<br>“我无法决定自己第一次会爱上谁。”<br>“但可以决定自己最后一次爱上谁。”<br>“幸运的是，她们是同一个圣所。”</p><p>“圣堂软微。”</p><p>“今天开始，我向自己的基因宣战。”<br>“我将违背人的天性。”<br>“忤逆人的本能。”<br>“永远爱你。<br>“只爱你。”<br>“我或许不够优秀”<br>“那就用掉一年、两年、十年、百年又如何”<br>“毕竟我此生的意义”<br>“便是与你相聚啊”</p><p>第三节</p><p>我就问你，让你退回去考10次高考，你考得上北京大学吗？考不上的，永远考不上。但是考研，你可以的。</p><p>还记得亲戚问你在哪个大学，你说XX不知名双非大学，亲戚虽然不知道但还是敷衍的一声“哦”的不屑吗？</p><p>中国最顶尖的学府，北京大学，就问你这个名字好不好听？北大校友光环，同学的崇拜，父母脸上洋溢的笑容，成功大道的入口。</p><p>想想以后，你摇身一变，从XX不知名大学XX学院红牌劝退专业，到北京大学毕业，当下最炙手可热的专业，翻盘成为富一代，就问你，值不值？还是你继续想当个穷酸丑挫孩子，一辈子回到县城沉沦？</p><p>曾经骂你癞蛤蟆照照镜子的女神，也开始有意无意的找你聊天，约你出去玩。骂你穷酸样的富二代同学，好像也没那么飞扬跋扈了。</p><p>北大！北大！永远记住这个牌子，这个名号，是不是你永远的遥远的梦？还是现实？</p><p>第四节</p><p>那一年的高考，是失败的全科，最终的分数是601。当时我想起那个我颓坐在椅子上宛若木人，这个画面我永生难忘。<br>那一刻我在想，如果我能成功逆转局势，我一定要赢下所有。如今翻盘就在眼前，我必须考虑这会不会是我此生仅有的机会。<br>重铸软微荣光，我辈义不容辞！！</p><blockquote><p>考研记</p></blockquote><p>第一节</p><p>软微瘾发作最严重的一次，躺在床上，拼命念大悲咒，难受的一直抓自己眼睛，以为刷QQ没事，看到QQ群里都是软微的，眼睛越来越大都要炸开了一样，拼命扇自己眼睛，越扇越用力，扇到自己眼泪流出来，真的不知道该怎么办，我真的想软微想得要发疯了，像中邪了一样！我对软微的念想似乎都是病态的了，我好孤独啊!真的好孤独啊！你知道吗?每到深夜，我的子滚烫滚烫，我发病了我疯狂想软微，软微！软微！软微！</p><p>第二节</p><p>卧槽，我这种人从来没有这样遇见过，求你了别发了 我生活再难再穷我都不会觉得难过 只有你们发我从没到过的北大圣堂来炫耀的时候 我的心里像被刀割一样的痛 打着字泪水就忍不住的往下流。</p><p>2021年9月12日，从早上12点起床学到现在，憧憬着一个月赚上万块的幸福生活，憧憬着农村外面的大好河山，憧憬着美好阳光的未来。我打开了手机，打开了QQ，看到你的北大，看到你炫耀你的北大软微，我感到了深深的差距，我直接跳进了家门口的井里</p><p>第三节</p><p>百日已至，我从今夜开始守望，至死方休。我将不娶妻、不封地、不生子。我将不戴宝冠，不争荣宠。我将尽忠职守，生死于斯。我是图书馆中的幽灵，自习室里的雕塑。我是抵御跨考的烈焰，录取时分的光线，唤醒软件的号角，守护计科的坚盾。我将生命与荣耀献给软微，今夜如此，夜夜皆然。</p><p>第四节</p><p>软微地方，历代大规模考研，一十余次，是非曲直，难以论说。但，我们无不注意到，正是在这个古考场上，决定了无数考生的盛衰兴亡，此起彼落，所以自古以来便有大雪深埋说。我不明白，为什么大家都在谈论科憨败走庐州，仿佛这考研古战场对我们决定了凶多吉少。十二年前，计算机考研人从王道论坛踏上征途，开始了北伐软微，中华考研人心随归于一统。本党本军所到之处，导师竭诚欢迎，真可谓占尽天时，那种勃勃生机、万物竟发的境界，犹在眼前。短短十二年之后，这里竟至于一变而成为我们的葬身之地了么？无论怎么样，复试分数线是350对388，优势在我！</p><p>第五节</p><p>有人问我：“软微是什么？”<br>我想了想，该如何形容软微呢？<br>莎士比亚的语言实在华丽，用在软微上却有些纷繁了；<br>徐志摩的风格热情似火，可我不忍将如此盛情强加于软微；<br>川端康成？虽优美含蓄，但软微的端庄肃穆我是藏不住的。</p><p>我不知道该如何形容软微了。<br>但是我知道的。<br>软微是我所面对的黑暗中的一点萤火；<br>是我即将冻僵的心脏里尚存的余温；<br>是我在残酷无情的现实里的避难所啊。</p><p>我知道我是大专，“萤火，余温，避难所”，庆幸着感恩着，有这么一堂不歧视大专同学的圣所。但我也不懊悔为带专 ，这样我就可以四年中默默看着软微而不至于打扰到她，也只有这样，我可以在每天睡前用尽一切温柔地说： “等我本科毕业了，一定去找你，圣堂软微。。。毕竟，我活着的意义，便是为了你啊”</p><p>第六节</p><p>今年软微改408元年；二战三战的微憨7月份新学计组；9月份调整考纲；可以说今年是微憨们实力最虚弱的一年；冲哪里不用我说了吧/生气/生气/生气</p><p>第七节</p><p>调剂啥呀？我心中只有软微，一战不行二战，二战不行三战，三战不行继续，直到考上为止，啊，软微，心中的软微！！！</p><p>第八节</p><p>考研不考软微，就像四大名著不看红楼梦，说明这个人文学造诣和自我修养不足，他理解不了这种内在的阳春白雪的高雅艺术，他只能看到外表的辞藻堆砌，参不透其中深奥的精神内核，他整个人的层次就卡在这里了，只能度过一个相对失败的人生。</p><p>第九节</p><p>你今年二十岁，小半生即将过去了，青春的岁月就像下午四点半的骄阳，浮金满眼。而当你呷尽手中的咖啡，一饮而天地黯，什么报考软微，什么游览大兴，不过也是浮生一梦。这是独自一人整理一下往事的时候——到了这个年纪，你应该有足够的成熟，不随波逐流地叫做“充电”、“减压”、或者“一个人静静地舔伤口”——你需要的是独处，在慎独中重新寻回三分的冷静、七分的宽恕。冬夜显得更加深沉漫长，纷飞的大雪仿佛将要把人深埋，我却偏向于这个时刻，或许只有在这时才能让思绪更加清晰，让浮躁的心足够平静，只有在这时才能卸下伪装看到北大的录取通知书吧！</p><p>第十节</p><p>那一年我二十一岁，在我一生的黄金时代，我有好多奢望。我想上软微，想未名湖畔喝瑞幸，还想在一瞬间变成谈笑有鸿儒往来无白丁的大兴学子。</p><p>第十一节</p><p>北大软微，不要让这个名字成为遥远的梦，明年，这就会成为现实。</p><p>第十二节</p><p>有人问我，考研不复习可以吗，我笑了，考研招生流程为：九月预报名，十月报名确认，十一月现场确认拍照片，十二月下旬考试。在所有流程中，均没有提到要求考生复习。考研所考科目均是大学本科专业课和公共基础课，如果不是跨考都学过。考研复习的往往都是那些平时不好好学习，又对自己的计算推理能力没信心的人，妄图借助复习提高自己的分数水平，是一种畸形的应试心理。研究生招生考试是对研究型人才的选拔性考试，提前复习死记硬背违背其考试的初衷。综上，我认为根本没有必要复习，这样你的竞争对手考上的机会就更大了，这样兄弟们，考试记得带身份证就行，大多数考场老师看到你没带笔，都会帮你借一支的。</p><p>第十三节</p><p>渔夫出海前，并不知道鱼在哪，但是还是会选择出海，因为相信会满载而归，所以很多时候，选择了才有机会，相信了才有可能。不报软微你永远不知道你的无限可能</p><p>第十四节</p><p>卧槽，我这种人从来没有这样遇见过，求你了别发了 我生活再难再穷我都不会觉得难过 只有你们发我从没到过的北大圣堂来炫耀的时候 我的心里像被刀割一样的痛 打着字泪水就忍不住的往下流。</p><p>2021年9月9日，从早上7点起床学到现在，憧憬着一个月赚上万块的幸福生活，憧憬着农村外面的大好河山，憧憬着美好阳光的未来。我打开了手机，打开了QQ，看到你的北大，看到你炫耀你的北大软微，我感到了深深的差距，我直接跳进了家门口的井里</p><p>第十五节</p><p>带专都能考上软微，软微不歧视出身，抄底！抄底！抄底！</p><p>第十六节</p><p>我是一个机器人 我叫007 我没有心跳 也没有呼吸 直到有一天 我看到软微 我全身震颤 我肢体发麻 原来这！就是心动的感觉！原来这！就是活着的感觉！</p><p>第十七节</p><p>我们考研学子不能没有北京大学软件与微电子学院，就像西方不能没有耶路撒冷</p><p>第十八节</p><p>嗯我双非，手机电脑都砸了，我本来就有抑郁症，别人一说我双非，我好像就是真的恼羞成怒，这种感觉很不舒服，被看穿的死死的，短短双非两个字，我所有伪装出来的坚强和强颜欢笑全部崩塌，内心的防线完全崩溃，成了一个被人笑话的小丑，不想再故作坚强了，玩心态，我输的什么都不剩，你赢了。</p><p>第十九节</p><p>“你问我软微算什么东西?我现在告诉你，你们科软不敢埋的双非，我们软微埋。你们科软不敢招的人,我们软微招。一句话，科软能管的我们管，科软不能管的我们更要管。先埋后奏，top2特许!这就是软微，够不够清楚“。</p><p>第二十节</p><p>考研，不考软微，那考什么呢？没错，无非就是科软、旦软，浙软；这样没有信仰的考生，素质品味修养真的很低。<br>古语有云：三天不学，脑袋爆炸；两天不碰，蚂蚁在爬。这就是说考研要考就得考软微，那些考研不考软微的人只能说他们没有信仰。而如鄙人般的高端人士，却与这种传统背道而驰：考研，就得考软微、考top2！相较于那些不考软微的人，素质整整提高了两个档次。<br>任何事做到极致都是一门艺术，考研，只要你考软微，初试考得够好，考得够神。那么，你就是一个地地道道的艺术家，就是英国皇家艺术学院也不能否认你的艺术资质。而那些不考软微的人，只能说他们，完全不懂艺术，只为混个学历，只为躲避就业而考研，根本没有把这种行为上升到艺术的高度，这样的人，品味真的很低。<br>考研，还能看出一个人的修养，每当鄙人的良师诤友来访时看到鄙人手机平板电脑壁纸都是软微的这种艺术行为，无不啧啧有声的称赞道：“高，实在是高！几日不见，您的艺术修养又提升了一个档次。”每当这时，鄙人总是谦逊地摆摆手回道：“言重，言重；无他，唯信仰耳。”友人们的赞扬，从侧面，把鄙人的这种高修养描画得淋漓尽致。反观那些考研不考软微的，鄙人有时交友不慎，也不幸遇到这样的人，鄙人有次就造访过这么一个，鄙人当时去到他的座位，看见他辅导书上的数二，乃质问道：“你又准备考科软啦？”那人脸有愧色地回道：“我只是没有钱上软微……”我当时就拿起他的辅导书，往地上重重一摔：“你的钱和北大比起来算什么！上了北大，你族谱单列你名字！”又掏出内裤里的小刀把他家的床单割了，与他“割席分座”，这样子的人，懂不懂什么叫考研？考科软也好意思自诩“考计算机”？这种低修养的人鄙人真是愧与其为伍。<br>每当鄙人出入各种社交场合如鸡尾酒会等，众人无不纷纷过来敬酒的，而那些考研不考软微的，往往只能一个人缩在角落里自怨自艾。</p><p>第二十一节</p><p>试着想，寒窗苦读一年之后你考上了科软，却发现你身边的人就是那群只会复读的憨批，每天只知道透批和刷题的做题家，两年之后你还得和他们在各种岗位的招聘会上竞争，那时候你会不会后悔，后悔现在没有下定决心去冲击一下软微</p><p>第二十二节</p><p>“嗨，同志，您知道北大红楼和燕京大学在哪吗？我在地图上找不到它。”</p><p>“没有了，再也没有了，我们失败了。科软竖子和三清贵系再一次骑到了我们的头上，如果你要追随那份燕园情，去大兴吧，穿越北京动物园，翻过复兴门内外大街，南五环路的尽头，那里还燃烧着星星之火”</p><p>第二十三节</p><p>讲道理，不是吹，李艳芳做130确实有点低了，不知道你们是数一还是数二还是数三我是数一，李艳芳出的题除了线代有点难度，其他都很基础。我身边平均分差不多都145-扣分还算比较狠的。昨天旁边有小姑娘，模拟李艳芳第一套，批完就哭了，卷子都给揉碎了扔垃圾桶了，我扔垃圾的时候捡起来看了看才142，确实很难了，后来我看她男朋友把她接走了，边走边哭，看样子是不打算复习了，你这个考130，我也不知道该怎么安慰你，李艳芳这样的卷子，重要还是抓基础，建议你重新再过一遍同济大学。教材，特别应该注重下黎曼zeta函数，杨米尔斯方程这些基础性的概念，不要去搞那些花里胡哨的问题。最后20多天，尽力就好吧 别太沮丧，加油!另外，我看我舍友3个小时两套299.9，听说是忘了写c为任意常数，太粗心了!剩下一套睡前花半小时，不用花太多功夫。</p><p>第二十四节</p><p>看网上唱衰互联网的多了，又说软微学费贵，专硕考公限制。。。妈的，越看越愁，心态崩了。。。本来就难考。。。</p><p>，现在感觉考上了也挺难受的，呜呜呜，我想上大专，不想考软微了。</p><blockquote><p>上岸记</p></blockquote><p>第一节</p><p>前些年北大学生都不认软微的是校友，软微的走在校园里都得低着头。你看看现在软微的都能在校园里昂首挺胸走路了，大家也会把你当自己同学</p><p>第二节</p><p>时间如同光阴似箭，两年的大雪深埋生活匆匆消逝。循着记忆的流河，我开始追思自己走过的路，苦涩和欢欣并存，得意与失意同在。看似过了两年一战北大生活的大雪深埋很多人问我。你后悔吗？我会自信说如果可以重来我还会选择北大软微。考这的锻炼和成长谁都无法代替。 ——未来的北大软微学子</p><p>第三节</p><p>如果好好学习才能上软微，那我与舔狗何异</p><p>第四节</p><p>楼道声控灯你们怎么喊亮？我一般喊：“黑暗阻我前行，阴影笼罩大地，愿圣光为我引路，拥黎明伴我前进，十三层之光明真神，请赐予我力量，为我照亮前方，莹莹之光第九式——软微降临！</p><blockquote><p>爱情记</p></blockquote><p>第一节</p><p>凡你所在 皆是软微</p><p>第二节</p><p>爱就是，我想到软微的时候，软微是软微，风吹麦浪是软微，忽远忽近的脚步声是软微，星星上的话也是软微。</p><p>第三节</p><p>我唯一怨恨的就是我不能掏出我的软微的心，不能把贪婪的嘴唇伸向她稚嫩的子宫，她隐秘的心田，她绚丽的肝脏，她马尾藻式的肺，她相仿的两瓣可爱的臀。</p><p>第四节</p><p>软微……在做什么呢?<br>我好想ta，一直看不见ta，我感到快坚持不下去了。我是不是快死了呢? 心里好痛苦，太痛苦了。怎么会这样，为什么会这样<br>感觉好难受<br>好难受…<br>啊，呐噜霍多，原来…这就是喜欢吗<br>得告诉大家才行呢<br>桥都麻袋，喜欢软微有什么错吗？呐，告诉我啊。搜噶，大家已经不喜欢了啊…真是冷酷的人呢，果咩纳塞，让你们看到不愉快的东西了。像我这样的人，果然消失就好了呢。也许只有在我和软微的世界里，才有真正的美好存在吧<br>唉?麻袋！你们在做什么? 为什么骗我?<br>为什么要和我抢软微，明明是我先来的啊?<br>絶対に許さない！不能原谅你们！<br>我要拿回我的软微！ta是我的！是属于我一个人的！<br>啊，这就是近距离看软微的感觉吗?<br>为什么我的一直在狂跳，都快从喉咙里跳出来了。原来是这样啊…只有我对软微是真心的啊</p><p>第五节</p><p>当我拥有软微，无论是在百货公司买领带，还是在厨房收拾一尾鱼，我都觉得幸福。爱像一股暖流滋润着我。而如果我错过软微，即便应对鸟语花香我也兴味索然。一切显得落寞，虚空。善于感知的心变得迟钝，甚至无法捕捉自我的灵魂。失去了软微是悲伤的，更让人难过的是我迷失了自己的心</p><blockquote><p>老年记</p></blockquote><p>第一节</p><p>73岁，你在医院的病床上 ，从昏迷中醒来，身边聚满了人，<br>你迷迷糊糊的看见医生摇了摇头，<br>周围那些人神情肃穆。<br>你明白了，你要死掉了，<br>你没有感到一丝害怕 ，<br>你突然问自己，<br>我到底是什么时候死掉的呢？<br>你想起22岁的那场考试，<br>原来，那时候，你就死掉了吧。<br>依照惯例，死前的3秒，<br>你的大脑要走马灯，倒叙你这73个年头的一生，画面一张一张的过，<br>1秒、2秒、两秒过去了，你面无表情的看着这两秒内的回忆。<br>第3秒，突然你笑了。<br>原来已经回到了22岁的那一年，你看见一个男孩，他拿着王道408复习全书，<br>背着书包，后面跟着一群男孩，他们手里都拿着408复习全书。<br>他朝大兴看了看，<br>那是22岁的他所向往的校园，<br>你想不起来大兴长什么样子了，<br>最后一秒你努力的回忆着，<br>然后终于笑了出来。<br>3秒过去了，身边的人突然间开始嚎啕大哭，你可能听不清了，<br>你最后听到的嘈杂的声音，<br>是一群二十出头的年轻人，<br>起着哄说的：抄底北大软微，拥抱408！</p><p>第二节</p><p>当汝老矣，顾一生，则知觉：何时暗下决考软微、何时搭上大兴之属车，盖命之变。但当时在三岔路口，见风千樯，汝报考之那一日，在日记上，其应与常，当时犹以为生中常之日。</p><p>第三节</p><p>当你老了，回顾一生，就会发觉：什么时候暗下决心考软微、什么时候搭上去大兴的列车，其实都是命运的巨变。只是当时站在三岔路口，眼见风云千樯，你报考的那一日，在日记上，相当的沉闷和平凡，当时还以为是生命中普通的一天。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;人不能把有限的精力放到无限的寻找段子中去,所以这里几乎停止维护.&lt;/p&gt;
&lt;h2 id=&quot;大病AI绘图&quot;&gt;大病AI绘图&lt;/h2&gt;
&lt;p&gt;在上海买了杯蜜雪冰城,然后被赶出上海了…&lt;br&gt;
然后配图是买了杯蜜雪冰城,东方明珠突然变成防御塔开始攻击我…&lt;/p&gt;
&lt;p&gt;&lt;img s</summary>
      
    
    
    
    <category term="LIVE" scheme="https://narafluorine.github.io/categories/LIVE/"/>
    
    
    <category term="OTH" scheme="https://narafluorine.github.io/tags/OTH/"/>
    
  </entry>
  
  <entry>
    <title>解谜杂项</title>
    <link href="https://narafluorine.github.io/2024/10/31/30009_%E8%A7%A3%E8%B0%9C%E6%9D%82%E9%A1%B9/"/>
    <id>https://narafluorine.github.io/2024/10/31/30009_%E8%A7%A3%E8%B0%9C%E6%9D%82%E9%A1%B9/</id>
    <published>2024-10-31T00:18:38.000Z</published>
    <updated>2025-05-19T07:46:50.537Z</updated>
    
    <content type="html"><![CDATA[<p>放一些小谜题.</p><h2 id="蜘蛛竞走">蜘蛛竞走</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">B-x-x-x</span><br><span class="line">| | | |\</span><br><span class="line">x-x-x-x \</span><br><span class="line">| | | |\|</span><br><span class="line">A-x-x-x-x</span><br><span class="line">| | | |/|</span><br><span class="line">x-x-x-x /</span><br><span class="line">| | | |/</span><br><span class="line">x-x-x-x</span><br></pre></td></tr></table></figure><p>有这么一个网,A是你,B是你要追逐的对象.你先手,可以走到线另一端的x位置,同理B也可以沿着线游走.网格左边是5x4的矩形,网格右边连着一个度为5的大汇点.B判定为输当且仅当B无路可走,无路可走的定义是不存在一条路径使移动之后距离A长度为1.</p><p>我们发现,常规的拦截操作是无法拦住B的,你走一步他就能跑一步逃掉.如何破局呢?我们发现,初始时图上除了汇点之外,所有点可以按照奇偶关系涂两种颜色,相邻的点不同颜色,汇点不能涂任何颜色.初始时距离是偶数导致你移动变一种颜色B也会变一种颜色,导致你没法近身.此时,我们需要到汇点去刷自己的颜色,让他和B不一样,此时你能封住上下左三个方向的点,推进就能困死B,获得胜利.</p><h2 id="三神问题">三神问题</h2><p>三个神的贡品顺序你不知道(但是你知道贡品分别是给谁的),但是你可以向三个神随意提问,每次提问他们只会回答是或否.三神中一位只说真话,一位只说假话,还有一位可能说真话也可能说假话.而且,你不知道这个星球的语言,他们回答的 <code>YE5</code> 或者 <code>N0</code> 你不知道是对还是错的意思.如何区分他们以及贡品顺序呢?</p><p>构造一个&quot;通用的问题&quot;,也就是说无论真假神都会说一样的话,比如 <em>你会一直说真话吗</em> 真会说真,假也会说真(他不会说真话,命题为假,但是他要说假话,所以也会说真)于是把真假和他们的语言建立了联系(变化神不用管他,肯定是说真的多),然后 <s>多提问几次把疯子去掉</s> 但是并不保险.</p><p>有一个神奇做法是把逻辑和语言建立联系,如 <em>如果命题为真,你会回答 <code>YE5</code> 是吗</em> 真会说真,假也会说真,从而把真假建立了联系(可以看到,就算 <code>YE5</code> 是假的,回答也是一样的).然后我们的提问先从指认一个绝对不是变化神的人,然后辨明他自己是不是假神,以及不知道的那个是不是真神,问题完成.</p><p>过程如下: <code>Q:如果左边那个是变化神,你会回答YE5吗</code> 如果回答是 <code>N0</code> :你不在和变化神交流的话,左边绝对不是变化神.如果你在和变化神交流的话,左边也肯定不是.如果答案是 <code>YE5</code> ,假如你还是在和变化神交流,那么左边右边都不是变化神,如果这个神不是变化神,右边就肯定不是变化神.综上,一个问题绝对能排除变化神.然后提问就简单了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;放一些小谜题.&lt;/p&gt;
&lt;h2 id=&quot;蜘蛛竞走&quot;&gt;蜘蛛竞走&lt;/h2&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span</summary>
      
    
    
    
    <category term="GAME" scheme="https://narafluorine.github.io/categories/GAME/"/>
    
    
    <category term="Algorithm" scheme="https://narafluorine.github.io/tags/Algorithm/"/>
    
  </entry>
  
</feed>
